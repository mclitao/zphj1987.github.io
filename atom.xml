<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[zphj1987'Blog]]></title>
  <subtitle><![CDATA[现在所学，终有所用]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.zphj1987.com/"/>
  <updated>2015-11-01T15:37:29.310Z</updated>
  <id>http://www.zphj1987.com/</id>
  
  <author>
    <name><![CDATA[zphj1987]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Mon失效处理方法]]></title>
    <link href="http://www.zphj1987.com/2015/11/01/Mon%E5%A4%B1%E6%95%88%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/"/>
    <id>http://www.zphj1987.com/2015/11/01/Mon失效处理方法/</id>
    <published>2015-11-01T15:34:26.000Z</published>
    <updated>2015-11-01T15:37:29.310Z</updated>
    <content type="html"><![CDATA[<p>假设环境为三个mon，主机名为mon1、mon2、mon3，现在mon3上面的系统盘损坏，mon的数据完全丢失，现在需要对mon3进行恢复处理</p>
<p>1、停止所有mon进程，可以不停其他进程，需要停止内核客户端以及对外的服务，防止卡死<br>在mon1机器上执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/ceph stop mon</span><br></pre></td></tr></table></figure></p>
<p>在mon2机器上执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/ceph stop mon</span><br></pre></td></tr></table></figure></p>
<p>2、分别在mon主机上获取当前的monmap<br>在mon1机器上执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph-mon -i mon1 --extract-monmap /tmp/monmap</span><br></pre></td></tr></table></figure></p>
<p>备份原始monmap<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /tmp/monmap /tmp/monmapbk</span><br></pre></td></tr></table></figure></p>
<p>在mon2机器上执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph-mon -i mon2 --extract-monmap /tmp/monmap</span><br></pre></td></tr></table></figure></p>
<p>备份原始monmap<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /tmp/monmap /tmp/monmapbk</span><br></pre></td></tr></table></figure></p>
<p>3、处理monmap，去掉损坏的mon3的map信息<br>在mon1机器上执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">monmaptool /tmp/monmap --rm mon3</span><br></pre></td></tr></table></figure></p>
<p>在mon2机器上执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">monmaptool /tmp/monmap --rm mon3</span><br></pre></td></tr></table></figure></p>
<p>4、导入修改后的monmap信息<br>在mon1机器上执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph-mon -i mon1 --inject-monmap /tmp/monmap</span><br></pre></td></tr></table></figure></p>
<p>在mon2机器上执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph-mon -i mon1 --inject-monmap /tmp/monmap</span><br></pre></td></tr></table></figure></p>
<p>5、启动mon进程<br>在mon1机器上执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/ceph start mon</span><br></pre></td></tr></table></figure></p>
<p>在mon2机器上执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/ceph start mon</span><br></pre></td></tr></table></figure></p>
<p>6、检查当前的mon信息，应该显示的是只有两个mon,再新加mon即可<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph <span class="operator">-s</span></span><br></pre></td></tr></table></figure></p>
<hr>
<p>写于：2015年11月1日</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>假设环境为三个mon，主机名为mon1、mon2、mon3，现在mon3上面的系统盘损坏，mon的数据完全丢失，现在需要对mon3进行恢复处理</p>
<p>1、停止所有mon进程，可以不停其他进程，需要停止内核客户端以及对外的服务，防止卡死<br>在mon1机器上执行<b]]>
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在页面中嵌入自适应视频的方法]]></title>
    <link href="http://www.zphj1987.com/2015/10/13/%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%B5%8C%E5%85%A5%E8%87%AA%E9%80%82%E5%BA%94%E8%A7%86%E9%A2%91%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://www.zphj1987.com/2015/10/13/在页面中嵌入自适应视频的方法/</id>
    <published>2015-10-13T13:50:23.000Z</published>
    <updated>2015-10-13T14:46:32.123Z</updated>
    <content type="html"><![CDATA[<p>准备在博客中嵌入视频，从视频网站获取的embed代码是指定宽度和高度的，这样在一些窗口或者移动端进行访问的时候，就可能视频溢出屏幕了，体验不好，实际上这几年响应式网站比较流行，也就是能让内容自动的适应窗口的大小</p>
<p>屏幕的宽度可以用 <code>width：100%</code> 进行设置，高度看到有个 <code>height:100%</code> 设置后height实际取的是上一层的高度的百分比，如果没设置的话，这个就为0，看到嵌入的视频就没有高度了，网上关于这个的资料很多，可以搜索下</p>
<p>关于视频的自适应看到  <a href="https://developers.google.com/web/fundamentals/media/video/size-videos-correctly?hl=zh-cn#section" title="google 自适应设置建议" target="_blank" rel="external">google 自适应设置建议</a> 这个介绍的很好<br><a id="more"></a><br>主要是这段代码:<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="class">.video-container</span> <span class="rules">&#123;</span><br><span class="line">        <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">padding-bottom</span>:<span class="value"> <span class="number">56.25%</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">padding-top</span>:<span class="value"> <span class="number">30px</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">overflow</span>:<span class="value"> hidden</span></span>;</span><br><span class="line">    <span class="rule">&#125;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="class">.video-container</span> <span class="tag">iframe</span>,</span><br><span class="line">    <span class="class">.video-container</span> <span class="tag">object</span>,</span><br><span class="line">    <span class="class">.video-container</span> <span class="tag">embed</span> <span class="rules">&#123;</span><br><span class="line">        <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">    <span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面的56.25%实际是16:9的视频的值，这个可以根据自己的视频高宽比进行设置</p>
<p>我自己的代码是这样的：<br>css的代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="class">.article-entry</span> <span class="class">.video-container</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">padding-bottom</span>:<span class="value"> <span class="number">56.25%</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">padding-top</span>:<span class="value"> <span class="number">30px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">overflow</span>:<span class="value"> hidden</span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="class">.article-entry</span> <span class="class">.video-container</span> <span class="tag">embed</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="class">.article-entry</span> <span class="class">.video-container</span> <span class="tag">object</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>嵌入的页面html代码为：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;div class="video-container"&gt; &lt;object&gt;</span><br><span class="line">&lt;param name="allowFullScreen" value="true"&gt;&lt;param name="flashVars" value="id=23750026 " /&gt;&lt;param name="movie" value="http://i7.imgs.letv.com/player/swfPlayer.swf?autoplay=0" /&gt;&lt;embed   src="http://i7.imgs.letv.com/player/swfPlayer.swf?autoplay=0" flashVars="id=23750026"allowFullScreen="true" type="application/x-shockwave-flash" &gt;&lt;/embed&gt;&lt;/object&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>添加了一个class标签，去掉了网站视频分享代码里面的width和height的值<br>下面为一个视频的例子：可以调整浏览器查看效果</p>
<div class="video-container"><object><param name="allowFullScreen" value="true"><param name="flashVars" value="id=23739460 "><param name="movie" value="http://i7.imgs.letv.com/player/swfPlayer.swf?autoplay=0"><embed src="http://i7.imgs.letv.com/player/swfPlayer.swf?autoplay=0" flashvars="id=23739460" allowfullscreen="true" type="application/x-shockwave-flash"></object><br></div>

<p><em>ps：测试了很多网站的视频上传，发现还是乐视的清晰度最高，没有压缩很多，并且视频提供高清的观看 </em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>准备在博客中嵌入视频，从视频网站获取的embed代码是指定宽度和高度的，这样在一些窗口或者移动端进行访问的时候，就可能视频溢出屏幕了，体验不好，实际上这几年响应式网站比较流行，也就是能让内容自动的适应窗口的大小</p>
<p>屏幕的宽度可以用 <code>width：100%</code> 进行设置，高度看到有个 <code>height:100%</code> 设置后height实际取的是上一层的高度的百分比，如果没设置的话，这个就为0，看到嵌入的视频就没有高度了，网上关于这个的资料很多，可以搜索下</p>
<p>关于视频的自适应看到  <a href="https://developers.google.com/web/fundamentals/media/video/size-videos-correctly?hl=zh-cn#section" title="google 自适应设置建议">google 自适应设置建议</a> 这个介绍的很好<br>]]>
    
    </summary>
    
      <category term="杂七杂八" scheme="http://www.zphj1987.com/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[inkscope管理平台试用]]></title>
    <link href="http://www.zphj1987.com/2015/10/12/inkscope%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E8%AF%95%E7%94%A8/"/>
    <id>http://www.zphj1987.com/2015/10/12/inkscope管理平台试用/</id>
    <published>2015-10-12T13:28:22.000Z</published>
    <updated>2015-10-13T14:46:38.365Z</updated>
    <content type="html"><![CDATA[<p>下面为inkscope的管理平台的操作记录，一直听说过这个管理平台，但一直没有真正的去配置过，花了一点时间进行了配置</p>
<p>inkscope的管理平台总结下有下面几个：</p>
<ul>
<li>使用sysprobe获取节点的操作系统监控信息</li>
<li>使用cephprobe去跟ceph集群进行交互，调用了ceph-rest-api进行集群的数据和操作交互</li>
<li>使用mongodb进行监控信息的存储</li>
</ul>
<p>总体来说架构简单，很容易配置，并且官方提供了包，是比较成熟的管理平台了，具体的可以看下面的这个视频<br><a id="more"></a></p>
<div class="video-container"> <object><br><param name="allowFullScreen" value="true"><param name="flashVars" value="id=23750026 "><param name="movie" value="http://i7.imgs.letv.com/player/swfPlayer.swf?autoplay=0"><embed src="http://i7.imgs.letv.com/player/swfPlayer.swf?autoplay=0" flashvars="id=23750026" allowfullscreen="true" type="application/x-shockwave-flash"></object><br></div>

]]></content>
    <summary type="html">
    <![CDATA[<p>下面为inkscope的管理平台的操作记录，一直听说过这个管理平台，但一直没有真正的去配置过，花了一点时间进行了配置</p>
<p>inkscope的管理平台总结下有下面几个：</p>
<ul>
<li>使用sysprobe获取节点的操作系统监控信息</li>
<li>使用cephprobe去跟ceph集群进行交互，调用了ceph-rest-api进行集群的数据和操作交互</li>
<li>使用mongodb进行监控信息的存储</li>
</ul>
<p>总体来说架构简单，很容易配置，并且官方提供了包，是比较成熟的管理平台了，具体的可以看下面的这个视频<br>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[查询osd上的pg数]]></title>
    <link href="http://www.zphj1987.com/2015/10/04/%E6%9F%A5%E8%AF%A2osd%E4%B8%8A%E7%9A%84pg%E6%95%B0/"/>
    <id>http://www.zphj1987.com/2015/10/04/查询osd上的pg数/</id>
    <published>2015-10-03T16:02:06.000Z</published>
    <updated>2015-10-08T16:13:00.758Z</updated>
    <content type="html"><![CDATA[<p>本文中的命令的第一版来源于国外的一个博客，后面的版本为我自己修改的版本</p>
<p>查询的命令如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph pg dump | awk <span class="string">'</span><br><span class="line"> /^pg_stat/ &#123; col=1; while($col!="up") &#123;col++&#125;; col++ &#125;</span><br><span class="line"> /^[0-9a-f]+\.[0-9a-f]+/ &#123; match($0,/^[0-9a-f]+/); pool=substr($0, RSTART, RLENGTH); poollist[pool]=0;</span><br><span class="line"> up=$col; i=0; RSTART=0; RLENGTH=0; delete osds; while(match(up,/[0-9]+/)&gt;0) &#123; osds[++i]=substr(up,RSTART,RLENGTH); up = substr(up, RSTART+RLENGTH) &#125;</span><br><span class="line"> for(i in osds) &#123;array[osds[i],pool]++; osdlist[osds[i]];&#125;</span><br><span class="line">&#125;</span><br><span class="line">END &#123;</span><br><span class="line"> printf("\n");</span><br><span class="line"> printf("pool :\t"); for (i in poollist) printf("%s\t",i); printf("| SUM \n");</span><br><span class="line"> for (i in poollist) printf("--------"); printf("----------------\n");</span><br><span class="line"> for (i in osdlist) &#123; printf("osd.%i\t", i); sum=0;</span><br><span class="line"> for (j in poollist) &#123; printf("%i\t", array[i,j]); sum+=array[i,j]; poollist[j]+=array[i,j] &#125;; printf("| %i\n",sum) &#125;</span><br><span class="line"> for (i in poollist) printf("--------"); printf("----------------\n");</span><br><span class="line"> printf("SUM :\t"); for (i in poollist) printf("%s\t",poollist[i]); printf("|\n");</span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>默认的输出如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pool :	<span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	| SUM </span><br><span class="line">----------------------------------------</span><br><span class="line">osd.<span class="number">4</span>	<span class="number">54</span>	<span class="number">133</span>	<span class="number">79</span>	| <span class="number">266</span></span><br><span class="line">osd.<span class="number">5</span>	<span class="number">57</span>	<span class="number">104</span>	<span class="number">88</span>	| <span class="number">249</span></span><br><span class="line">osd.<span class="number">6</span>	<span class="number">61</span>	<span class="number">132</span>	<span class="number">86</span>	| <span class="number">279</span></span><br><span class="line">osd.<span class="number">7</span>	<span class="number">54</span>	<span class="number">114</span>	<span class="number">85</span>	| <span class="number">253</span></span><br><span class="line">osd.<span class="number">8</span>	<span class="number">63</span>	<span class="number">123</span>	<span class="number">85</span>	| <span class="number">271</span></span><br><span class="line">osd.<span class="number">0</span>	<span class="number">62</span>	<span class="number">120</span>	<span class="number">87</span>	| <span class="number">269</span></span><br><span class="line">osd.<span class="number">1</span>	<span class="number">52</span>	<span class="number">126</span>	<span class="number">81</span>	| <span class="number">259</span></span><br><span class="line">osd.<span class="number">2</span>	<span class="number">52</span>	<span class="number">103</span>	<span class="number">88</span>	| <span class="number">243</span></span><br><span class="line">osd.<span class="number">3</span>	<span class="number">57</span>	<span class="number">125</span>	<span class="number">89</span>	| <span class="number">271</span></span><br><span class="line">----------------------------------------</span><br><span class="line">SUM :	<span class="number">512</span>	<span class="number">1080</span>	<span class="number">768</span>	|</span><br></pre></td></tr></table></figure></p>
<p>这个有个问题就是osd是乱序的，并且对于一个存储池来说不清楚哪个osd的pg是最多的</p>
<h3 id="重构第一版：">重构第一版：</h3><p>跟上面的相比按顺序来排列</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ceph pg dump | awk <span class="string">'</span><br><span class="line"> /^pg_stat/ &#123; col=1; while($col!="up") &#123;col++&#125;; col++ &#125;</span><br><span class="line"> /^[0-9a-f]+\.[0-9a-f]+/ &#123; match($0,/^[0-9a-f]+/); pool=substr($0, RSTART, RLENGTH); poollist[pool]=0;</span><br><span class="line"> up=$col; i=0; RSTART=0; RLENGTH=0; delete osds; while(match(up,/[0-9]+/)&gt;0) &#123; osds[++i]=substr(up,RSTART,RLENGTH); up = substr(up, RSTART+RLENGTH) &#125;</span><br><span class="line"> for(i in osds) &#123;array[osds[i],pool]++; osdlist[osds[i]];&#125;</span><br><span class="line">&#125;</span><br><span class="line">END &#123;</span><br><span class="line"> printf("\n");</span><br><span class="line"> slen=asorti(poollist,newpoollist);</span><br><span class="line"> printf("pool :\t");for (i=1;i&lt;=slen;i++) &#123;printf("%s\t", newpoollist[i])&#125;; printf("| SUM \n");</span><br><span class="line"> for (i in poollist) printf("--------"); printf("----------------\n");</span><br><span class="line"> slen1=asorti(osdlist,newosdlist)</span><br><span class="line"> delete poollist;</span><br><span class="line"> for (i=1;i&lt;=slen1;i++) &#123; printf("osd.%i\t", newosdlist[i]); sum=0; </span><br><span class="line"> for (j=1;j&lt;=slen;j++)  &#123; printf("%i\t", array[newosdlist[i],newpoollist[j]]); sum+=array[newosdlist[i],newpoollist[j]]; poollist[j]+=array[newosdlist[i],newpoollist[j]] &#125;; printf("| %i\n",sum)</span><br><span class="line">&#125; </span><br><span class="line">for (i in poollist) printf("--------"); printf("----------------\n");</span><br><span class="line">slen2=asorti(poollist,newpoollist);</span><br><span class="line"> printf("SUM :\t"); for (i=1;i&lt;=slen2;i++) printf("%s\t",poollist[newpoollist[i]]); printf("|\n");</span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure>
<p>输出结果为下面的，可以看到现在是按顺序来的，存储池是顺序的，osd编号也是顺序的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pool :	<span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	| SUM </span><br><span class="line">----------------------------------------</span><br><span class="line">osd.<span class="number">0</span>	<span class="number">62</span>	<span class="number">120</span>	<span class="number">87</span>	| <span class="number">269</span></span><br><span class="line">osd.<span class="number">1</span>	<span class="number">52</span>	<span class="number">126</span>	<span class="number">81</span>	| <span class="number">259</span></span><br><span class="line">osd.<span class="number">2</span>	<span class="number">52</span>	<span class="number">103</span>	<span class="number">88</span>	| <span class="number">243</span></span><br><span class="line">osd.<span class="number">3</span>	<span class="number">57</span>	<span class="number">125</span>	<span class="number">89</span>	| <span class="number">271</span></span><br><span class="line">osd.<span class="number">4</span>	<span class="number">54</span>	<span class="number">133</span>	<span class="number">79</span>	| <span class="number">266</span></span><br><span class="line">osd.<span class="number">5</span>	<span class="number">57</span>	<span class="number">104</span>	<span class="number">88</span>	| <span class="number">249</span></span><br><span class="line">osd.<span class="number">6</span>	<span class="number">61</span>	<span class="number">132</span>	<span class="number">86</span>	| <span class="number">279</span></span><br><span class="line">osd.<span class="number">7</span>	<span class="number">54</span>	<span class="number">114</span>	<span class="number">85</span>	| <span class="number">253</span></span><br><span class="line">osd.<span class="number">8</span>	<span class="number">63</span>	<span class="number">123</span>	<span class="number">85</span>	| <span class="number">271</span></span><br><span class="line">----------------------------------------</span><br><span class="line">SUM :	<span class="number">512</span>	<span class="number">1080</span>	<span class="number">768</span>	|</span><br></pre></td></tr></table></figure>
<h3 id="重构第三版：">重构第三版：</h3><p>包含osd pool的排序，包含osd的排序，输出平均pg数目，输出最大的osd编号，输出超过平均值的百分比</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph pg dump | awk <span class="string">'</span><br><span class="line"> /^pg_stat/ &#123; col=1; while($col!="up") &#123;col++&#125;; col++ &#125;</span><br><span class="line"> /^[0-9a-f]+\.[0-9a-f]+/ &#123; match($0,/^[0-9a-f]+/); pool=substr($0, RSTART, RLENGTH); poollist[pool]=0;</span><br><span class="line"> up=$col; i=0; RSTART=0; RLENGTH=0; delete osds; while(match(up,/[0-9]+/)&gt;0) &#123; osds[++i]=substr(up,RSTART,RLENGTH); up = substr(up, RSTART+RLENGTH) &#125;</span><br><span class="line"> for(i in osds) &#123;array[osds[i],pool]++; osdlist[osds[i]];&#125;</span><br><span class="line">&#125;</span><br><span class="line">END &#123;</span><br><span class="line"> printf("\n");</span><br><span class="line"> slen=asorti(poollist,newpoollist);</span><br><span class="line"> printf("pool :\t");for (i=1;i&lt;=slen;i++) &#123;printf("%s\t", newpoollist[i])&#125;; printf("| SUM \n");</span><br><span class="line"> for (i in poollist) printf("--------"); printf("----------------\n");</span><br><span class="line"> slen1=asorti(osdlist,newosdlist)</span><br><span class="line"> delete poollist;</span><br><span class="line"> for (i=1;i&lt;=slen1;i++) &#123; printf("osd.%i\t", newosdlist[i]); sum=0; </span><br><span class="line"> for (j=1;j&lt;=slen;j++)  &#123; printf("%i\t", array[newosdlist[i],newpoollist[j]]); sum+=array[newosdlist[i],newpoollist[j]]; poollist[j]+=array[newosdlist[i],newpoollist[j]];if(array[newosdlist[i],newpoollist[j]] != 0)&#123;poolhasid[j]+=1 &#125;;if(array[newosdlist[i],newpoollist[j]]&gt;maxpoolosd[j])&#123;maxpoolosd[j]=array[newosdlist[i],newpoollist[j]];maxosdid[j]=newosdlist[i]&#125;&#125;; printf("| %i\n",sum)&#125; </span><br><span class="line">for (i in poollist) printf("--------"); printf("----------------\n");</span><br><span class="line">slen2=asorti(poollist,newpoollist);</span><br><span class="line"> printf("SUM :\t"); for (i=1;i&lt;=slen2;i++) printf("%s\t",poollist[newpoollist[i]]); printf("|\n");</span><br><span class="line"> printf("AVE :\t"); for (i=1;i&lt;=slen2;i++) printf("%d\t",poollist[newpoollist[i]]/poolhasid[i]); printf("|\n");</span><br><span class="line"> printf("max :\t"); for (i=1;i&lt;=slen2;i++) printf("%s\t",maxpoolosd[i]); printf("|\n");</span><br><span class="line"> printf("osdid :\t"); for (i=1;i&lt;=slen2;i++) printf("osd.%s\t",maxosdid[i]); printf("|\n");</span><br><span class="line"> printf("per:\t"); for (i=1;i&lt;=slen2;i++) printf("%.1f%\t",100*(maxpoolosd[i]-poollist[newpoollist[i]]/poolhasid[i])/(poollist[newpoollist[i]]/poolhasid[i])); printf("|\n");</span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure>
<p>输出如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pool :	<span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	| SUM </span><br><span class="line">----------------------------------------</span><br><span class="line">osd.<span class="number">0</span>	<span class="number">62</span>	<span class="number">120</span>	<span class="number">87</span>	| <span class="number">269</span></span><br><span class="line">osd.<span class="number">1</span>	<span class="number">52</span>	<span class="number">126</span>	<span class="number">81</span>	| <span class="number">259</span></span><br><span class="line">osd.<span class="number">2</span>	<span class="number">52</span>	<span class="number">103</span>	<span class="number">88</span>	| <span class="number">243</span></span><br><span class="line">osd.<span class="number">3</span>	<span class="number">57</span>	<span class="number">125</span>	<span class="number">89</span>	| <span class="number">271</span></span><br><span class="line">osd.<span class="number">4</span>	<span class="number">54</span>	<span class="number">133</span>	<span class="number">79</span>	| <span class="number">266</span></span><br><span class="line">osd.<span class="number">5</span>	<span class="number">57</span>	<span class="number">104</span>	<span class="number">88</span>	| <span class="number">249</span></span><br><span class="line">osd.<span class="number">6</span>	<span class="number">61</span>	<span class="number">132</span>	<span class="number">86</span>	| <span class="number">279</span></span><br><span class="line">osd.<span class="number">7</span>	<span class="number">54</span>	<span class="number">114</span>	<span class="number">85</span>	| <span class="number">253</span></span><br><span class="line">osd.<span class="number">8</span>	<span class="number">63</span>	<span class="number">123</span>	<span class="number">85</span>	| <span class="number">271</span></span><br><span class="line">----------------------------------------</span><br><span class="line">SUM :	<span class="number">512</span>	<span class="number">1080</span>	<span class="number">768</span>	|</span><br><span class="line">AVE :	<span class="number">56</span>	<span class="number">120</span>	<span class="number">85</span>	|</span><br><span class="line">max :	<span class="number">63</span>	<span class="number">133</span>	<span class="number">89</span>	|</span><br><span class="line">osdid :	osd.<span class="number">8</span>	osd.<span class="number">4</span>	osd.<span class="number">3</span>	|</span><br><span class="line">per:	<span class="number">10.7</span>%	<span class="number">10.8</span>%	<span class="number">4.3</span>%	|</span><br></pre></td></tr></table></figure></p>
<hr>
<p>上面的处理使用的是awk处理，开始的时候看不懂什么意思，然后就去看了这本书 <code>The AWK Programming Language</code> ,网上说这个是awk的圣经，这本书在京东卖1000RMB+,可见这本书的价值，下载地址为： <a href="http://pan.baidu.com/s/1gdwbF71" target="_blank" rel="external">http://pan.baidu.com/s/1gdwbF71</a>，关于原始脚本的意思在这里做一个简单的语法的解释，以及作者脚本的逻辑。</p>
<hr>
<h3 id="语法的解释">语法的解释</h3><blockquote>
<p>/^pg_stat/ { col=1; while($col!=”up”) {col++}; col++ }</p>
</blockquote>
<p>这个是匹配pg dump 的输出结果里面pg_stat那个字段，开始计数为1，不是up值就将col的值加1，这个匹配到的就是我们经常看到的[1,10]这个值最后的col++是将col值+1,因为字段里面有up,up_primary,我们需要的是up_primary</p>
<blockquote>
<p>/^[0-9a-f]+.[0-9a-f]+/ { match($0,/^[0-9a-f]+/); pool=substr($0, RSTART, RLENGTH); poollist[pool]=0;</p>
</blockquote>
<p>这个是匹配前面的 1.17a pg号 ，使用自带的match函数 做字符串的过滤统计匹配.号前面的存储池ID， 并得到 RSTART, RLENGTH 值，这个是取到前面的存储池ID，使用substr 函数，就可以得到pool的值了，poollist[pool]=0，是将数组的值置为0</p>
<blockquote>
<p>up=$col; i=0; RSTART=0; RLENGTH=0; delete osds; while(match(up,/[0-9]+/)&gt;0) { osds[++i]=substr(up,RSTART,RLENGTH); up = substr(up, RSTART+RLENGTH) }</p>
</blockquote>
<p>先将变量置0，然后将osd编号一个个输入到osds[i]的数组当中去</p>
<blockquote>
<p>for(i in osds) {array[osds[i],pool]++; osdlist[osds[i]];}</p>
</blockquote>
<p>将osds数组中的值输入到数组当中去，并且记录成osdlist，和数组array[osd[i],pool]</p>
<blockquote>
<p>printf(“\n”);<br> printf(“pool :\t”); for (i in poollist) printf(“%s\t”,i); printf(“| SUM \n”);</p>
</blockquote>
<p>打印osd pool的编号</p>
<blockquote>
<p>for (i in poollist) printf(“————“); printf(“————————\n”);</p>
</blockquote>
<p>根据osd pool的长度打印——</p>
<blockquote>
<p>for (i in osdlist) { printf(“osd.%i\t”, i); sum=0;</p>
</blockquote>
<p>打印osd的编号</p>
<blockquote>
<p>for (j in poollist) { printf(“%i\t”, array[i,j]); sum+=array[i,j]; poollist[j]+=array[i,j] }; printf(“| %i\n”,sum) }<br>打印对应的osd的pg数目，并做求和的统计</p>
<p>for (i in poollist) printf(“————“); printf(“————————\n”);<br> printf(“SUM :\t”); for (i in poollist) printf(“%s\t”,poollist[i]); printf(“|\n”);</p>
</blockquote>
<p>打印新的poollist里面的求和的值</p>
<p>修改版本里面用到的函数</p>
<blockquote>
<p>slen1=asorti(osdlist,newosdlist)</p>
</blockquote>
<p>这个是将数组里面的下标进行排序，这里是对osd和poollist的编号进行排序 slen1是拿到数组的长度，使用for进行遍历输出</p>
<hr>
<h3 id="脚本的逻辑">脚本的逻辑</h3><ul>
<li>匹配到pg的id和pg对应的osd，</li>
<li>使用数组的方式，将统计到的osd id存储起来，</li>
<li>然后打印数组</li>
</ul>
<hr>
<p>其他资源：<br>pg设置的计算器：<br><a href="http://ceph.com/pgcalc/" target="_blank" rel="external">http://ceph.com/pgcalc/</a><br>pg的查询和设置：<br><a href="http://ceph.com/docs/master/rados/operations/placement-groups/" target="_blank" rel="external">http://ceph.com/docs/master/rados/operations/placement-groups/</a></p>
<hr>
<p>引用博客地址如下：</p>
<p><a href="http://cephnotes.ksperis.com/blog/2015/02/23/get-the-number-of-placement-groups-per-osd/" target="_blank" rel="external">http://cephnotes.ksperis.com/blog/2015/02/23/get-the-number-of-placement-groups-per-osd/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文中的命令的第一版来源于国外的一个博客，后面的版本为我自己修改的版本</p>
<p>查询的命令如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph pg dump | awk <span class="string">'</span><br><span class="line"> /^pg_stat/ &#123; col=1; while($col!="up") &#123;col++&#125;; col++ &#125;</span><br><span class="line"> /^[0-9a-f]+\.[0-9a-f]+/ &#123; match($0,/^[0-9a-f]+/); pool=substr($0, RSTART, RLENGTH); poollist[pool]=0;</span><br><span class="line"> up=$col; i=0; RSTART=0; RLENGTH=0; delete osds; while(match(up,/[0-9]+/)&gt;0) &#123; osds[++i]=substr(up,RSTART,RLENGTH); up = substr(up, RSTART+RLENGTH) &#125;</span><br><span class="line"> for(i in osds) &#123;array[osds[i],pool]++; osdlist[osds[i]];&#125;</span><br><span class="line">&#125;</span><br><span class="line">END &#123;</span><br><span class="line"> printf("\n");</span><br><span class="line"> printf("pool :\t"); for (i in poollist) printf("%s\t",i); printf("| SUM \n");</span><br><span class="line"> for (i in poollist) printf("--------"); printf("----------------\n");</span><br><span class="line"> for (i in osdlist) &#123; printf("osd.%i\t", i); sum=0;</span><br><span class="line"> for (j in poollist) &#123; printf("%i\t", array[i,j]); sum+=array[i,j]; poollist[j]+=array[i,j] &#125;; printf("| %i\n",sum) &#125;</span><br><span class="line"> for (i in poollist) printf("--------"); printf("----------------\n");</span><br><span class="line"> printf("SUM :\t"); for (i in poollist) printf("%s\t",poollist[i]); printf("|\n");</span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[rbd的数据在哪里]]></title>
    <link href="http://www.zphj1987.com/2015/09/28/rbd%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%93%AA%E9%87%8C/"/>
    <id>http://www.zphj1987.com/2015/09/28/rbd的数据在哪里/</id>
    <published>2015-09-28T08:06:29.000Z</published>
    <updated>2015-09-28T08:21:56.250Z</updated>
    <content type="html"><![CDATA[<h3 id="创建一个rbd">创建一个rbd</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># rbd create test1 --size 4000</span></span><br></pre></td></tr></table></figure>
<h3 id="查看rbd信息">查看rbd信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># rbd info test1</span></span><br><span class="line">rbd image <span class="string">'test1'</span>:</span><br><span class="line">	size <span class="number">4000</span> MB <span class="keyword">in</span> <span class="number">1000</span> objects</span><br><span class="line">	order <span class="number">22</span> (<span class="number">4096</span> kB objects)</span><br><span class="line">	block_name_prefix: rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567</span><br><span class="line">	format: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以看出是没写入真实数据的<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># ceph df|grep rbd</span></span><br><span class="line">    rbd          <span class="number">0</span>       <span class="number">133</span>         <span class="number">0</span>        <span class="number">30627</span>M           <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h3 id="查询rbd池里面的对象信息">查询rbd池里面的对象信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># rados ls -p rbd</span></span><br><span class="line"><span class="built_in">test</span>1.rbd</span><br><span class="line">rbd_directory</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>查看下这两个对象的内容<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment">#rados -p rbd get test1.rbd test1rbd.txt</span></span><br><span class="line">[root@mytest ~]<span class="comment"># echo -e `cat test1rbd.txt`</span></span><br><span class="line">&lt;&lt;&lt; Rados Block Device Image &gt;&gt;&gt; rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567RBD001.<span class="number">005</span></span><br></pre></td></tr></table></figure></p>
<p>这个是记录的rbd镜像的信息<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># rados -p rbd get rbd_directory rbddirectory.txt</span></span><br><span class="line">[root@mytest ~]<span class="comment"># echo -e `cat rbddirectory.txt`</span></span><br><span class="line"><span class="built_in">test</span>1</span><br></pre></td></tr></table></figure></p>
<p>这个是记录的rbd的目录信息</p>
<h3 id="rbd映射到本地">rbd映射到本地</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># rbd map test1</span></span><br><span class="line">/dev/rbd0</span><br></pre></td></tr></table></figure>
<h3 id="格式化rbd设备">格式化rbd设备</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># mkfs.xfs /dev/rbd/rbd/test1 </span></span><br><span class="line"><span class="built_in">log</span> stripe unit (<span class="number">4194304</span> bytes) is too large (maximum is <span class="number">256</span>KiB)</span><br><span class="line"><span class="built_in">log</span> stripe unit adjusted to <span class="number">32</span>KiB</span><br><span class="line">meta-data=/dev/rbd/rbd/<span class="built_in">test</span>1     isize=<span class="number">256</span>    agcount=<span class="number">9</span>, agsize=<span class="number">126976</span> blks</span><br><span class="line">         =                       sectsz=<span class="number">512</span>   attr=<span class="number">2</span>, projid32bit=<span class="number">1</span></span><br><span class="line">         =                       crc=<span class="number">0</span>        finobt=<span class="number">0</span></span><br><span class="line">data     =                       bsize=<span class="number">4096</span>   blocks=<span class="number">1024000</span>, imaxpct=<span class="number">25</span></span><br><span class="line">         =                       sunit=<span class="number">1024</span>   swidth=<span class="number">1024</span> blks</span><br><span class="line">naming   =version <span class="number">2</span>              bsize=<span class="number">4096</span>   ascii-ci=<span class="number">0</span> ftype=<span class="number">0</span></span><br><span class="line"><span class="built_in">log</span>      =internal <span class="built_in">log</span>           bsize=<span class="number">4096</span>   blocks=<span class="number">2560</span>, version=<span class="number">2</span></span><br><span class="line">         =                       sectsz=<span class="number">512</span>   sunit=<span class="number">8</span> blks, lazy-count=<span class="number">1</span></span><br><span class="line">realtime =none                   extsz=<span class="number">4096</span>   blocks=<span class="number">0</span>, rtextents=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="查看当前的rbd池里面的对象信息">查看当前的rbd池里面的对象信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest mnt]<span class="comment"># rados -p rbd ls</span></span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">0000000001</span>f0</span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">0000000001</span>f1</span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">000000000174</span></span><br><span class="line"><span class="built_in">test</span>1.rbd</span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">0000000002</span>e8</span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">0000000001</span>f2</span><br><span class="line">rbd_directory</span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">0000000000</span>f8</span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">0000000003</span>e0</span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">000000000000</span></span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">00000000007</span>c</span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">0000000003</span>e7</span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">00000000026</span>c</span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">000000000001</span></span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">000000000364</span></span><br></pre></td></tr></table></figure>
<p>可以看到格式化过程中写入了一些对象信息，这些应该是存储文件系统信息的，写入的对象，数据的写入的前缀是rb.0.fa6c.6b8b4567</p>
<h3 id="查看对象数据在哪里">查看对象数据在哪里</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest <span class="number">0.1</span>_head]<span class="comment"># ceph osd map rbd rb.0.fa6c.6b8b4567.0000000001f0</span></span><br><span class="line">osdmap e78 pool <span class="string">'rbd'</span> (<span class="number">0</span>) object <span class="string">'rb.0.fa6c.6b8b4567.0000000001f0'</span> -&gt; pg <span class="number">0.1</span>cdfe181 (<span class="number">0.1</span>) -&gt; up ([<span class="number">1</span>], p1) acting ([<span class="number">1</span>], p1)</span><br></pre></td></tr></table></figure>
<p>可以查看到数据是在节点1的pg 0.1 里面</p>
<h3 id="去节点一上查看">去节点一上查看</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest <span class="number">0.1</span>_head]<span class="comment"># ll  /var/lib/ceph/osd/ceph-1/current/0.1_head/</span></span><br><span class="line">total <span class="number">4100</span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root       <span class="number">0</span> Aug <span class="number">10</span> <span class="number">14</span>:<span class="number">02</span> __head_00000001__0</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">4194304</span> Aug <span class="number">23</span> <span class="number">12</span>:<span class="number">36</span> rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">0000000001</span>f0__head_1CDFE181__0</span><br></pre></td></tr></table></figure>
<p>可以看到这个对象</p>
<p>上面的步骤实现的是: </p>
<ul>
<li>查看一个rbd image</li>
<li>查看这个image 里面的包含的对象    </li>
<li>查看这个 rbd image的对象在哪个具体的磁盘上</li>
</ul>
<p>无法实现的是查询文件系统之上的某个文件在哪里，这个在cephfs 文件系统接口中是有的</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="创建一个rbd">创建一个rbd</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># rbd create test1 --size 4000</span></span><br></pre></td></tr></table></figure>
<h3 id="查看rbd信息">查看rbd信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># rbd info test1</span></span><br><span class="line">rbd image <span class="string">'test1'</span>:</span><br><span class="line">	size <span class="number">4000</span> MB <span class="keyword">in</span> <span class="number">1000</span> objects</span><br><span class="line">	order <span class="number">22</span> (<span class="number">4096</span> kB objects)</span><br><span class="line">	block_name_prefix: rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567</span><br><span class="line">	format: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以看出是没写入真实数据的<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># ceph df|grep rbd</span></span><br><span class="line">    rbd          <span class="number">0</span>       <span class="number">133</span>         <span class="number">0</span>        <span class="number">30627</span>M           <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h3 id="查询rbd池里面的对象信息">查询rbd池里面的对象信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># rados ls -p rbd</span></span><br><span class="line"><span class="built_in">test</span>1.rbd</span><br><span class="line">rbd_directory</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[批量下载instagram图片]]></title>
    <link href="http://www.zphj1987.com/2015/09/28/%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BDinstagram%E5%9B%BE%E7%89%87/"/>
    <id>http://www.zphj1987.com/2015/09/28/批量下载instagram图片/</id>
    <published>2015-09-28T05:54:09.000Z</published>
    <updated>2015-09-28T06:09:12.916Z</updated>
    <content type="html"><![CDATA[<h3 id="下载图片：">下载图片：</h3><p>通过下面的网址可以批量下载图片，需要翻墙</p>
<p><a href="http://instrport.me/" target="_blank" rel="external">http://instrport.me/</a></p>
<h3 id="处理图片到blog可用">处理图片到blog可用</h3><p>使用脚本运行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="shebang">#! /bin/sh</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `ls ./ins`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">year=`<span class="built_in">echo</span> <span class="variable">$file</span>|cut <span class="operator">-f</span> <span class="number">1</span> <span class="operator">-d</span> -`</span><br><span class="line">mouth=`<span class="built_in">echo</span> <span class="variable">$file</span>|cut <span class="operator">-f</span> <span class="number">2</span> <span class="operator">-d</span> -`</span><br><span class="line">	</span><br><span class="line"><span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">"&#123;\"src\":\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/<span class="variable">$file</span>\",\"text\":\"\",\"y\":<span class="variable">$year</span>,\"m\":<span class="variable">$mouth</span>&#125;,\c"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>替换instagram中的相应字段即可</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="下载图片：">下载图片：</h3><p>通过下面的网址可以批量下载图片，需要翻墙</p>
<p><a href="http://instrport.me/" target="_blank" rel="external">http://instrport.me/</]]>
    </summary>
    
      <category term="instagram" scheme="http://www.zphj1987.com/tags/instagram/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[删除ceph集群mds]]></title>
    <link href="http://www.zphj1987.com/2015/09/24/%E5%88%A0%E9%99%A4ceph%E9%9B%86%E7%BE%A4mds/"/>
    <id>http://www.zphj1987.com/2015/09/24/删除ceph集群mds/</id>
    <published>2015-09-24T03:10:49.000Z</published>
    <updated>2015-09-28T08:24:14.398Z</updated>
    <content type="html"><![CDATA[<p>ceph集群新搭建以后是只有一个默认的存储池rbd的池</p>
<h2 id="创建文件接口集群">创建文件接口集群</h2><h3 id="1-创建一个元数据池">1.创建一个元数据池</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># ceph osd pool create metadata  20 20</span></span><br><span class="line">pool <span class="string">'metadata'</span> created</span><br></pre></td></tr></table></figure>
<h3 id="2-创建一个数据池">2.创建一个数据池</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># ceph osd pool create data   20 20</span></span><br><span class="line">pool <span class="string">'data'</span> created</span><br></pre></td></tr></table></figure>
<h3 id="3-创建一个文件系统">3.创建一个文件系统</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># ceph fs new ceph  metadata data</span></span><br><span class="line">new fs with metadata pool <span class="number">4</span> and data pool <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="4-创建一个mds">4.创建一个mds</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># ceph-deploy mds create mytest</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="5-部署完检查状态">5.部署完检查状态</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ceph]<span class="comment"># ceph -s</span></span><br><span class="line">    cluster <span class="number">7</span>e5469ac-ae1f-<span class="number">494</span>f-<span class="number">9913</span>-<span class="number">901</span>f60c0a76b</span><br><span class="line">     health HEALTH_OK</span><br><span class="line">     monmap e1: <span class="number">1</span> mons at &#123;mytest=<span class="number">192.168</span>.<span class="number">0.76</span>:<span class="number">6789</span>/<span class="number">0</span>&#125;</span><br><span class="line">            election epoch <span class="number">1</span>, quorum <span class="number">0</span> mytest</span><br><span class="line">     mdsmap e60: <span class="number">1</span>/<span class="number">1</span>/<span class="number">1</span> up &#123;<span class="number">0</span>=mytest=up:active&#125;</span><br><span class="line">     osdmap e70: <span class="number">2</span> osds: <span class="number">2</span> up, <span class="number">2</span> <span class="keyword">in</span></span><br><span class="line">      pgmap v252: <span class="number">104</span> pgs, <span class="number">3</span> pools, <span class="number">1962</span> bytes data, <span class="number">20</span> objects</span><br><span class="line">            <span class="number">75144</span> kB used, <span class="number">30624</span> MB / <span class="number">30697</span> MB avail</span><br><span class="line">                 <span class="number">104</span> active+clean</span><br><span class="line">  client io <span class="number">108</span> B/s wr, <span class="number">0</span> op/s</span><br></pre></td></tr></table></figure>
<h2 id="删除文件接口集群（删除mds）">删除文件接口集群（删除mds）</h2><h3 id="1-停止mds进程">1.停止mds进程</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ceph]<span class="comment"># /etc/init.d/ceph stop mds</span></span><br><span class="line">=== mds.mytest === </span><br><span class="line">Stopping Ceph mds.mytest on mytest...kill <span class="number">9638</span>...done</span><br></pre></td></tr></table></figure>
<h3 id="2-将mds状态标记为失效">2.将mds状态标记为失效</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ceph]<span class="comment"># ceph mds fail 0</span></span><br><span class="line">failed mds.<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="3-删除ceph文件系统">3.删除ceph文件系统</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ceph]<span class="comment"># ceph fs rm ceph --yes-i-really-mean-it</span></span><br></pre></td></tr></table></figure>
<h3 id="4-删除完了检查状态">4.删除完了检查状态</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ceph]<span class="comment"># ceph -s</span></span><br><span class="line">    cluster <span class="number">7</span>e5469ac-ae1f-<span class="number">494</span>f-<span class="number">9913</span>-<span class="number">901</span>f60c0a76b</span><br><span class="line">     health HEALTH_OK</span><br><span class="line">     monmap e1: <span class="number">1</span> mons at &#123;mytest=<span class="number">192.168</span>.<span class="number">0.76</span>:<span class="number">6789</span>/<span class="number">0</span>&#125;</span><br><span class="line">            election epoch <span class="number">1</span>, quorum <span class="number">0</span> mytest</span><br><span class="line">     osdmap e71: <span class="number">2</span> osds: <span class="number">2</span> up, <span class="number">2</span> <span class="keyword">in</span></span><br><span class="line">      pgmap v253: <span class="number">104</span> pgs, <span class="number">3</span> pools, <span class="number">1962</span> bytes data, <span class="number">20</span> objects</span><br><span class="line">            <span class="number">75144</span> kB used, <span class="number">30624</span> MB / <span class="number">30697</span> MB avail</span><br><span class="line">                 <span class="number">104</span> active+clean</span><br></pre></td></tr></table></figure>
<p>可以看到已经没有了mds的那一条了</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ceph集群新搭建以后是只有一个默认的存储池rbd的池</p>
<h2 id="创建文件接口集群">创建文件接口集群</h2><h3 id="1-创建一个元数据池">1.创建一个元数据池</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># ceph osd pool create metadata  20 20</span></span><br><span class="line">pool <span class="string">'metadata'</span> created</span><br></pre></td></tr></table></figure>
<h3 id="2-创建一个数据池">2.创建一个数据池</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># ceph osd pool create data   20 20</span></span><br><span class="line">pool <span class="string">'data'</span> created</span><br></pre></td></tr></table></figure>
<h3 id="3-创建一个文件系统">3.创建一个文件系统</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># ceph fs new ceph  metadata data</span></span><br><span class="line">new fs with metadata pool <span class="number">4</span> and data pool <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="4-创建一个mds">4.创建一个mds</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># ceph-deploy mds create mytest</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ceph客户端服务端属性匹配关系]]></title>
    <link href="http://www.zphj1987.com/2015/09/18/ceph%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%B1%9E%E6%80%A7%E5%8C%B9%E9%85%8D%E5%85%B3%E7%B3%BB/"/>
    <id>http://www.zphj1987.com/2015/09/18/ceph客户端服务端属性匹配关系/</id>
    <published>2015-09-18T03:24:08.000Z</published>
    <updated>2015-09-22T16:15:49.600Z</updated>
    <content type="html"><![CDATA[<p>ceph的server是定期会发布版本，而它的客户端是放到linux 内核当中的，一些属性的支持是依赖于内核版本的，这样就存在一些问题，一些功能后端支持，而客户端旧了；还有可能是客户端用的很新的内核，而后端比较旧不支持，所以查看了下内核中的 <code>features</code> 文件，可以看到这个对应关系，总结了下就是下面的列表</p>
<p>注意表中：</p>
<ul>
<li><strong>S</strong>=SUPPORTED_DEFAULT     代表客户端支持这个属性</li>
<li><strong>R</strong>=REQUIRED_DEFAULT      代表需要服务端支持这个属性</li>
</ul>
<p><img src="http://7xi6lo.com1.z0.glb.clouddn.com/属性匹配的问题.png" alt=""></p>
<p><code>missing 2040000</code> 意思是 <code>CEPH_FEATURE_CRUSH_TUNABLES (40000)</code> 和 <code>CEPH_FEATURE_CRUSH_TUNABLES2 (2000000)</code> 不被当前客户端支持，一般要么关闭新的server端的这个属性，或者升级到支持的版本的内核.</p>
<p>内核代码查看地址：<a href="http://lxr.free-electrons.com/source/include/linux/ceph/ceph_features.h" target="_blank" rel="external">http://lxr.free-electrons.com/source/include/linux/ceph/ceph_features.h</a></p>
<p>写于：2015年09月18日夜</p>
<p><strong>Power by zphj1987</strong></p>
<p><strong>QQ:199383004</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ceph的server是定期会发布版本，而它的客户端是放到linux 内核当中的，一些属性的支持是依赖于内核版本的，这样就存在一些问题，一些功能后端支持，而客户端旧了；还有可能是客户端用的很新的内核，而后端比较旧不支持，所以查看了下内核中的 <code>features</]]>
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nginx配置代理缓存]]></title>
    <link href="http://www.zphj1987.com/2015/07/14/nginx%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98/"/>
    <id>http://www.zphj1987.com/2015/07/14/nginx配置代理缓存/</id>
    <published>2015-07-14T01:57:21.000Z</published>
    <updated>2015-09-23T07:27:31.203Z</updated>
    <content type="html"><![CDATA[<p>nginx可以实现反向代理的配置，并且可以使用缓存来加速，本文是简单的实现功能的配置，暂时没有做其他的优化的部分的配置，从网上的资料来看，很多配置都是没有讲哪些是必须配置的，我自己在配置过程中就发现没有生成缓存文件，下面来记录下配置的内容<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">upstream test&#123;&#10;            server 127.0.0.1:8080;&#10;        &#125;&#10;&#10;proxy_cache_path /var/cache/nginx/proxy_cache keys_zone=cache_zone:2000m max_size=1000m;&#10;&#10;server &#123;&#10;    listen       80;&#10;    server_name  localhost;&#10;    location / &#123;&#10;        proxy_pass http://127.0.0.1:8080;&#10;        proxy_cache cache_zone;&#10;        proxy_cache_valid  200 304 302 24h;&#10;    &#125;&#10;&#10;    error_page   500 502 503 504  /50x.html;&#10;&#10;    location = /50x.html &#123;&#10;        root   /usr/share/nginx/html;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>以上为我的配置文件，说明：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">upstream test&#123;&#10;            server 127.0.0.1:8080;&#10;        &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个字段是配置代理的部分，这个配置没有做多机的配置，只是将本机的nginx的80端口配置到了apache的8080端口，<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">proxy_cache_path /var/cache/nginx/proxy_cache keys_zone=cache_zone:2000m max_size=1000m;</span><br></pre></td></tr></table></figure></p>
<p>这个是配置缓存的放置的路径的，这个路径最好是跟proxy_temp在一个分区上，后面是写得名称，共享内存大小，缓存的最大值<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">location / &#123;&#10;    proxy_pass http://127.0.0.1:8080;&#10;    proxy_cache cache_zone;&#10;    proxy_cache_valid  200 304 302 24h;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个是缓存的关键配置，proxy_pass是将请求转发到你要代理的机器上，proxy_cache是指明使用的规则，上面的keys_zone，下面的proxy_cache_valid是配置允许缓存的请求，这个地方不配置就无法生成缓存的文件，</p>
<p>到这里基本的代理缓存就配置成功了，可以通过访问来检查是否生成了缓存文件，下载检查下是否web直接将请求返回了前端</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>nginx可以实现反向代理的配置，并且可以使用缓存来加速，本文是简单的实现功能的配置，暂时没有做其他的优化的部分的配置，从网上的资料来看，很多配置都是没有讲哪些是必须配置的，我自己在配置过程中就发现没有生成缓存文件，下面来记录下配置的内容<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">upstream test&#123;&#10;            server 127.0.0.1:8080;&#10;        &#125;&#10;&#10;proxy_cache_path /var/cache/nginx/proxy_cache keys_zone=cache_zone:2000m max_size=1000m;&#10;&#10;server &#123;&#10;    listen       80;&#10;    server_name  localhost;&#10;    location / &#123;&#10;        proxy_pass http://127.0.0.1:8080;&#10;        proxy_cache cache_zone;&#10;        proxy_cache_valid  200 304 302 24h;&#10;    &#125;&#10;&#10;    error_page   500 502 503 504  /50x.html;&#10;&#10;    location = /50x.html &#123;&#10;        root   /usr/share/nginx/html;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="nginx" scheme="http://www.zphj1987.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux服务器远程网络开机（wake on lan）]]></title>
    <link href="http://www.zphj1987.com/2015/05/27/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9C%E7%A8%8B%E7%BD%91%E7%BB%9C%E5%BC%80%E6%9C%BA%EF%BC%88wake-on-lan%EF%BC%89/"/>
    <id>http://www.zphj1987.com/2015/05/27/linux服务器远程网络开机（wake-on-lan）/</id>
    <published>2015-05-27T06:35:40.000Z</published>
    <updated>2015-09-23T07:27:27.955Z</updated>
    <content type="html"><![CDATA[<h3 id="检查服务器是否支持远程网络开机">检查服务器是否支持远程网络开机</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab5101 ~]<span class="comment"># ethtool eth0</span></span><br><span class="line">    Settings <span class="keyword">for</span> eth0:</span><br><span class="line">        Supported ports: [ TP ]</span><br><span class="line">        Supported link modes: <span class="number">10</span>baseT/Half <span class="number">10</span>baseT/Full </span><br><span class="line">                              <span class="number">100</span>baseT/Half <span class="number">100</span>baseT/Full </span><br><span class="line">                              <span class="number">1000</span>baseT/Full </span><br><span class="line">        Supported pause frame use: No</span><br><span class="line">        Supports auto-negotiation: Yes</span><br><span class="line">        Advertised link modes: </span><br><span class="line">                             <span class="number">10</span>baseT/Half <span class="number">10</span>baseT/Full </span><br><span class="line">                             <span class="number">100</span>baseT/Half <span class="number">100</span>baseT/Full </span><br><span class="line">                             <span class="number">1000</span>baseT/Full </span><br><span class="line">        Advertised pause frame use: No</span><br><span class="line">        Advertised auto-negotiation: Yes</span><br><span class="line">        Speed: <span class="number">1000</span>Mb/s</span><br><span class="line">        Duplex: Full</span><br><span class="line">        Port: Twisted Pair</span><br><span class="line">        PHYAD: <span class="number">2</span></span><br><span class="line">        Transceiver: internal</span><br><span class="line">        Auto-negotiation: onMDI-X: on</span><br><span class="line">        Supports Wake-on: pumbg</span><br><span class="line">        Wake-on: g</span><br><span class="line">        Current message level: <span class="number">0</span>x00000007 (<span class="number">7</span>) </span><br><span class="line">                               drv probe linkLink detected: yes</span><br></pre></td></tr></table></figure>
<p>注意这两项：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Supports Wake-on: pumbg&#10;Wake-on: g</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>可以通过命令设置，也可以去bios中设置<br>d表示禁用，g表示开启<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab5101 ~]<span class="comment"># ethtool -s eth0 wol g</span></span><br></pre></td></tr></table></figure></p>
<p>拿到网卡的mac地址<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab5101 ~]<span class="comment"># ifconfig </span></span><br><span class="line">eth0  Link encap:Ethernet HWaddr <span class="number">00</span>:<span class="number">30</span>:<span class="number">67</span>:<span class="number">6</span>D:<span class="number">3</span>D:<span class="number">7</span>C </span><br><span class="line">     inet addr:<span class="number">192.168</span>.<span class="number">5.101</span> Bcast:<span class="number">192.168</span>.<span class="number">255.255</span> Mask:<span class="number">255.255</span>.<span class="number">0.0</span> </span><br><span class="line">     inet6 addr: fe80::<span class="number">215</span>:<span class="number">17</span>ff:fed0:be85/<span class="number">64</span> Scope:Link</span><br><span class="line">     UP BROADCAST RUNNING MULTICAST MTU:<span class="number">1500</span> Metric:<span class="number">1</span> </span><br><span class="line">     RX packets:<span class="number">17752</span> errors:<span class="number">0</span> dropped:<span class="number">4</span> overruns:<span class="number">0</span> frame:<span class="number">0</span> </span><br><span class="line">     TX packets:<span class="number">1101</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> carrier:<span class="number">0</span> </span><br><span class="line">     collisions:<span class="number">0</span> txqueuelen:<span class="number">1000</span> </span><br><span class="line">     RX bytes:<span class="number">1288183</span> (<span class="number">1.2</span> MiB) TX bytes:<span class="number">262525</span> (<span class="number">256.3</span> KiB) </span><br><span class="line">     Interrupt:<span class="number">16</span> Memory:b1100000-b1120000 </span><br><span class="line">lo   Link encap:Local Loopback inet addr:<span class="number">127.0</span>.<span class="number">0.1</span> Mask:<span class="number">255.0</span>.<span class="number">0.0</span> </span><br><span class="line">     inet6 addr: ::<span class="number">1</span>/<span class="number">128</span> Scope:Host </span><br><span class="line">     UP LOOPBACK RUNNING MTU:<span class="number">65536</span> Metric:<span class="number">1</span> </span><br><span class="line">     RX packets:<span class="number">62566</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> frame:<span class="number">0</span> </span><br><span class="line">     TX packets:<span class="number">62566</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> carrier:<span class="number">0</span> </span><br><span class="line">     collisions:<span class="number">0</span> txqueuelen:<span class="number">0</span> </span><br><span class="line">     RX bytes:<span class="number">91540393</span> (<span class="number">87.2</span> MiB) TX bytes:<span class="number">91540393</span> (<span class="number">87.2</span> MiB)</span><br></pre></td></tr></table></figure></p>
<p>得到：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">HWaddr 00:15:17:D0:BE:85</span><br></pre></td></tr></table></figure></p>
<p>在另外一台服务器上执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab901 ~]<span class="comment"># ether-wake -i eth0 00:30:67:6d:3d:7c</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="检查服务器是否支持远程网络开机">检查服务器是否支持远程网络开机</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab5101 ~]<span class="comment"># ethtool eth0</span></span><br><span class="line">    Settings <span class="keyword">for</span> eth0:</span><br><span class="line">        Supported ports: [ TP ]</span><br><span class="line">        Supported link modes: <span class="number">10</span>baseT/Half <span class="number">10</span>baseT/Full </span><br><span class="line">                              <span class="number">100</span>baseT/Half <span class="number">100</span>baseT/Full </span><br><span class="line">                              <span class="number">1000</span>baseT/Full </span><br><span class="line">        Supported pause frame use: No</span><br><span class="line">        Supports auto-negotiation: Yes</span><br><span class="line">        Advertised link modes: </span><br><span class="line">                             <span class="number">10</span>baseT/Half <span class="number">10</span>baseT/Full </span><br><span class="line">                             <span class="number">100</span>baseT/Half <span class="number">100</span>baseT/Full </span><br><span class="line">                             <span class="number">1000</span>baseT/Full </span><br><span class="line">        Advertised pause frame use: No</span><br><span class="line">        Advertised auto-negotiation: Yes</span><br><span class="line">        Speed: <span class="number">1000</span>Mb/s</span><br><span class="line">        Duplex: Full</span><br><span class="line">        Port: Twisted Pair</span><br><span class="line">        PHYAD: <span class="number">2</span></span><br><span class="line">        Transceiver: internal</span><br><span class="line">        Auto-negotiation: onMDI-X: on</span><br><span class="line">        Supports Wake-on: pumbg</span><br><span class="line">        Wake-on: g</span><br><span class="line">        Current message level: <span class="number">0</span>x00000007 (<span class="number">7</span>) </span><br><span class="line">                               drv probe linkLink detected: yes</span><br></pre></td></tr></table></figure>
<p>注意这两项：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Supports Wake-on: pumbg&#10;Wake-on: g</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="linux" scheme="http://www.zphj1987.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[dm-crypt加密磁盘]]></title>
    <link href="http://www.zphj1987.com/2015/05/25/dm-crypt%E5%8A%A0%E5%AF%86%E7%A3%81%E7%9B%98/"/>
    <id>http://www.zphj1987.com/2015/05/25/dm-crypt加密磁盘/</id>
    <published>2015-05-25T06:07:58.000Z</published>
    <updated>2015-05-25T06:14:22.406Z</updated>
    <content type="html"><![CDATA[<h3 id="dm-cry加密方式密码与文件">dm-cry加密方式密码与文件</h3><p>与其它创建加密文件系统的方法相比，dm-crypt系统有着无可比拟的优越性：它的速度更快，易用性更强。除此之外，它的适用面也很广，能够运行在各种块设备上，即使这些设备使用了RAID和 LVM也毫无障碍。</p>
<p>如果看到类似下面的输出，说明AES模块已经加载了。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">cat /proc/crypto&#10;&#10;name         : aes&#10;driver       : aes-generic&#10;module       : kernel&#10;priority     : 100&#10;refcnt       : 3&#10;selftest     : passed&#10;type         : cipher&#10;blocksize    : 16&#10;min keysize  : 16&#10;max keysize  : 32</span><br></pre></td></tr></table></figure></p>
<p>否则可以用modprobe命令来手工加载AES模块。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modprobe aes</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>检查dmsetup软件包是否已经建立了设备映像程序，用如下命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls <span class="operator">-l</span> /dev/mapper/control</span><br></pre></td></tr></table></figure></p>
<p>检查dm-crypt内核模块是否加载<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 mnt]<span class="comment"># dmsetup targets</span></span><br><span class="line">crypt            v1.<span class="number">13.0</span></span><br><span class="line">mirror           v1.<span class="number">13.2</span></span><br><span class="line">striped          v1.<span class="number">5.1</span></span><br><span class="line">linear           v1.<span class="number">2.1</span></span><br><span class="line">error            v1.<span class="number">2.0</span></span><br></pre></td></tr></table></figure></p>
<p>这说明系统已经为加密设备做好了准备。如果没有输出，可以用如下命令来加载dm-crypt模块。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modprobe dm-crypt</span><br></pre></td></tr></table></figure></p>
<p>建立加密设备</p>
<p>这里用 fdisk命令来创建需要加密的磁盘，怎么创建磁盘这里不再冗述。假设这里创建好的磁盘分区是/dev/sdb1<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cryptsetup -y create sdb_cry /dev/sdb1</span><br></pre></td></tr></table></figure></p>
<p>sdb_cry是逻辑卷的名称。输入上面命令后，还要输入2次密码，这个密码就是磁盘加密的密码。请牢记！<br>创建好后，用下面命令检查所建立的逻辑卷：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># dmsetup ls</span></span><br><span class="line">sdb_cry	(<span class="number">252</span>:<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>device-mapper会把它的虚拟设备装载到/dev/mapper下面，所以，你的虚拟块设备应该是/dev/mapper/sdb_cry，尽管用起来和其他块设备没什么不同，实际上它却是经过透明加密的。</p>
<p>创建文件系统：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># mkfs.xfs /dev/mapper/sdb_cry -f</span></span><br></pre></td></tr></table></figure></p>
<p>装载加密磁盘：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># mount /dev/mapper/sdb_cry /mnt</span></span><br><span class="line"></span><br><span class="line">[root@node1 ~]<span class="comment"># cp /etc/networks /mnt/</span></span><br><span class="line">[root@node1 ~]<span class="comment"># cat /mnt/networks </span></span><br><span class="line">default <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line">loopback <span class="number">127.0</span>.<span class="number">0.0</span></span><br><span class="line">link-local <span class="number">169.254</span>.<span class="number">0.0</span></span><br></pre></td></tr></table></figure></p>
<p>卸载加密设备<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cryptsetup remove sdb_cry</span></span><br></pre></td></tr></table></figure></p>
<p>重新加载加密设备<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># cryptsetup create sdb_cry /dev/sdb1</span></span><br></pre></td></tr></table></figure></p>
<p>这里重新挂载会要求输入密码，密码输入不正确，设备会映射过去，但是找不到文件系统，是无法看到数据的</p>
<p>重新挂载<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/mapper/sdb_cry /mnt</span><br></pre></td></tr></table></figure></p>
<p>注意 cryptsetup -y create sdb_cry /dev/sdb1 会重新为磁盘设置新的密码，只要不对磁盘进行格式化，即使设置了新的密码，同样是看不到数据的，设置了新的密码后，只要不格式化，还是能够使用旧的密码来对磁盘进行挂载的</p>
<p>以上为采用密码加密磁盘的方式</p>
<hr>
<p>使用luks方式的加密<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cryptsetup -y -v luksFormat /dev/sdb1</span><br></pre></td></tr></table></figure></p>
<p>输入大写的YES，小写不行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cryptsetup isLuks /dev/sdb1</span><br></pre></td></tr></table></figure></p>
<p>判断设备<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cryptsetup luksOpen /dev/sdb1 sdb1_luks</span><br></pre></td></tr></table></figure></p>
<p>映射设备到/dev/mapper/下面</p>
<p>卸载<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cryptsetup remove sdb1_luks</span><br></pre></td></tr></table></figure></p>
<p>再次加载<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cryptsetup isLuks /dev/sdb1</span><br></pre></td></tr></table></figure></p>
<hr>
<p>采用文件方式的加密</p>
<p>创建加密设备，并指定的文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cryptsetup --key-file /etc/zbkc/key/UUID --key-size <span class="number">256</span> create sdb1_cry /dev/sdb1</span><br></pre></td></tr></table></figure></p>
<p>使用上面的命令后会在/dev/mapper/下生成对应设备</p>
<p>然后格式化使用设备即可</p>
<p>卸载设备<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cryptsetup remove sdb1_cry</span><br></pre></td></tr></table></figure></p>
<p>需要再次使用就<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cryptsetup --key-file /etc/zbkc/key/UUID --key-size <span class="number">256</span> create sdb1_cry /dev/sdb1</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="dm-cry加密方式密码与文件">dm-cry加密方式密码与文件</h3><p>与其它创建加密文件系统的方法相比，dm-crypt系统有着无可比拟的优越性：它的速度更快，易用性更强。除此之外，它的适用面也很广，能够运行在各种块设备上，即使这些设备使用了RAID和 LVM也毫无障碍。</p>
<p>如果看到类似下面的输出，说明AES模块已经加载了。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">cat /proc/crypto&#10;&#10;name         : aes&#10;driver       : aes-generic&#10;module       : kernel&#10;priority     : 100&#10;refcnt       : 3&#10;selftest     : passed&#10;type         : cipher&#10;blocksize    : 16&#10;min keysize  : 16&#10;max keysize  : 32</span><br></pre></td></tr></table></figure></p>
<p>否则可以用modprobe命令来手工加载AES模块。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modprobe aes</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux系统克隆系统盘]]></title>
    <link href="http://www.zphj1987.com/2015/05/12/linux%E7%B3%BB%E7%BB%9F%E5%85%8B%E9%9A%86%E7%B3%BB%E7%BB%9F%E7%9B%98/"/>
    <id>http://www.zphj1987.com/2015/05/12/linux系统克隆系统盘/</id>
    <published>2015-05-12T06:24:31.000Z</published>
    <updated>2015-09-23T07:27:21.750Z</updated>
    <content type="html"><![CDATA[<p>本文将介绍两种方式的系统盘的完整的备份，两种方式各有优缺点，需要根据实际情况来进行选择</p>
<ul>
<li>使用dd的完整镜像克隆的方式</li>
<li>使用tar去备份数据，安装grub的方式</li>
</ul>
<h4 id="dd方式">dd方式</h4><p>优点：<br>简单，一条命令 dd if=/dev/sda of=/dev/sdb 就可以进行完整的系统备份了</p>
<p>缺点：<br>时间非常长，备份一个系统盘，无论数据多少，系统盘全部会读取一遍，时间比较久<br>备份目的盘需要大于原盘<br>分区无法调整，根原分区一模一样</p>
<h4 id="tar方式">tar方式</h4><p>优点：<br>时间短，只需要备份实际磁盘上的数据即可<br>自定义，可以修改分区的大小，可以控制备份的类容，可以定期备份<br>对目的盘大小无限制，比较灵活</p>
<p>缺点：<br>人为修改东西比较多，需要手动去修改一些信息<br>当然在掌握了一定的linux基础的情况下建议是使用tar方式的，，下面将介绍tar方式的处理方式：</p>
<a id="more"></a>
<h3 id="给准备用来备份的磁盘进行分区和格式化">给准备用来备份的磁盘进行分区和格式化</h3><p>首先使用 df -h 来检查当前的挂载的系统分区：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Filesystem      Size  Used Avail Use% Mounted on&#10;/dev/sdb5       285G  4.1G  266G   2% /&#10;tmpfs           2.0G  4.0K  2.0G   1% /dev/shm&#10;/dev/sdb1       239M   81M  141M  37% /boot&#10;/dev/sdb2       6.7G   17M  6.3G   1% /var/log</span><br></pre></td></tr></table></figure></p>
<p>查看磁盘的大小：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@zhongbo ~]# fdisk -l&#9;&#10;Disk /dev/sdb: 320.1 GB, 320072933376 bytes</span><br></pre></td></tr></table></figure></p>
<p>本例子中备用磁盘为sda,大小为240G：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@zhongbo ~]# fdisk -l /dev/sda &#10;Disk /dev/sda: 240.1 GB, 240057409536 bytes</span><br></pre></td></tr></table></figure></p>
<p>查看系统盘详细的分区信息<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@zhongbo ~]# parted -l&#10;Model: ATA WDC WD3200AAJS-2 (scsi)&#10;Disk /dev/sdb: 320GB&#10;Sector size (logical/physical): 512B/512B&#10;Partition Table: msdos&#10;&#10;Number  Start   End     Size    Type      File system     Flags&#10; 1      1049kB  263MB   262MB   primary   ext4            boot&#10; 2      263MB   7603MB  7340MB  primary   ext4&#10; 3      7603MB  9751MB  2147MB  primary   linux-swap(v1)&#10; 4      9751MB  320GB   310GB   extended&#10; 5      9752MB  320GB   310GB   logical   ext4</span><br></pre></td></tr></table></figure></p>
<p>可以看到分区表模式为msdos，分区信息为含有扩展分区，逻辑分区了，下面为新准备的盘进行分区，分区信息跟原来尽量一样，这个地方也可以根据自己的需要进行调整<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@zhongbo ~]# parted /dev/sda&#10;(parted) mklabel msdos &#10;(parted) mkpart primary 1049kB 263&#10;(parted) mkpart primary 263 7603&#10;(parted) mkpart primary 7603 9751 &#10;(parted) mkpart extended 9751 100%&#10;(parted) mkpart logical 9752 100%&#10;(parted) p                                                                &#10;Model: ATA INTEL SSDSC2BF24 (scsi)&#10;Disk /dev/sda: 240GB&#10;Sector size (logical/physical): 512B/512B&#10;Partition Table: msdos&#10;&#10;Number  Start   End     Size    Type      File system     Flags&#10; 1      1049kB  263MB   262MB   primary   ext4&#10; 2      263MB   7603MB  7340MB  primary   ext4&#10; 3      7603MB  9751MB  2147MB  primary   linux-swap(v1)&#10; 4      9751MB  240GB   230GB   extended                  lba&#10; 5      9752MB  240GB   230GB   logical   ext4</span><br></pre></td></tr></table></figure></p>
<p>格式化硬盘</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@zhongbo ~]<span class="comment"># mkfs.ext4 /dev/sda1  </span></span><br><span class="line">[root@zhongbo ~]<span class="comment"># mkfs.ext4 /dev/sda2</span></span><br><span class="line">[root@zhongbo ~]<span class="comment"># mkswap /dev/sda3 </span></span><br><span class="line">[root@zhongbo ~]<span class="comment"># mkfs.ext4 /dev/sda5</span></span><br></pre></td></tr></table></figure>
<h3 id="备份原始磁盘上的数据到备份目的盘">备份原始磁盘上的数据到备份目的盘</h3><p>在本地系统盘上创建一个备份的目录，将数据打包放到这个目录下面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@zhongbo ~]<span class="comment"># mkdir /backup</span></span><br></pre></td></tr></table></figure>
<p>按这个系统来说需要备份三个分区/ , /var/log/, /boot </p>
<p>开始备份/<br>所有的操作都进入到/目录下操作<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@zhongbo ~]<span class="comment"># cd /</span></span><br><span class="line">[root@zhongbo /]<span class="comment"># tar zcvpf /backup/gen.tar.gz -C /  --exclude=boot/* --exclude=var/log/* --exclude=backup/*  --exclude=lost+found/* --exclude=mnt/*  --exclude=dev/* --exclude=proc/* --exclude=tmp/* --exclude=sys/* .</span></span><br></pre></td></tr></table></figure></p>
<p>注意这里排除了很多不需要备份的目录</p>
<p>备份boot分区<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@zhongbo /]<span class="comment"># tar zcvpf /backup/boot.tar.gz -C /boot/ .</span></span><br></pre></td></tr></table></figure></p>
<p>备份/var/log<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@zhongbo /]<span class="comment"># tar zcvpf /backup/log.tar.gz -C /var/log/ .</span></span><br></pre></td></tr></table></figure></p>
<p>恢复/的数据<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@zhongbo /]<span class="comment"># mkdir /mnt/gen</span></span><br><span class="line">[root@zhongbo /]<span class="comment"># mount /dev/sda5 /mnt/gen/</span></span><br><span class="line">[root@zhongbo /]<span class="comment"># tar zxvpf /backup/gen.tar.gz -C /mnt/gen/</span></span><br></pre></td></tr></table></figure></p>
<p>恢复/boot的数据<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@zhongbo /]<span class="comment"># mkdir /mnt/boot</span></span><br><span class="line">[root@zhongbo /]<span class="comment"># mount /dev/sda1 /mnt/boot/</span></span><br><span class="line">[root@zhongbo /]<span class="comment"># tar zxvpf /backup/boot.tar.gz -C /mnt/boot/</span></span><br></pre></td></tr></table></figure></p>
<p>恢复/var/log<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@zhongbo /]<span class="comment"># mkdir /mnt/log</span></span><br><span class="line">[root@zhongbo /]<span class="comment"># mount /dev/sda2 /mnt/log/</span></span><br><span class="line">[root@zhongbo /]<span class="comment"># tar zxvpf /backup/log.tar.gz -C /mnt/log/</span></span><br></pre></td></tr></table></figure></p>
<h3 id="修改启动文件">修改启动文件</h3><p>拿到新的分区的blkid<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@zhongbo /]# blkid /dev/sda1&#10;/dev/sda1: UUID=&#34;a6ca4369-109c-47ed-a522-7e1752a6681b&#34; TYPE=&#34;ext4&#34; &#10;&#23545;&#24212;boot&#10;[root@zhongbo /]# blkid /dev/sda2&#10;/dev/sda2: UUID=&#34;f775f248-57d8-49a7-9334-60bc75a53685&#34; TYPE=&#34;ext4&#34; &#10;&#23545;&#24212;log&#10;&#10;[root@zhongbo /]# blkid /dev/sda5&#10;/dev/sda5: UUID=&#34;6942c7d6-486c-4d51-bb4d-a126ee0c05b1&#34; TYPE=&#34;ext4&#34;&#10;&#23545;&#24212;/&#10;&#10;[root@zhongbo /]# blkid /dev/sda3&#10;/dev/sda3: UUID=&#34;154784d8-dbe3-45c8-8fcb-cb4f5a14ae44&#34; TYPE=&#34;swap&#34; &#10;&#23545;&#24212;swap</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@zhongbo /]<span class="comment"># vim /mnt/gen/etc/fstab </span></span><br><span class="line">修改对应分区的uuid信息</span><br><span class="line"></span><br><span class="line">修改menu.list </span><br><span class="line">[root@zhongbo ~]<span class="comment"># vim /mnt/boot/grub/menu.lst</span></span><br><span class="line">修改root= 根分区的uuid，第一次做的时候，就是在这个地方忘了修改，进入系统后能够看到启动画面，但是没法启动内核，修改好了后，就可以正常的启动了</span><br></pre></td></tr></table></figure>
<h3 id="安装grub">安装grub</h3><p>查找grub分区<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">grub&#62; find /grub/grub.conf&#10;find /grub/grub.conf&#10; (hd0,0)&#10; (hd1,0)&#10;grub&#62;</span><br></pre></td></tr></table></figure></p>
<p>修改其中的新盘上的grub然后分辨新的grub在哪台机器上，我的新盘是(hd0,0)<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub&gt; root (hd0,<span class="number">0</span>) </span><br><span class="line">grub&gt; setup (hd0)    </span><br><span class="line">setup (hd0)</span><br><span class="line"> Checking <span class="keyword">if</span> <span class="string">"/boot/grub/stage1"</span> exists... no</span><br><span class="line"> Checking <span class="keyword">if</span> <span class="string">"/grub/stage1"</span> exists... yes</span><br><span class="line"> Checking <span class="keyword">if</span> <span class="string">"/grub/stage2"</span> exists... yes</span><br><span class="line"> Checking <span class="keyword">if</span> <span class="string">"/grub/e2fs_stage1_5"</span> exists... yes</span><br><span class="line"> Running <span class="string">"embed /grub/e2fs_stage1_5 (hd0)"</span>...  <span class="number">27</span> sectors are embedded.</span><br><span class="line">succeeded</span><br><span class="line"> Running <span class="string">"install /grub/stage1 (hd0) (hd0)1+27 p (hd0,0)/grub/stage2 /grub/grub.conf"</span>... succeeded</span><br><span class="line">Done.</span><br><span class="line">grub&gt; quit</span><br></pre></td></tr></table></figure></p>
<p>完成后，系统盘就完全备份了一份了，重启就可以启动一个一模一样的系统了</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文将介绍两种方式的系统盘的完整的备份，两种方式各有优缺点，需要根据实际情况来进行选择</p>
<ul>
<li>使用dd的完整镜像克隆的方式</li>
<li>使用tar去备份数据，安装grub的方式</li>
</ul>
<h4 id="dd方式">dd方式</h4><p>优点：<br>简单，一条命令 dd if=/dev/sda of=/dev/sdb 就可以进行完整的系统备份了</p>
<p>缺点：<br>时间非常长，备份一个系统盘，无论数据多少，系统盘全部会读取一遍，时间比较久<br>备份目的盘需要大于原盘<br>分区无法调整，根原分区一模一样</p>
<h4 id="tar方式">tar方式</h4><p>优点：<br>时间短，只需要备份实际磁盘上的数据即可<br>自定义，可以修改分区的大小，可以控制备份的类容，可以定期备份<br>对目的盘大小无限制，比较灵活</p>
<p>缺点：<br>人为修改东西比较多，需要手动去修改一些信息<br>当然在掌握了一定的linux基础的情况下建议是使用tar方式的，，下面将介绍tar方式的处理方式：</p>]]>
    
    </summary>
    
      <category term="操作系统" scheme="http://www.zphj1987.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux下制作软件包安装服务器]]></title>
    <link href="http://www.zphj1987.com/2015/04/28/linux%E4%B8%8B%E5%88%B6%E4%BD%9C%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%AE%89%E8%A3%85%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://www.zphj1987.com/2015/04/28/linux下制作软件包安装服务器/</id>
    <published>2015-04-28T08:43:29.000Z</published>
    <updated>2015-09-23T07:27:18.653Z</updated>
    <content type="html"><![CDATA[<p>linux下的软件包在有网络的情况下比较好安装，在ubuntu下，更新sourcelist，然后使用apt-get就可以很方便的安装包，在centos下面，更新yum列表，然后使用yum也可以进行方便的软件安装，但是在没有网络的情况下就比较难安装，可以用一个个包的安装的方式去安装，这个在少量的包的情况下比较好处理，在多的情况下就比较麻烦了，本篇文档，就是介绍了在无网的情况下，根据自己的需要制作内网的包的安装服务器</p>
<h2 id="centos系列">centos系列</h2><h3 id="使用光驱作为安装源">使用光驱作为安装源</h3><p>1、将光驱挂载到服务器的本地目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># mount /dev/cdrom /mnt</span></span><br><span class="line">mount: block device /dev/sr0 is write-protected, mounting <span class="built_in">read</span>-only</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>2、修改本地的yum源文件，将源指向光驱挂载的目录<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/yum.repos.d/myiso.repo</span><br></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10;&#28155;&#21152;&#10;[myiso]&#10;name=myiso&#10;baseurl=file:///mnt&#10;gpgcheck=0&#10;enabled=1&#10;gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</span><br></pre></td></tr></table></figure>
<p>3、更新本地的源缓存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 yum.repos.d]<span class="comment"># yum makecache</span></span><br><span class="line">Loaded plugins: security</span><br><span class="line">myiso                                 | <span class="number">3.6</span> kB     <span class="number">00</span>:<span class="number">00</span> ... </span><br><span class="line">myiso/group_gz                        |  <span class="number">17</span> kB     <span class="number">00</span>:<span class="number">00</span> ... </span><br><span class="line">myiso/filelists_db                    | <span class="number">3.4</span> MB     <span class="number">00</span>:<span class="number">00</span> ... </span><br><span class="line">myiso/primary_db                      | <span class="number">6.8</span> MB     <span class="number">00</span>:<span class="number">00</span> ... </span><br><span class="line">myiso/other_db                        | <span class="number">2.3</span> MB     <span class="number">00</span>:<span class="number">00</span> ... </span><br><span class="line">Metadata Cache Created</span><br></pre></td></tr></table></figure>
<p>做完上面的就可以使用本地的光驱的中的包使用yum安装了</p>
<h3 id="使用iso文件作为安装源">使用iso文件作为安装源</h3><p>1、将iso文件拷贝到服务器，然后挂载到服务器本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># mount -t iso9660 OracleLinux-R6-U5-Server-x86_64-dvd.\[V41362-01\].iso /mnt -o loop</span></span><br><span class="line">mount: /root/OracleLinux-R6-U5-Server-x86_64-dvd.[V41362-<span class="number">01</span>].iso is write-protected, mounting <span class="built_in">read</span>-only</span><br></pre></td></tr></table></figure>
<p>2、修改本地的yum源文件，将源指向光驱挂载的目录</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">vim /etc/yum.repos.d/myiso.repo&#10;&#28155;&#21152;&#10;[myiso]&#10;name=myiso&#10;baseurl=file:///mnt&#10;gpgcheck=0&#10;enabled=1&#10;gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</span><br></pre></td></tr></table></figure>
<p>3、更新本地的源缓存<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@node1 yum.repos.d]# yum makecache&#10;Loaded plugins: security&#10;myiso                                 | 3.6 kB     00:00 ... &#10;myiso/group_gz                        |  17 kB     00:00 ... &#10;myiso/filelists_db                    | 3.4 MB     00:00 ... &#10;myiso/primary_db                      | 6.8 MB     00:00 ... &#10;myiso/other_db                        | 2.3 MB     00:00 ... &#10;Metadata Cache Created</span><br></pre></td></tr></table></figure></p>
<p>做完上面的就可以使用本地的iso中的包使用yum安装了</p>
<h3 id="使用安装包做一个ftp的yum安装服务器">使用安装包做一个ftp的yum安装服务器</h3><p>1、安装vsftpd服务器<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh vsftpd-<span class="number">2.2</span>.<span class="number">2</span>-<span class="number">11</span>.el6_4.<span class="number">1</span>.x86_64.rpm</span><br></pre></td></tr></table></figure></p>
<p>这个包在操作iso中的包路径下面有</p>
<p>2、配置ftp服务器<br>默认的ftp目录为/var/ftp/pub/<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#21019;&#24314;&#28304;&#30446;&#24405;&#10;mkdir /var/ftp/pub/centos&#10;&#23558;iso&#25346;&#36733;&#21040;&#28304;&#30446;&#24405;&#65292;&#20063;&#21487;&#20197;&#30452;&#25509;&#23558;&#25991;&#20214;&#25335;&#36125;&#21040;&#36825;&#20010;&#30446;&#24405;&#24403;&#20013;&#21435;&#10;mount -t iso9660 OracleLinux-R6-U5-Server-x86_64-dvd.\[V41362-01\].iso /var/ftp/pub/centos/  -o loop</span><br></pre></td></tr></table></figure></p>
<p>配置完成后，镜像的下载地址就为:<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">ftp://youripaddress/pub/centos/</span><br></pre></td></tr></table></figure></p>
<p>我的为:<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">ftp://172.16.81.129/pub/centos/</span><br></pre></td></tr></table></figure></p>
<p>3、使用的机器的配置<br>修改yum源<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">vim /etc/yum.repos.d/ftpcentos.repo&#10;&#28155;&#21152;&#10;[ftpcentos]&#10;name=ftpcentos&#10;baseurl=ftp://172.16.81.129/pub/centos/&#10;enabled=1</span><br></pre></td></tr></table></figure></p>
<p>4、更新yum的缓存<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@node2 yum.repos.d]# yum makecache&#10;Loaded plugins: security&#10;ftpcentos                          | 3.7 kB     00:00     &#10;ftpcentos/filelists_db             | 3.3 MB     00:00     &#10;ftpcentos/primary_db               | 3.0 MB     00:00     &#10;ftpcentos/other_db                 | 1.3 MB     00:00     &#10;ftpcentos/group_gz                 | 203 kB     00:00     &#10;Metadata Cache Created</span><br></pre></td></tr></table></figure></p>
<h3 id="制作自己的定制源">制作自己的定制源</h3><p>1、安装制作源的工具<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">rpm -ivh deltarpm-3.5-0.5.20090913git.el6.x86_64.rpm&#10;rpm -ivh python-deltarpm-3.5-0.5.20090913git.el6.x86_64.rpm &#10;rpm -ivh createrepo-0.9.9-18.0.1.el6.noarch.rpm</span><br></pre></td></tr></table></figure></p>
<p>这三个包在默认的iso当中有</p>
<p>2、将安装包拷贝到指定的目录</p>
<p>本例子使用leveldb，snappy举例，snappy是leveldb的依赖包。<br>将<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">leveldb-1.7.0-2.el6.x86_64.rpm&#10;snappy-1.0.5-1.el6.x86_64.rpm</span><br></pre></td></tr></table></figure></p>
<p>拷贝到<br>/usr/src/myepel/目录当中去</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@node1 src]# createrepo myepel/&#10;Spawning worker 0 with 2 pkgs&#10;Workers Finished&#10;Gathering worker results&#10;&#10;Saving Primary metadata&#10;Saving file lists metadata&#10;Saving other metadata&#10;Generating sqlite DBs&#10;Sqlite DBs complete</span><br></pre></td></tr></table></figure>
<p>检查目录下面会生成repodata，存储一些元数据信息<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@node1 src]# ll myepel/&#10;total 200&#10;-rw-r--r-- 1 root root 162052 Apr 16 08:45 leveldb-1.7.0-2.el6.x86_64.rpm&#10;drwxr-xr-x 2 root root   4096 Apr 16 08:48 repodata&#10;-rw-r--r-- 1 root root  34372 Apr 16 08:45 snappy-1.0.5-1.el6.x86_64.rpm</span><br></pre></td></tr></table></figure></p>
<p>3、修改源列表</p>
<p>同样的将yum源的目录指向这个myepel/<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[myiso]&#10;name=myiso&#10;baseurl=file:///usr/src/myepel/&#10;gpgcheck=0&#10;enabled=1</span><br></pre></td></tr></table></figure></p>
<p>4、更新yum缓存<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@node1 yum.repos.d]# yum makecache&#10;[root@node1 yum.repos.d]# yum install leveldb</span><br></pre></td></tr></table></figure></p>
<p>即可安装了</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>linux下的软件包在有网络的情况下比较好安装，在ubuntu下，更新sourcelist，然后使用apt-get就可以很方便的安装包，在centos下面，更新yum列表，然后使用yum也可以进行方便的软件安装，但是在没有网络的情况下就比较难安装，可以用一个个包的安装的方式去安装，这个在少量的包的情况下比较好处理，在多的情况下就比较麻烦了，本篇文档，就是介绍了在无网的情况下，根据自己的需要制作内网的包的安装服务器</p>
<h2 id="centos系列">centos系列</h2><h3 id="使用光驱作为安装源">使用光驱作为安装源</h3><p>1、将光驱挂载到服务器的本地目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># mount /dev/cdrom /mnt</span></span><br><span class="line">mount: block device /dev/sr0 is write-protected, mounting <span class="built_in">read</span>-only</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="linux" scheme="http://www.zphj1987.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[windows下命令行设置静态IP]]></title>
    <link href="http://www.zphj1987.com/2015/04/03/windows%E4%B8%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP/"/>
    <id>http://www.zphj1987.com/2015/04/03/windows下命令行设置静态IP/</id>
    <published>2015-04-03T04:25:48.000Z</published>
    <updated>2015-09-23T07:27:15.004Z</updated>
    <content type="html"><![CDATA[<p>windows 10 预览版出现无法设置静态IP的bug，只能通过命令行进行设置，开启powershell，然后执行下列的命令即可<br>下面的“以太网 3” 为你设置的网卡的网卡名称,注意不要忘了空格</p>
<p>设置静态IP:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netsh interface ipv4 <span class="built_in">set</span> address <span class="string">"以太网 3"</span>  static <span class="number">192.168</span>.<span class="number">0.71</span> <span class="number">255.255</span>.<span class="number">0.0</span> <span class="number">192.168</span>.<span class="number">26.1</span></span><br></pre></td></tr></table></figure></p>
<p>增加静态IP:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netsh interface ipv4 <span class="built_in">set</span> dns <span class="string">"以太网 3"</span>  static <span class="number">223.5</span>.<span class="number">5.5</span></span><br></pre></td></tr></table></figure></p>
<p>增加静态IP:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netsh interface ipv4 add address <span class="string">"以太网 3"</span> <span class="number">11.12</span>.<span class="number">0.0</span> <span class="number">255.255</span>.<span class="number">0.0</span></span><br></pre></td></tr></table></figure></p>
<p>重置为dhcp:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netsh interface ipv4 <span class="built_in">set</span> address <span class="string">"以太网 3"</span>  dhcp</span><br></pre></td></tr></table></figure></p>
<p>基本设置应该够用了</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>windows 10 预览版出现无法设置静态IP的bug，只能通过命令行进行设置，开启powershell，然后执行下列的命令即可<br>下面的“以太网 3” 为你设置的网卡的网卡名称,注意不要忘了空格</p>
<p>设置静态IP:<br><figure class="hi]]>
    </summary>
    
      <category term="windows" scheme="http://www.zphj1987.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[shell脚本的自动交互]]></title>
    <link href="http://www.zphj1987.com/2015/04/02/shell%E8%84%9A%E6%9C%AC%E7%9A%84%E8%87%AA%E5%8A%A8%E4%BA%A4%E4%BA%92/"/>
    <id>http://www.zphj1987.com/2015/04/02/shell脚本的自动交互/</id>
    <published>2015-04-02T09:22:40.000Z</published>
    <updated>2015-09-23T07:27:11.524Z</updated>
    <content type="html"><![CDATA[<p>使用expect来自动应答shell的交互</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/expect&#10;spawn openssl req -new -key server.key -out server1.csr&#10;expect &#34;Country Name&#34;&#10;send &#34;\n&#34;&#10;expect &#34;State or Province Name&#34;&#10;send &#34;\n&#34;&#10;interact</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>使用expect来自动应答shell的交互</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/expect&#10;spawn opens]]>
    </summary>
    
      <category term="脚本" scheme="http://www.zphj1987.com/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[history命令的优化]]></title>
    <link href="http://www.zphj1987.com/2015/03/31/history%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://www.zphj1987.com/2015/03/31/history命令的优化/</id>
    <published>2015-03-31T08:53:28.000Z</published>
    <updated>2015-03-31T08:54:52.846Z</updated>
    <content type="html"><![CDATA[<p>现在在项目中遇到这个情况比较多，在执行了一系列的命令后，想去翻历史记录的时候，翻不到历史记录，不同终端的命令，没有汇总，也不清楚那条命令是什么时候执行的，所以需要对默认的命令进行下面两个优化：</p>
<ul>
<li>让历史记录里面带有时间</li>
<li>让所有终端命令都记录到history当中去</li>
</ul>
<h3 id="添加日期">添加日期</h3><p>在 /etc/bashrc 末尾添加：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">HISTTIMEFORMAT=&#34;%F %T &#34;&#10;export HISTTIMEFORMAT</span><br></pre></td></tr></table></figure></p>
<p>然后执行:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/bashrc</span><br></pre></td></tr></table></figure></p>
<p>新开终端，history就已经带有日期</p>
<h3 id="汇总命令，并且不同的终端可以通过上翻查询到命令">汇总命令，并且不同的终端可以通过上翻查询到命令</h3><p>在 /etc/bashrc 末尾添加：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Avoid duplicates&#10;export HISTCONTROL=ignoredups:erasedups&#10;# When the shell exits, append to the history file instead of overwriting it&#10;shopt -s histappend&#10;&#10;# After each command, append to the history file and reread it&#10;export PROMPT_COMMAND=&#34;$&#123;PROMPT_COMMAND:+$PROMPT_COMMAND$&#39;\n&#39;&#125;history -a; history -c; history -r&#34;</span><br></pre></td></tr></table></figure></p>
<p>然后执行:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/bashrc</span><br></pre></td></tr></table></figure></p>
<h3 id="调整大小，增加到10000条">调整大小，增加到10000条</h3><p>在 /etc/bashrc 末尾添加：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">export HISTSIZE=10000</span><br></pre></td></tr></table></figure></p>
<p>然后执行:<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">source /etc/bashrc</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>现在在项目中遇到这个情况比较多，在执行了一系列的命令后，想去翻历史记录的时候，翻不到历史记录，不同终端的命令，没有汇总，也不清楚那条命令是什么时候执行的，所以需要对默认的命令进行下面两个优化：</p>
<ul>
<li>让历史记录里面带有时间</li>
<li>让所有终端命]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[压缩css与js]]></title>
    <link href="http://www.zphj1987.com/2015/03/25/%E5%8E%8B%E7%BC%A9css%E4%B8%8Ejs/"/>
    <id>http://www.zphj1987.com/2015/03/25/压缩css与js/</id>
    <published>2015-03-25T04:52:01.000Z</published>
    <updated>2015-09-23T07:26:33.819Z</updated>
    <content type="html"><![CDATA[<p>使用yuicompressor 进行css和js的压缩</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="shebang">#! /bin/sh	</span></span><br><span class="line">yasuocss=<span class="string">"java -jar /root/yuicompressor-2.4.8.jar --type css  --charset utf-8"</span></span><br><span class="line">yasuojs=<span class="string">"java -jar /root/yuicompressor-2.4.8.jar --type js  --charset utf-8"</span></span><br><span class="line"><span class="comment">######################css</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span>  ./SGMag/sites/media/css/sgmag/*.css ./SGMag/sites/media/css/*.css</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span>"</span>bk</span><br><span class="line">mv <span class="variable">$file</span>  <span class="string">"<span class="variable">$file</span>"</span>bk</span><br><span class="line"><span class="variable">$yasuocss</span>  <span class="variable">$file</span><span class="string">"bk"</span> &gt;  <span class="variable">$file</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#######################js</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span>  ./SGMag/sites/media/component/*.js ./SGMag/sites/media/*.js  ./SGMag/sites/media/pagejs/*.js  </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span>"</span>bk</span><br><span class="line">mv <span class="variable">$file</span>  <span class="string">"<span class="variable">$file</span>"</span>bk</span><br><span class="line"><span class="variable">$yasuojs</span>  <span class="variable">$file</span><span class="string">"bk"</span> &gt;  <span class="variable">$file</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$file</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">########################报错处理</span></span><br><span class="line">cp -rf  ./SGMag/sites/media/pagejs/cluster/hosttools.jsbk  ./SGMag/sites/media/pagejs/cluster/hosttools.js</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>使用yuicompressor 进行css和js的压缩</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class]]>
    </summary>
    
      <category term="杂七杂八" scheme="http://www.zphj1987.com/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ubuntu配置简单的DNS服务器]]></title>
    <link href="http://www.zphj1987.com/2015/03/24/ubuntu%E9%85%8D%E7%BD%AE%E7%AE%80%E5%8D%95%E7%9A%84DNS%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://www.zphj1987.com/2015/03/24/ubuntu配置简单的DNS服务器/</id>
    <published>2015-03-24T05:39:44.000Z</published>
    <updated>2015-09-23T07:25:55.222Z</updated>
    <content type="html"><![CDATA[<p>之所以说是简单的服务器，实现的功能很简单，通过这个dns server 查询制定域名的时候，能够根据设置的值来返回IP，当前的需求是需要轮询的返回IP</p>
<p>DNS 轮询机制会受到多方面的影响，如：A记录的TTL时间长短的影响；别的 DNS 服务器 Cache 的影响；windows 客户端也有一个DNS Cache。这些都会影响 DNS 轮询的效果。</p>
<p>下面的配置就是实现解析test.zp.com到不同的IP地址</p>
<h3 id="安装dns_server软件包">安装dns server软件包</h3><p>ubuntu下是通过安装bind9软件包来配置dns-server的<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab5106 ~]<span class="comment"># apt-get install bind9</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="配置dns">配置dns</h3><p>配置文件的路径在/etc/bind路径下面</p>
<h4 id="添加一个zone">添加一个zone</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	root@ubuntu14:/etc/<span class="built_in">bind</span><span class="comment"># vim /etc/bind/named.conf.local </span></span><br><span class="line">	添加下面，语法可以参照/etc/<span class="built_in">bind</span>/zones.rfc1918中的语法添加，如下：</span><br><span class="line"> </span><br><span class="line">	zone <span class="string">"zp.com"</span>  &#123; <span class="built_in">type</span> master; file <span class="string">"/etc/bind/db.zp.com"</span>; &#125;;</span><br><span class="line">```	</span><br><span class="line">修改db的配置文件</span><br><span class="line">```bash</span><br><span class="line">	root@ubuntu14:/etc/<span class="built_in">bind</span><span class="comment"># cp db.local db.zp.com</span></span><br><span class="line">	root@ubuntu14:/etc/<span class="built_in">bind</span><span class="comment"># vim db.zp.com</span></span><br><span class="line">	;</span><br><span class="line">	; BIND data file <span class="keyword">for</span> <span class="built_in">local</span> loopback interface</span><br><span class="line">	;</span><br><span class="line">	<span class="variable">$TTL</span>    <span class="number">604800</span></span><br><span class="line">	@       IN      SOA     zp.com. root.localhost. (</span><br><span class="line">	                              <span class="number">2</span>         ; Serial</span><br><span class="line">	                         <span class="number">604800</span>         ; Refresh</span><br><span class="line">	                          <span class="number">86400</span>         ; Retry</span><br><span class="line">	                        <span class="number">2419200</span>         ; Expire</span><br><span class="line">	                         <span class="number">604800</span> )       ; Negative Cache TTL</span><br><span class="line">	;</span><br><span class="line">	@       IN      NS      localhost.</span><br><span class="line">	@       IN      A       <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line">	@       IN      AAAA    ::<span class="number">1</span></span><br><span class="line">	<span class="built_in">test</span>       IN      A       <span class="number">192.168</span>.<span class="number">0.11</span></span><br><span class="line">	<span class="built_in">test</span>       IN      A       <span class="number">192.168</span>.<span class="number">0.12</span></span><br><span class="line">	<span class="built_in">test</span>       IN      A       <span class="number">192.168</span>.<span class="number">0.13</span></span><br><span class="line">	<span class="built_in">test</span>       IN      A       <span class="number">192.168</span>.<span class="number">0.14</span></span><br><span class="line">	<span class="built_in">test</span>       IN      A       <span class="number">192.168</span>.<span class="number">0.15</span></span><br><span class="line">	<span class="built_in">test</span>       IN      A       <span class="number">192.168</span>.<span class="number">0.16</span></span><br></pre></td></tr></table></figure>
<p>修改<code>/etc/bind/named.conf.option</code> 配置文件，在 <code>named.conf.option</code> 中可以设置 bind 的 round-robin 的给出结果的顺序：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">rrset-order &#123; order cyclic; &#125;;&#10;&#10;rrset-order &#25903;&#25345;&#19977;&#20010;&#21442;&#25968;&#65306;fixed, random, cyclic &#12290;&#10;fixed &#20250;&#23558;&#22810;&#20010;A&#35760;&#24405;&#25353;&#37197;&#32622;&#25991;&#20214;&#30340;&#39034;&#24207;&#22266;&#23450;&#32473;&#20986;&#10;random &#20250;&#38543;&#26426;&#32473;&#20986;&#10;cyclic &#20250;&#24490;&#29615;&#32473;&#20986;</span><br></pre></td></tr></table></figure>
<h3 id="重启服务">重启服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu14:/etc/<span class="built_in">bind</span><span class="comment"># /etc/init.d/bind9 restart</span></span><br></pre></td></tr></table></figure>
<h3 id="检查配置效果">检查配置效果</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#20462;&#25913;&#22495;&#21517;&#35299;&#26512;&#37197;&#32622;&#25991;&#20214;&#10;root@ubuntu14:/etc/bind# vim /etc/resolv.conf &#10;nameserver 192.168.0.122&#10;&#28155;&#21152;&#20320;&#30340;&#22495;&#21517;&#26381;&#21153;&#22120;&#30340;IP&#22320;&#22336;&#10;&#10;&#36890;&#36807;&#22810;&#27425;ping&#22495;&#21517;&#26816;&#26597;&#36820;&#22238;&#30340;&#32467;&#26524;&#10;root@ubuntu14:/etc/bind# ping test.zp.com&#10;PING test.zp.com (192.168.0.13) 56(84) bytes of data.&#10;root@ubuntu14:/etc/bind# ping test.zp.com&#10;PING test.zp.com (192.168.0.14) 56(84) bytes of data.</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="后话">后话</h3><p>window的dns缓存的处理办法：<br>清空dns缓存<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure></p>
<p>显示缓存的dns信息<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipconfig/displaydns</span><br></pre></td></tr></table></figure></p>
<p>临时禁用dns缓存<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">net stop dnscache</span><br></pre></td></tr></table></figure></p>
<p>启动dns缓存<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">net start dnscache</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之所以说是简单的服务器，实现的功能很简单，通过这个dns server 查询制定域名的时候，能够根据设置的值来返回IP，当前的需求是需要轮询的返回IP</p>
<p>DNS 轮询机制会受到多方面的影响，如：A记录的TTL时间长短的影响；别的 DNS 服务器 Cache 的影响；windows 客户端也有一个DNS Cache。这些都会影响 DNS 轮询的效果。</p>
<p>下面的配置就是实现解析test.zp.com到不同的IP地址</p>
<h3 id="安装dns_server软件包">安装dns server软件包</h3><p>ubuntu下是通过安装bind9软件包来配置dns-server的<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab5106 ~]<span class="comment"># apt-get install bind9</span></span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="ubuntu" scheme="http://www.zphj1987.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mdtest测试工具]]></title>
    <link href="http://www.zphj1987.com/2015/03/24/mdtest%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.zphj1987.com/2015/03/24/mdtest测试工具/</id>
    <published>2015-03-24T05:33:52.000Z</published>
    <updated>2015-09-23T07:25:41.021Z</updated>
    <content type="html"><![CDATA[<p>软件介绍</p>
<p> mdstest是软件的元数据操作基准测试工具，用来模拟对文件或者目录的open、stat、close操作，然后报告性能</p>
<p>下载软件压缩包：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install openmpi openmpi-devel -y</span><br><span class="line">在/root/.bashrc中添加（注意也要添加mdtest的路径）</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/lib64/openmpi/bin/</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /root/.bashrc</span><br><span class="line">下载</span><br><span class="line">[root@lab8105 ~]<span class="comment"># wget http://sourceforge.net/projects/mdtest/files/latest/download</span></span><br><span class="line">解压</span><br><span class="line">[root@lab8105 ~]<span class="comment"># tar -xvf mdtest-1.9.3.tgz</span></span><br><span class="line">修改makefile：</span><br><span class="line">mdtest: mdtest.c</span><br><span class="line">       mpicc -Wall -D $(OS) $(LARGE_FILE) $(MDTEST_FLAGS) -g -o mdtest mdtest.c -lm</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>参数如下：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Usage:  mdtest [-b #] [-B] [-c] [-C] [-d testdir] [-D] [-e] [-E] [-f first] [-F]&#10;               [-h] [-i iterations] [-I #] [-l last] [-L] [-n #] [-N #] [-p seconds]&#10;               [-r] [-R[#]] [-s #] [-S] [-t] [-T] [-u] [-v] [-V #] [-w #] [-y]&#10;               [-z #]&#10;&#10;    -b: branching factor of hierarchical directory structure&#10;&#9;&#9;&#30446;&#24405;&#26641;&#30340;&#20998;&#25903;&#21442;&#25968;&#10;    -B: no barriers between phases (create/stat/remove)&#10;&#9;&#9; &#19981;&#21516;&#30340;&#38454;&#27573;&#27809;&#26377;&#38548;&#31163; (create/stat/remove)&#65307;&#10;    -c: collective creates: task 0 does all creates and deletes&#10;&#9;&#9;&#20849;&#21516;&#21019;&#24314;: task 0 &#23436;&#25104;&#25152;&#26377;&#30340;&#21019;&#24314;&#21644;&#21024;&#38500;&#24037;&#20316;&#65307;&#10;    -C: only create files/dirs&#10;&#9;&#9;&#21482;&#21019;&#24314;&#25991;&#20214;&#25110;&#30446;&#24405;&#65292;&#19981;&#20316;&#21024;&#38500;&#65307;&#10;    -d: the directory in which the tests will run&#10;&#9;&#9;&#25351;&#20986;&#27979;&#35797;&#36816;&#34892;&#30340;&#30446;&#24405;&#65288;&#33509;&#19981;&#25351;&#23450;&#65292;&#21017;&#40664;&#35748;&#24403;&#21069;&#30446;&#24405;&#65289;&#65307;&#10;    -D: perform test on directories only (no files)&#10;&#9;&#9;&#21482;&#23545;&#30446;&#24405;&#25805;&#20316;&#36827;&#34892;&#27979;&#35797;&#65288;&#19981;&#21253;&#25324;&#25991;&#20214;&#65289;&#65307;&#10;    -e: number of bytes to read from each file&#10;&#9;&#9;&#20174;&#27599;&#20010;&#25991;&#20214;&#35835;&#20986;&#30340;&#25991;&#20214;&#22823;&#23567;&#10;    -E: only read files&#10;&#9;&#9;&#21482;&#35835;&#21462;&#25991;&#20214;&#10;    -f: first number of tasks on which the test will run&#10;&#9;&#9;&#39318;&#20808;&#36816;&#34892;&#30340;&#20219;&#21153;&#21495;&#65307;&#10;    -F: perform test on files only (no directories)&#10;&#9;&#9;&#21482;&#21019;&#24314;&#25991;&#20214;&#65292;&#27809;&#26377;&#30446;&#24405;&#65307;&#10;    -h: prints help message&#10;&#9;&#9;&#36755;&#20986;&#24110;&#21161;&#20449;&#24687;&#10;    -i: number of iterations the test will run&#10;&#9;&#9;&#27979;&#35797;&#36845;&#20195;&#24490;&#29615;&#27425;&#25968;&#65307;&#10;    -I: number of items per tree node&#10;&#9;&#9;&#27599;&#20010;&#26641;&#33410;&#28857;&#21253;&#21547;&#30340;&#39033;&#30446;&#10;    -l: last number of tasks on which the test will run&#10;&#9;&#9;&#26368;&#21518;&#36816;&#34892;&#30340;&#20219;&#21153;&#21495;&#10;    -L: files/dirs created only at leaf level&#10;&#9;&#9;&#21482;&#22312;&#30446;&#24405;&#26641;&#30340;&#8220;&#21494;&#23376;&#8221;&#23618;&#21019;&#24314;&#25991;&#20214;/&#30446;&#24405;&#65307;&#10;    -n: every task will create/stat/remove # files/dirs per tree&#10;&#9;&#9;&#27599;&#20010;&#20219;&#21153;&#38656;&#35201;&#20877;&#27599;&#26869;&#26641;&#20013;create/stat/remove&#30340;&#25991;&#20214;/&#30446;&#24405;&#25968;&#65307;&#10;    -N: stride # between neighbor tasks for file/dir stat (local=0)&#10;&#9;&#9;&#36941;&#21382;&#26102;&#25351;&#23450;&#21644;&#30456;&#37051;&#20219;&#21153;&#30340;&#36328;&#24230;&#10;    -p: pre-iteration delay (in seconds)&#10;&#9;&#9;&#27599;&#27425;&#36845;&#20195;&#20043;&#38388;&#24310;&#26102;&#65288;&#20197;&#31186;&#35745;&#31639;&#65289;&#10;    -r: only remove files/dirs&#10;&#9;&#9; &#21024;&#38500;&#25991;&#20214;/&#30446;&#24405;&#10;    -R: randomly stat files/dirs (optional seed can be provided)&#10;&#9;&#9;&#38543;&#26426;&#36941;&#21382;&#25991;&#20214;/&#30446;&#24405; &#65307;&#10;    -s: stride between the number of tasks for each test&#10;&#9;&#9;&#27599;&#27425;&#27979;&#35797;&#30340;&#20219;&#21153;&#25968;&#30340;&#36328;&#24230;&#10;    -S: shared file access (file only, no directories)&#10;&#9;&#9;&#20849;&#20139;&#25991;&#20214;&#35775;&#38382;&#65288;&#21482;&#38024;&#23545;&#25991;&#20214;&#25805;&#20316;&#65289;&#65307;&#10;    -t: time unique working directory overhead&#10;&#9;&#9;&#35760;&#24405;&#29305;&#23450;&#30446;&#24405;&#30340;&#26102;&#38388;&#24320;&#38144;&#10;    -T: only stat files/dirs&#10;&#9;&#9;&#10;    -u: unique working directory for each task&#10;&#9;&#9;&#20026;&#27599;&#20010;&#20219;&#21153;&#25351;&#23450;&#24037;&#20316;&#30446;&#24405;&#65307;&#10;    -v: verbosity (each instance of option increments by one)&#10;&#9;&#9;&#10;    -V: verbosity value&#10;    -w: number of bytes to write to each file&#10;&#9;&#9; &#20889;&#21040;&#27599;&#20010;&#25991;&#20214;&#30340;&#23383;&#33410;&#25968;&#10;    -y: sync file after write completion&#10;&#9;&#9; &#20877;&#20889;&#25191;&#34892;&#23436;&#21518;&#21516;&#27493;&#25991;&#20214;&#21040;&#30913;&#30424;&#65288;&#21516;&#27493;&#20889;&#65289;&#10;    -z: depth of hierarchical directory structure&#10;&#9;&#9;&#30446;&#24405;&#26641;&#30340;&#28145;&#24230;&#65307;&#10;&#10;NOTES:&#10; * -N allows a &#34;read-your-neighbor&#34; approach by setting stride to&#10;    tasks-per-node. Do not use it with -B, as it creates race conditions.&#10;&#9;&#20801;&#35768;&#34;read-your-neighbor&#34; &#26041;&#27861;&#10; * -d allows multiple paths for the form &#39;-d fullpath1@fullpath2@fullpath3&#39;&#10;      &#21487;&#20197;&#25351;&#23450;&#22810;&#20010;&#27979;&#35797;&#36335;&#24452;&#65292;&#39;-d fullpath1@fullpath2@fullpath3&#39;&#10; * -B allows each task to time itself. The aggregate results reflect this&#10;    change.&#10;&#9;&#20801;&#35768;&#27599;&#20010;&#20219;&#21153;&#23545;&#33258;&#24049;&#36827;&#34892;&#35745;&#26102;&#65307;&#10; * -n and -I cannot be used together.  -I specifies the number of files/dirs&#10;   created per tree node, whereas the -n specifies the total number of&#10;   files/dirs created over an entire tree.  When using -n, integer division is&#10;   used to determine the number of files/dirs per tree node.  (E.g. if -n is&#10;   10 and there are 4 tree nodes (z=1 and b=3), there will be 2 files/dirs per&#10;   tree node.)&#10;&#9;&#10;&#9; * -R and -T can be used separately.  -R merely indicates that if files/dirs&#10;   are going to be stat&#39;ed, then they will be stat&#39;ed randomly.&#10;   &#19981;&#33021;&#21516;&#26102;&#20351;&#29992;&#65292;&#22240;&#20026;&#25351;&#23450;&#20102;&#27599;&#20010;&#26641;&#33410;&#28857;&#30340;&#25991;&#20214;/&#30446;&#24405;&#25968;&#37327;&#65292;&#32780;-I&#25351;&#23450;&#30340;&#26159;&#25972;&#26869;&#26641;&#30340;&#25991;&#20214;/&#30446;&#24405;&#25968;&#37327;&#12290;&#10;&#10;Illustration of terminology:&#10;&#10;                     Hierarchical directory structure (tree)&#10;&#10;                                   =======&#10;                                  |       |  (tree node)&#10;                                   =======&#10;                                  /   |   \&#10;                            ------    |    ------&#10;                           /          |          \&#10;                       =======     =======     =======&#10;                      |       |   |       |   |       |    (leaf level)&#10;                       =======     =======     =======&#10;&#10;    In this example, the tree has a depth of one (z=1) and branching factor of&#10;    three (b=3).  The node at the top of the tree is the root node.  The level&#10;    of nodes furthest from the root is the leaf level.  All trees created by&#10;    mdtest are balanced.&#10;&#9;&#36825;&#20010;&#20363;&#23376;&#20013;&#65292;&#30446;&#24405;&#26641;&#28145;&#24230;&#20026;1&#65288;z=1&#65289;,&#27599;&#20010;&#33410;&#28857;&#20998;&#25903;&#20026;3&#65288;b=3&#65289;.&#26368;&#19978;&#38754;&#30340;&#33410;&#28857;&#20026;&#26681;&#33410;&#28857;&#65292;</span><br></pre></td></tr></table></figure></p>
<p>关于openmpi的软件的使用</p>
<p>openmpi是并行的运行程序，配置的时候需要注意下<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#22686;&#21152;&#24182;&#34892;&#30340;&#36816;&#34892;&#33410;&#28857;&#10;[root@lab8105 ~]# vim /etc/openmpi-x86_64/openmpi-default-hostfile&#10;&#28155;&#21152;&#10;lab8105 slots=1&#10;lab8106 slots=1&#10;&#29305;&#21035;&#27880;&#24847;&#21152;slots &#36825;&#20010;&#26159;&#37197;&#32622;&#26435;&#37325;&#30340;&#65292;&#22914;&#26524;&#19981;&#37197;&#32622;&#65292;&#31532;&#19968;&#26465;&#26377;&#40664;&#35748;&#26435;&#37325;&#65292;&#23601;&#26080;&#27861;&#22312;&#25968;&#30446;&#23567;&#26102;&#36827;&#34892;&#22343;&#34913;&#25805;&#20316;&#10;&#26816;&#26597;&#26159;&#21542;&#37197;&#32622;&#25104;&#21151;&#65292;np&#20026;&#25805;&#20316;&#32447;&#31243;&#25968;&#10;[root@lab8105 ~]# mpirun  --allow-run-as-root -np 2 hostname&#10;lab8105&#10;lab8106&#10;&#22914;&#26524;&#24819;&#21333;&#26426;&#25191;&#34892;&#22810;&#36827;&#31243;&#65292;&#21487;&#20197;&#29992;-host&#25351;&#23450;&#20027;&#26426;&#10;[root@lab8105 ~]# mpirun -host lab8105  --allow-run-as-root -np 2 hostname</span><br></pre></td></tr></table></figure></p>
<h3 id="单机下多进程测试">单机下多进程测试</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">2 task on 1 node&#10;[root@lab8105 ~]# mpirun -host lab8105  --allow-run-as-root -np 2 mdtest -I 10  -z 5 -b 2 -d /mnt/zptest/ -t -c 2&#10;-- started at 01/27/2015 21:06:23 --&#10;&#10;mdtest-1.9.3 was launched with 2 total task(s) on 1 node(s)&#10;Command line used: mdtest -I 10 -z 5 -b 2 -d /mnt/zptest/ -t -c 2&#10;Path: /mnt/zptest&#10;FS: 6.5 TiB   Used FS: 59.2%   Inodes: 0.6 Mi   Used Inodes: 100.0%&#10;&#10;2 tasks, 1260 files/directories&#10;&#10;SUMMARY: (of 1 iterations)&#10;   Operation                      Max            Min           Mean        Std Dev&#10;   ---------                      ---            ---           ----        -------&#10;   Directory creation:        312.088        312.088        312.088          0.000&#10;   Directory stat    :      73447.245      73447.245      73447.245          0.000&#10;   Directory removal :        255.755        255.755        255.755          0.000&#10;   File creation     :        638.824        638.824        638.824          0.000&#10;   File stat         :      86747.366      86747.366      86747.366          0.000&#10;   File read         :      84434.232      84434.232      84434.232          0.000&#10;   File removal      :        207.545        207.545        207.545          0.000&#10;   Tree creation     :         39.062         39.062         39.062          0.000&#10;   Tree removal      :         46.971         46.971         46.971          0.000&#10;&#10;-- finished at 01/27/2015 21:06:43 --</span><br></pre></td></tr></table></figure>
<h3 id="多机并发测试">多机并发测试</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#22914;&#19979;&#26174;&#31034;&#30340;2 task on 2 node&#10;&#10;[root@lab8105 ~]#  mpirun  --allow-run-as-root -np 2 mdtest -I 10  -z 5 -b 2 -d /mnt/zptest/ -t -c 2&#10;-- started at 01/27/2015 21:04:35 --&#10;&#10;mdtest-1.9.3 was launched with 2 total task(s) on 2 node(s)&#10;Command line used: mdtest -I 10 -z 5 -b 2 -d /mnt/zptest/ -t -c 2&#10;Path: /mnt/zptest&#10;FS: 6.5 TiB   Used FS: 59.2%   Inodes: 0.6 Mi   Used Inodes: 100.0%&#10;&#10;2 tasks, 1260 files/directories&#10;&#10;SUMMARY: (of 1 iterations)&#10;   Operation                      Max            Min           Mean        Std Dev&#10;   ---------                      ---            ---           ----        -------&#10;   Directory creation:        312.355        312.355        312.355          0.000&#10;   Directory stat    :       1611.000       1611.000       1611.000          0.000&#10;   Directory removal :        127.333        127.333        127.333          0.000&#10;   File creation     :        309.295        309.295        309.295          0.000&#10;   File stat         :     113257.534     113257.534     113257.534          0.000&#10;   File read         :     203458.057     203458.057     203458.057          0.000&#10;   File removal      :         98.523         98.523         98.523          0.000&#10;   Tree creation     :         36.566         36.566         36.566          0.000&#10;   Tree removal      :         20.191         20.191         20.191          0.000&#10;&#10;-- finished at 01/27/2015 21:05:12 --</span><br></pre></td></tr></table></figure>
<p>关于目录生成的问题：<br>这个是 -z 2 -b 3<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 mnt]<span class="comment"># ls mdtest2/#test-dir.0/mdtest_tree.0/</span></span><br><span class="line">mdtest_tree.<span class="number">1</span>  mdtest_tree.<span class="number">2</span>  mdtest_tree.<span class="number">3</span></span><br><span class="line">[root@lab8106 mnt]<span class="comment"># ls mdtest2/#test-dir.0/mdtest_tree.0/mdtest_tree.1/</span></span><br><span class="line">mdtest_tree.<span class="number">4</span>  mdtest_tree.<span class="number">5</span>  mdtest_tree.<span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p>这个是以这个目录开始的<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 mnt]<span class="comment"># ls mdtest2/#test-dir.0/mdtest_tree.0/</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>软件介绍</p>
<p> mdstest是软件的元数据操作基准测试工具，用来模拟对文件或者目录的open、stat、close操作，然后报告性能</p>
<p>下载软件压缩包：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install openmpi openmpi-devel -y</span><br><span class="line">在/root/.bashrc中添加（注意也要添加mdtest的路径）</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/lib64/openmpi/bin/</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /root/.bashrc</span><br><span class="line">下载</span><br><span class="line">[root@lab8105 ~]<span class="comment"># wget http://sourceforge.net/projects/mdtest/files/latest/download</span></span><br><span class="line">解压</span><br><span class="line">[root@lab8105 ~]<span class="comment"># tar -xvf mdtest-1.9.3.tgz</span></span><br><span class="line">修改makefile：</span><br><span class="line">mdtest: mdtest.c</span><br><span class="line">       mpicc -Wall -D $(OS) $(LARGE_FILE) $(MDTEST_FLAGS) -g -o mdtest mdtest.c -lm</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="测试工具" scheme="http://www.zphj1987.com/tags/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[cgroup实践-资源控制]]></title>
    <link href="http://www.zphj1987.com/2015/03/24/cgroup%E5%AE%9E%E8%B7%B5-%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6/"/>
    <id>http://www.zphj1987.com/2015/03/24/cgroup实践-资源控制/</id>
    <published>2015-03-24T05:32:19.000Z</published>
    <updated>2015-09-23T07:25:23.788Z</updated>
    <content type="html"><![CDATA[<p>1、Cgroup安装</p>
<p>安装Cgroups需要libcap-devel和libcgroup两个相关的包<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	yum install gcc libcap-devel </span><br><span class="line">```	</span><br><span class="line"><span class="number">2</span>、Cgroup挂载配置</span><br><span class="line">```raw</span><br><span class="line">	Cgroup对应服务名称为cgconfig，cgconfig默认采用“多挂载点”挂载。经过实际测试，发现在CentOS环境中应采用“单挂载点”进行挂载，因此应当卸载原有cgroup文件系统，并禁用cgconfig。</span><br><span class="line">	cgclear或者sudo service cgconfig stop <span class="comment"># 停止cgconfig，卸载cgroup目录</span></span><br><span class="line">	sudo chkconfig cgconfig off          <span class="comment"># 禁用cgconfig服务，避免其开机启动</span></span><br><span class="line">	然后采用“单挂载点”方式重新挂载cgroup。</span><br><span class="line">	可以直接手动挂载，这样仅当次挂载成功。</span><br><span class="line">	mount -t cgroup none /cgroup</span><br><span class="line">	然后编辑/etc/fstab/，输入下列内容。这样每次开机后都会自动挂载。</span><br><span class="line">	none   /cgroup  cgroup  defaults   <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>3、常用的Cgroup相关命令和配置文件<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#9;service cgconfig status|start|stop|restart    #&#26597;&#30475;&#24050;&#23384;&#22312;&#23376;&#31995;&#32479;&#10;&#9;lssubsys &#8211;am    #&#26597;&#30475;&#24050;&#23384;&#22312;&#23376;&#31995;&#32479;&#10;&#9;cgclear   # &#28165;&#38500;&#25152;&#26377;&#25346;&#36733;&#28857;&#20869;&#37096;&#25991;&#20214;&#65292;&#30456;&#24403;&#20110;service  cgconfig stop&#10;&#9;cgconfigparser -l /etc/cgconfig.conf    #&#37325;&#26032;&#25346;&#36733;&#10;&#9;&#10;&#9;Cgroup&#40664;&#35748;&#25346;&#36733;&#28857;&#65288;CentOS&#65289;&#65306;/cgroup&#10;&#9;cgconfig&#37197;&#32622;&#25991;&#20214;&#65306;/etc/cgconfig.conf&#10;```&#9;&#10;4&#12289;libcgroup Man Page&#31616;&#20171;&#10;```raw&#10;&#9;man 1 cgclassify -- cgclassify&#21629;&#20196;&#26159;&#29992;&#26469;&#23558;&#36816;&#34892;&#30340;&#20219;&#21153;&#31227;&#21160;&#21040;&#19968;&#20010;&#25110;&#32773;&#22810;&#20010;cgroup&#12290;&#10;&#9;man 1 cgclear -- cgclear &#21629;&#20196;&#26159;&#29992;&#26469;&#21024;&#38500;&#23618;&#32423;&#20013;&#30340;&#25152;&#26377;cgroup&#12290;&#10;&#9;man 5 cgconfig.conf -- &#22312;cgconfig.conf&#25991;&#20214;&#20013;&#23450;&#20041;cgroup&#12290;&#10;&#9;man 8 cgconfigparser -- cgconfigparser&#21629;&#20196;&#35299;&#26512;cgconfig.conf&#25991;&#20214;&#21644;&#24182;&#25346;&#36733;&#23618;&#32423;&#12290;&#10;&#9;&#10;&#9;man 1 cgcreate -- cgcreate&#22312;&#23618;&#32423;&#20013;&#21019;&#24314;&#26032;cgroup&#12290;&#10;&#9;man 1 cgdelete -- cgdelete&#21629;&#20196;&#21024;&#38500;&#25351;&#23450;&#30340;cgroup&#12290;&#10;&#9;man 1 cgexec -- cgexec&#21629;&#20196;&#22312;&#25351;&#23450;&#30340;cgroup&#20013;&#36816;&#34892;&#20219;&#21153;&#12290;&#10;&#9;man 1 cgget -- cgget&#21629;&#20196;&#26174;&#31034;cgroup&#21442;&#25968;&#12290;&#10;&#9;man 5 cgred.conf -- cgred.conf&#26159;cgred&#26381;&#21153;&#30340;&#37197;&#32622;&#25991;&#20214;&#12290;&#10;&#9;man 5 cgrules.conf -- cgrules.conf &#21253;&#21547;&#29992;&#26469;&#20915;&#23450;&#20309;&#26102;&#20219;&#21153;&#26415;&#35821;&#26576;&#20123;  cgroup&#30340;&#35268;&#21017;&#12290;&#10;&#9;&#10;&#9;man 8 cgrulesengd -- cgrulesengd &#22312;  cgroup &#20013;&#21457;&#24067;&#20219;&#21153;&#12290;&#10;&#9;man 1 cgset -- cgset &#21629;&#20196;&#20026;  cgroup &#35774;&#23450;&#21442;&#25968;&#12290;&#10;&#9;man 1 lscgroup -- lscgroup &#21629;&#20196;&#21015;&#20986;&#23618;&#32423;&#20013;&#30340;  cgroup&#12290;&#10;&#9;man 1 lssubsys -- lssubsys &#21629;&#20196;&#21015;&#20986;&#21253;&#21547;&#25351;&#23450;&#23376;&#31995;&#32479;&#30340;&#23618;&#32423;&#12290;</span><br></pre></td></tr></table></figure></p>
<h3 id="测试一：限制cpu的资源">测试一：限制cpu的资源</h3><p>测试后验证了可以做到：</p>
<ul>
<li>限制进程的cpu占用百分比</li>
<li>限制多个进程组的之间的cpu使用权重</li>
<li>指定进程的使用的cpu和内存组（绑定cpu）</li>
</ul>
<p>跑一个耗cpu的脚本<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> [ True ];<span class="keyword">do</span></span><br><span class="line">    x=<span class="variable">$x</span>+<span class="number">1</span></span><br><span class="line"><span class="keyword">done</span>;</span><br></pre></td></tr></table></figure></p>
<p>top可以看到这个脚本基本占了100%的cpu资源<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">top - 15:30:01 up  1:03,  5 users,  load average: 0.30, 0.50, 0.39&#10;Tasks: 210 total,   2 running, 208 sleeping,   0 stopped,   0 zombie&#10;Cpu(s):  6.3%us,  0.1%sy,  0.0%ni, 93.5%id,  0.2%wa,  0.0%hi,  0.0%si,  0.0%st&#10;Mem:  49461228k total, 13412644k used, 36048584k free,    75384k buffers&#10;Swap:  2097148k total,        0k used,  2097148k free, 12498636k cached&#10;&#10;  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND&#10;11605 root      20   0  104m 1528 1016 R 99.7  0.0   2:30.48 sh&#10;105 root      20   0     0    0    0 S  0.3  0.0   0:00.11 kworker/8:1</span><br></pre></td></tr></table></figure></p>
<p>创建一个控制组控制这个进程的cpu资源<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /cgroup/cpu/foo	     <span class="comment">#新建一个控制组foo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="number">50000</span> &gt; /cgroup/cpu/foo/cpu.cfs_quota_us  <span class="comment">#将cpu.cfs_quota_us设为50000，相对于cpu.cfs_period_us的100000是50%</span></span><br><span class="line"><span class="built_in">echo</span> <span class="number">11605</span> &gt; /cgroup/cpu/foo/tasks</span><br></pre></td></tr></table></figure></p>
<p>然后top的实时统计数据如下，cpu占用率将近50%，看来cgroups关于cpu的控制起了效果<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">top - 15:32:48 up  1:06,  5 users,  load average: 0.80, 0.68, 0.48&#10;Tasks: 210 total,   2 running, 208 sleeping,   0 stopped,   0 zombie&#10;Cpu(s):  3.2%us,  0.0%sy,  0.0%ni, 96.8%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st&#10;Mem:  49461228k total, 13412276k used, 36048952k free,    75400k buffers&#10;Swap:  2097148k total,        0k used,  2097148k free, 12498652k cached&#10;&#10;PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND&#10;11605 root      20   0  104m 1724 1016 R 50.2  0.0   5:09.97 sh&#10;11639 root      20   0 15200 1200  820 R  0.3  0.0   0:00.03 top</span><br></pre></td></tr></table></figure></p>
<p>可以看到，进程的 cpu 占用已经被成功地限制到了 50% 。这里，测试的虚拟机只有一个核心。在多核情况下，看到的值会不一样。另外，cfs_quota_us 也是可以大于 cfs_period_us 的，这主要是对于多核情况。有 n 个核时，一个控制组中的进程自然最多就能用到 n 倍的 cpu 时间。</p>
<p>这两个值在 cgroups 层次中是有限制的，下层的资源不能超过上层。具体的说，就是下层的 cpu.cfs_period_us 值不能小于上层的值，cpu.cfs_quota_us 值不能大于上层的值。</p>
<p>另外的一组 cpu.rt_period_us、cpu.rt_runtime_us 对应的是实时进程的限制，平时可能不会有机会用到。</p>
<p>在 cpu 子系统中，cpu.stat 就是用前面那种方法做的资源限制的统计了。nr_periods、nr_throttled 就是总共经过的周期，和其中受限制的周期。throttled_time 就是总共被控制组掐掉的 cpu 使用时间。</p>
<p>还有个 cpu.shares， 它也是用来限制 cpu 使用的。但是与 cpu.cfs_quota_us、cpu.cfs_period_us 有挺大区别。cpu.shares 不是限制进程能使用的绝对的 cpu 时间，而是控制各个组之间的配额。比如<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">/cpu/cpu.shares : 1024&#10;/cpu/foo/cpu.shares : 2048</span><br></pre></td></tr></table></figure></p>
<p>那么当两个组中的进程都满负荷运行时，/foo 中的进程所能占用的 cpu 就是 / 中的进程的两倍。如果再建一个 /foo/bar 的 cpu.shares 也是 1024，且也有满负荷运行的进程，那 /、/foo、/foo/bar 的 cpu 占用比就是 1:2:1 。前面说的是各自都跑满的情况。如果其他控制组中的进程闲着，那某一个组的进程完全可以用满全部 cpu。可见通常情况下，这种方式在保证公平的情况下能更充分利用资源。</p>
<p>此外，还可以限定进程可以使用哪些 cpu 核心。cpuset 子系统就是处理进程可以使用的 cpu 核心和内存节点，以及其他一些相关配置。这部分的很多配置都和 NUMA 有关。其中 cpuset.cpus、cpuset.mems 就是用来限制进程可以使用的 cpu 核心和内存节点的。这两个参数中 cpu 核心、内存节点都用 id 表示，之间用 “,” 分隔。比如 0,1,2 。也可以用 “-” 表示范围，如 0-3 。两者可以结合起来用。如“0-2,6,7”。在添加进程前，cpuset.cpus、cpuset.mems 必须同时设置，而且必须是兼容的，否则会出错。例如<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo 0 &gt;/sys/fs/cgroup/cpuset/foo/cpuset.cpus</span></span><br><span class="line"><span class="comment"># echo 0 &gt;/sys/fs/cgroup/cpuset/foo/cpuset.mems</span></span><br><span class="line">这样， /foo 中的进程只能使用 cpu0 和内存节点<span class="number">0</span>。用</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat /proc/&lt;pid&gt;/status|grep '_allowed_list'</span></span><br></pre></td></tr></table></figure></p>
<p>cgroups 除了用来限制资源使用外，还有资源统计的功能。做云计算的计费就可以用到它。有一个 cpuacct 子系统专门用来做 cpu 资源统计。cpuacct.stat 统计了该控制组中进程用户态和内核态的 cpu 使用量，单位是 USER_HZ，也就是 jiffies、cpu 滴答数。每秒的滴答数可以用 getconf CLK_TCK 来获取，通常是 100。将看到的值除以这个值就可以换算成秒。</p>
<h3 id="测试二：限制进程的内存资源">测试二：限制进程的内存资源</h3><p>测试后验证了：</p>
<ul>
<li>限制了资源的占用，达到内存以后，进程直接杀掉</li>
</ul>
<p>测试方法：</p>
<p>跑一个耗内存的脚本，内存不断增长<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x=<span class="string">"a"</span></span><br><span class="line"><span class="keyword">while</span> [ True ];<span class="keyword">do</span></span><br><span class="line">    x=<span class="variable">$x</span><span class="variable">$x</span></span><br><span class="line"><span class="keyword">done</span>;</span><br></pre></td></tr></table></figure></p>
<p>top看内存占用稳步上升<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"> PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND&#10;       30215 root      20   0  871m 501m 1036 R 99.8 26.7   0:38.69 sh  &#10;30215 root      20   0 1639m 721m 1036 R 98.7 38.4   1:03.99 sh &#10;30215 root      20   0 1639m 929m 1036 R 98.6 49.5   1:13.73 sh</span><br></pre></td></tr></table></figure></p>
<p>下面用cgroups控制这个进程的内存资源<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /cgroup/memory/foo</span><br><span class="line"><span class="built_in">echo</span> <span class="number">1048576</span> &gt;  /cgroup/memory/foo/memory.limit_<span class="keyword">in</span>_bytes   <span class="comment">#分配1MB的内存给这个控制组</span></span><br><span class="line"><span class="built_in">echo</span> <span class="number">30215</span> &gt; /cgroup/memory/foo/tasks</span><br></pre></td></tr></table></figure></p>
<p>发现之前的脚本被kill掉<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># sh /home/test.sh </span></span><br><span class="line">已杀死</span><br></pre></td></tr></table></figure></p>
<p>因为这是强硬的限制内存，当进程试图占用的内存超过了cgroups的限制，会触发out of memory，导致进程被kill掉。</p>
<p>实际情况中对进程的内存使用会有一个预估，然后会给这个进程的限制超配50%比如，除非发生内存泄露等异常情况，才会因为cgroups的限制被kill掉。</p>
<p>也可以通过配置关掉cgroups oom kill进程，通过memory.oom_control来实现（oom_kill_disable 1），但是尽管进程不会被直接杀死，但进程也进入了休眠状态，无法继续执行，仍让无法服务。</p>
<p>关于内存的控制，还有以下配置文件，关于虚拟内存的控制，以及权值比重式的内存控制等<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# ls /cgroup/memory/foo/&#10;cgroup.event_control  memory.force_empty         memory.memsw.failcnt             &#10;memory.memsw.usage_in_bytes      memory.soft_limit_in_bytes  memory.usage_in_bytes  tasks&#10;cgroup.procs          memory.limit_in_bytes      memory.memsw.limit_in_bytes      &#10;memory.move_charge_at_immigrate  memory.stat                 memory.use_hierarchy&#10;memory.failcnt        memory.max_usage_in_bytes  memory.memsw.max_usage_in_bytes  &#10;memory.oom_control               memory.swappiness           notify_on_release</span><br></pre></td></tr></table></figure></p>
<h3 id="测试三：限制进程的IO资源">测试三：限制进程的IO资源</h3><p>测试验证了：</p>
<ul>
<li>能够控制io设备的读写速度</li>
</ul>
<p>跑一个耗io的脚本</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#9; dd if=/dev/sda of=/dev/null &#10;&#10;&#9;&#36890;&#36807;iotop&#30475;io&#21344;&#29992;&#24773;&#20917;&#65292;&#30913;&#30424;&#36895;&#24230;&#21040;&#20102;284M/s&#10;&#10;&#10;&#9;30252 be/4 root      284.71 M/s    0.00 B/s  0.00 %  0.00 % dd if=/dev/sda of=/dev/null&#10;``` &#10;&#19979;&#38754;&#29992;cgroups&#25511;&#21046;&#36825;&#20010;&#36827;&#31243;&#30340;io&#36164;&#28304;&#10;```bash&#10;&#9;mkdir -p /cgroup/blkio/foo&#10;&#9;&#10;&#9;echo &#39;8:0   1048576&#39; &#62;  /cgroup/blkio/foo/blkio.throttle.read_bps_device&#10;&#9;#8:0&#23545;&#24212;&#20027;&#35774;&#22791;&#21495;&#21644;&#21103;&#35774;&#22791;&#21495;&#65292;&#21487;&#20197;&#36890;&#36807;ls -l /dev/sda&#26597;&#30475;&#10;&#9;echo 30252 &#62; /cgroup/blkio/foo/tasks</span><br></pre></td></tr></table></figure>
<p>再通过iotop看，确实将读速度降到了1M/s<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">30252 be/4 root      993.36 K/s    0.00 B/s  0.00 %  0.00 % dd if=/dev/sda of=/dev/null</span><br></pre></td></tr></table></figure></p>
<p>对于io还有很多其他可以控制层面和方式，如下<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls /cgroup/blkio/foo/</span></span><br><span class="line">blkio.io_merged         blkio.io_serviced      blkio.reset_stats                </span><br><span class="line">blkio.throttle.io_serviced       blkio.throttle.write_bps_device   blkio.weight          cgroup.procs</span><br><span class="line">blkio.io_queued         blkio.io_service_time  blkio.sectors                    </span><br><span class="line">blkio.throttle.read_bps_device   blkio.throttle.write_iops_device  blkio.weight_device   notify_on_release</span><br><span class="line">blkio.io_service_bytes  blkio.io_<span class="built_in">wait</span>_time     blkio.throttle.io_service_bytes  </span><br><span class="line">blkio.throttle.read_iops_device  blkio.time                        cgroup.event_control  tasks</span><br></pre></td></tr></table></figure></p>
<p>blkio 子系统里东西很多。不过大部分都是只读的状态报告，可写的参数就只有下面这几个：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">blkio.throttle.read_bps_device&#10;blkio.throttle.read_iops_device&#10;blkio.throttle.write_bps_device&#10;blkio.throttle.write_iops_device&#10;blkio.weight&#10;blkio.weight_device&#10;&#10;&#36825;&#20123;&#37117;&#26159;&#29992;&#26469;&#25511;&#21046;&#36827;&#31243;&#30340;&#30913;&#30424; io &#30340;&#12290;&#24456;&#26126;&#26174;&#22320;&#20998;&#25104;&#20004;&#31867;&#65292;&#20854;&#20013;&#24102;&#8220;throttle&#8221;&#30340;&#65292;&#39038;&#21517;&#24605;&#20041;&#23601;&#26159;&#33410;&#27969;&#38400;&#65292;&#23558;&#27969;&#37327;&#38480;&#21046;&#22312;&#26576;&#20010;&#20540;&#19979;&#12290;&#32780;&#8220;weight&#8221;&#23601;&#26159;&#20998;&#37197; io &#30340;&#26435;&#37325;&#12290;&#10;&#20877;&#30475;&#30475; blkio.weight &#12290;blkio &#30340; throttle &#21644; weight &#26041;&#24335;&#21644; cpu &#23376;&#31995;&#32479;&#30340; quota &#21644; shares &#26377;&#28857;&#20687;&#65292;&#37117;&#26159;&#19968;&#31181;&#26159;&#32477;&#23545;&#38480;&#21046;&#65292;&#21478;&#19968;&#31181;&#26159;&#30456;&#23545;&#38480;&#21046;&#65292;&#24182;&#19988;&#22312;&#19981;&#32321;&#24537;&#30340;&#26102;&#20505;&#21487;&#20197;&#20805;&#20998;&#21033;&#29992;&#36164;&#28304;&#65292;&#26435;&#37325;&#20540;&#30340;&#33539;&#22260;&#22312; 10 &#8211; 1000 &#20043;&#38388;&#12290;</span><br></pre></td></tr></table></figure></p>
<p>测试权重方式要麻烦一点。因为不是绝对限制，所以会受到文件系统缓存的影响。如在虚拟机中测试，要关闭虚机如我用的 VirtualBox 在宿主机上的缓存。如要测试读 io 的效果，先生成两个几个 G 的大文件 /tmp/file_1，/tmp/file_2 ，可以用 dd 搞。然后设置两个权重<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo 500 &gt;/sys/fs/cgroup/blkio/foo/blkio.weight</span></span><br><span class="line"><span class="comment"># echo 100 &gt;/sys/fs/cgroup/blkio/bar/blkio.weight</span></span><br></pre></td></tr></table></figure></p>
<p>测试前清空文件系统缓存，以免干扰测试结果<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sync</span><br><span class="line"><span class="built_in">echo</span> <span class="number">3</span> &gt;/proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure></p>
<p>在这两个控制组中用 dd 产生 io 测试效果。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cgexec -g "blkio:foo" dd if=/tmp/file_1 of=/dev/null &amp;</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">1838</span></span><br><span class="line"><span class="comment"># cgexec -g "blkio:bar" dd if=/tmp/file_2 of=/dev/null &amp;</span></span><br><span class="line">[<span class="number">2</span>] <span class="number">1839</span></span><br></pre></td></tr></table></figure></p>
<p>还是用 iotop 看看效果<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"> TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&#62;    COMMAND&#10;1839 be/4 root       48.14 M/s    0.00 B/s  0.00 % 99.21 % dd if=/tmp/file_2 of=/dev/null&#10;1838 be/4 root      223.59 M/s    0.00 B/s  0.00 % 16.44 % dd if=/tmp/file_1 of=/dev/null</span><br></pre></td></tr></table></figure></p>
<p>两个进程每秒读的字节数虽然会不断变动，但是大致趋势还是维持在 1:5 左右，和设定的 weight 比例一致。blkio.weight_device 是分设备的。写入时，前面再加上设备号即可。</p>
<h2 id="实践记录">实践记录</h2><p>1、假如已经配置好一个资源组，现在想让一个服务按这个组的资源分配来运行服务，而不需要去找到进程号再写入到tasks中<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8105 ~]<span class="comment"># cgexec -g cpu:daemons/ftp top</span></span><br></pre></td></tr></table></figure></p>
<p>这个运行以后有会自动将top进程号写入到tasks当中去</p>
<p>2、查询一个组里面设置的资源的限制<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#35774;&#32622;&#30340;&#20540;&#20250;&#26174;&#31034;&#20986;&#26469;&#65292;&#27809;&#26377;&#35774;&#32622;&#30340;&#23601;&#20250;&#25552;&#31034;&#27809;&#26377;&#25214;&#25171;&#10;&#10;[root@lab8105 ~]# cgget  daemons/ftp&#10;daemons/ftp:&#10;cgget: cannot find controller &#39;cpuset&#39; in group &#39;daemons/ftp&#39;&#10;cpu.rt_period_us: 1000000&#10;cpu.rt_runtime_us: 0&#10;cpu.stat: nr_periods 0&#10;&#9;nr_throttled 0&#10;&#9;throttled_time 0&#10;cpu.cfs_period_us: 5000&#10;cpu.cfs_quota_us: -1&#10;cpu.shares: 1000&#10;cgget: cannot find controller &#39;cpuacct&#39; in group &#39;daemons/ftp&#39;&#10;cgget: cannot find controller &#39;memory&#39; in group &#39;daemons/ftp&#39;&#10;cgget: cannot find controller &#39;devices&#39; in group &#39;daemons/ftp&#39;&#10;cgget: cannot find controller &#39;freezer&#39; in group &#39;daemons/ftp&#39;&#10;cgget: cannot find controller &#39;net_cls&#39; in group &#39;daemons/ftp&#39;&#10;cgget: cannot find controller &#39;blkio&#39; in group &#39;daemons/ftp&#39;</span><br></pre></td></tr></table></figure></p>
<p>3、需要用两个限制条件对进程进行限制<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8105 ~]<span class="comment"># cgexec -g cpu:daemons/ftp -g memory:daemons/ftp top</span></span><br></pre></td></tr></table></figure></p>
<p>4、默认情况下是一个大根，然后分了几个资源系统，还支持做一个子系统组，即单独组建一个资源组，然后对这个资源组里面进行配置，具体方法如下：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mount &#123;&#10;        cpu     = /cgroup/cpu_and_mem;&#10;        memory  = /cgroup/cpu_and_mem;&#10;&#125;&#10;&#9;&#10;group daemons/ftp &#123;&#10;                     cpu &#123;&#10;                             cpu.shares = &#34;1000&#34;;&#10;                             cpu.cfs_period_us = &#34;5000&#34;;&#10;                     &#125;&#10;                     memory &#123;&#10;                                memory.swappiness = &#34;20&#34;;&#10;                     &#125;&#10;              &#125;</span><br></pre></td></tr></table></figure></p>
<p>5、需要创建控制组群，如上的daemons/ftp，想通过命令行的方式创建<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8105 ~]<span class="comment"># cgcreate -g cpu:/zp -g memory:/zp	</span></span><br><span class="line">如上命令使用后会在/cgroup/cpu/中多了zp目录，并且里面是继承的上级的cpu里面的参数，这样就创建了一个zp的组群</span><br><span class="line"></span><br><span class="line">删除组群的方式如下（删除cgroup时，其所有任务都移动到了父组群当中）：</span><br><span class="line">[root@lab8105 ~]<span class="comment"># cgdelete cpu:/zp memory:/zp</span></span><br></pre></td></tr></table></figure></p>
<p>6、设置里面的配置参数<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#38656;&#35201;&#35774;&#32622;&#10; /cgroup/cpu/daemons/ftp/cpu.shares&#10;&#25191;&#34892;&#10;[root@lab8105 ~]# cgset -r cpu.shares=500 daemons/ftp&#10;daemons/ftp&#36335;&#24452;&#26159;&#30456;&#23545;&#20110;&#26681;&#30340;&#65292;&#22914;&#26524;&#24819;&#35774;&#32622;&#26681;&#30340;&#36825;&#20010;&#21442;&#25968;&#37027;&#20040;&#23601;&#25191;&#34892;&#10;[root@lab8105 ~]# gset -r cpuacct.usage=0 /&#10;&#9;&#36825;&#37324;&#38656;&#35201;&#27880;&#24847;&#65292;&#21482;&#26377;&#26576;&#20123;&#21442;&#25968;&#26159;&#21487;&#20197;&#20462;&#25913;&#30340;&#65292;&#26576;&#20123;&#21442;&#25968;&#26159;&#19981;&#33021;&#20462;&#25913;&#30340;&#10;&#20063;&#21487;&#20197;&#30452;&#25509;echo&#30340;&#26041;&#24335;&#36827;&#34892;&#21442;&#25968;&#30340;&#35774;&#32622;</span><br></pre></td></tr></table></figure></p>
<p>7，移动某个进程到控制组群当中（动态的进行资源的调配）<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#31227;&#21160;&#25351;&#23450;&#36827;&#31243;&#21040;&#25351;&#23450;&#30340;&#25511;&#21046;&#32452;&#24403;&#20013;&#65292;&#21019;&#24314;&#20004;&#20010;&#36164;&#28304;&#32452;&#65292;&#20351;&#29992;&#19978;&#38754;&#30340;cpu&#30340;&#33050;&#26412;&#65292;&#28982;&#21518;&#36816;&#34892;&#21518;&#65292;&#20351;&#29992;top&#36827;&#34892;&#30417;&#25511;&#10;group half &#123;&#10;                     cpu &#123;&#10;                                 cpu.cfs_period_us=&#34;100000&#34;;&#10;                                 cpu.cfs_quota_us=&#34;50000&#34;;&#10;                     &#125;&#10;                     memory &#123;&#10;                                memory.swappiness = &#34;50&#34;;&#10;                     &#125;&#10;              &#125;&#10;&#10;group eighty &#123;&#10;                     cpu &#123;&#10;                              cpu.cfs_period_us = &#34;100000&#34;;&#10;                              cpu.cfs_quota_us=&#34;50000&#34;;&#10;                     &#125;&#10;                     memory &#123;&#10;                                memory.swappiness = &#34;80&#34;;&#10;                     &#125;&#10;              &#125;&#10;[root@lab8105 ~]# cgclassify -g cpu:half 14245&#10;top&#30417;&#25511;&#30475;&#21040;cpu&#30340;&#21344;&#29992;&#20026;50%&#10;[root@lab8105 ~]# cgclassify -g cpu:eighty 14245&#10;top&#30417;&#25511;&#30475;&#21040;cpu&#30340;&#21344;&#29992;&#20026;80%&#10;&#27880;&#24847;&#25903;&#25345;&#22810;&#36827;&#31243;&#65292;&#22810;&#36164;&#28304;&#32452;&#21516;&#26102;&#31227;&#21160;&#10;[root@lab8105 ~]# cgclassify -g cpu,memory:eighty 14245 14565&#10;&#22791;&#29992;&#26041;&#27861;&#23601;&#26159;&#30452;&#25509;echo</span><br></pre></td></tr></table></figure></p>
<p>8、通过规则对指定的进程进行控制</p>
<p>我们还可以通过设置规则来让 cgred（cgroup 规则引擎后台程序）自动将进程分配给特定组。cgred 后台程序根据 /etc/cgrules.conf 文件中的设置将任务移到 cgroup 中<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8105 ~]<span class="comment"># vim /etc/cgrules.conf </span></span><br><span class="line">[root@lab8105 ~]<span class="comment"># man cgrules.conf       </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/cgrules.conf</span></span><br><span class="line"><span class="comment">#The format of this file is described in cgrules.conf(5)</span></span><br><span class="line"><span class="comment">#manual page.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Example:</span></span><br><span class="line"><span class="comment">#&lt;user&gt;         &lt;controllers&gt;   &lt;destination&gt;</span></span><br><span class="line"><span class="comment">#@student       cpu,memory      usergroup/student/</span></span><br><span class="line"><span class="comment">#peter          cpu             test1/</span></span><br><span class="line"><span class="comment">#%              memory          test2/</span></span><br><span class="line"><span class="comment"># End of file</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">root:cpu.sh           cpu             half/</span><br><span class="line">root                  cpu             half/</span><br><span class="line"></span><br><span class="line">启动监控进程服务</span><br><span class="line">[root@lab8105 ~]<span class="comment"># /etc/init.d/cgred</span></span><br></pre></td></tr></table></figure></p>
<p>效果如下，运行相同的命令，所占用的cpu的资源按指定的比例进行占用</p>
<pre><code class="bash">[root@lab8105 ~]<span class="comment"># top</span>
top - <span class="number">16</span>:<span class="number">00</span>:<span class="number">40</span> up <span class="number">1</span> day,  <span class="number">1</span>:<span class="number">34</span>,  <span class="number">5</span> users,  load average: <span class="number">1.57</span>, <span class="number">1.13</span>, <span class="number">0.90</span>
Tasks: <span class="number">216</span> total,   <span class="number">3</span> running, <span class="number">213</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">0</span> zombie
Cpu(s):  <span class="number">6.9</span>%us,  <span class="number">0.0</span>%sy,  <span class="number">0.0</span>%ni, <span class="number">93.1</span>%id,  <span class="number">0.0</span>%wa,  <span class="number">0.0</span>%hi,  <span class="number">0.0</span>%si,  <span class="number">0.0</span>%st
Mem:  <span class="number">49461228</span>k total, <span class="number">49346312</span>k used,   <span class="number">114916</span>k free, <span class="number">47374260</span>k buffers
Swap:  <span class="number">2097148</span>k total,        <span class="number">0</span>k used,  <span class="number">2097148</span>k free,    <span class="number">33116</span>k cached

  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                               
<span class="number">14648</span> root      <span class="number">20</span>   <span class="number">0</span>  <span class="number">104</span>m <span class="number">1716</span> <span class="number">1012</span> R <span class="number">99.7</span>  <span class="number">0.0</span>   <span class="number">4</span>:<span class="number">58.38</span> cpu1.sh                                                
<span class="number">14565</span> root      <span class="number">20</span>   <span class="number">0</span>  <span class="number">104</span>m <span class="number">1704</span> <span class="number">1012</span> R <span class="number">10.0</span>  <span class="number">0.0</span>   <span class="number">4</span>:<span class="number">30.53</span> cpu.sh
</code></pre>
<p>如上所述，指定用户，可以指定进程进行控制，也可以指定用户的所有进程进行控制，后台的做的操作就是把进行的号移动到了指定的资源组的task当中去了</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>1、Cgroup安装</p>
<p>安装Cgroups需要libcap-devel和libcgroup两个相关的包<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">	yum install gcc libcap-devel </span><br><span class="line">```	</span><br><span class="line"><span class="number">2</span>、Cgroup挂载配置</span><br><span class="line">```raw</span><br><span class="line">	Cgroup对应服务名称为cgconfig，cgconfig默认采用“多挂载点”挂载。经过实际测试，发现在CentOS环境中应采用“单挂载点”进行挂载，因此应当卸载原有cgroup文件系统，并禁用cgconfig。</span><br><span class="line">	cgclear或者sudo service cgconfig stop <span class="comment"># 停止cgconfig，卸载cgroup目录</span></span><br><span class="line">	sudo chkconfig cgconfig off          <span class="comment"># 禁用cgconfig服务，避免其开机启动</span></span><br><span class="line">	然后采用“单挂载点”方式重新挂载cgroup。</span><br><span class="line">	可以直接手动挂载，这样仅当次挂载成功。</span><br><span class="line">	mount -t cgroup none /cgroup</span><br><span class="line">	然后编辑/etc/fstab/，输入下列内容。这样每次开机后都会自动挂载。</span><br><span class="line">	none   /cgroup  cgroup  defaults   <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="linux" scheme="http://www.zphj1987.com/tags/linux/"/>
    
  </entry>
  
</feed>
