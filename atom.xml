<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[zphj1987'Blog]]></title>
  <subtitle><![CDATA[现在所学，终有所用]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.zphj1987.com/"/>
  <updated>2015-12-11T17:48:30.321Z</updated>
  <id>http://www.zphj1987.com/</id>
  
  <author>
    <name><![CDATA[zphj1987]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[关于开始写教程的事]]></title>
    <link href="http://www.zphj1987.com/2015/12/12/%E5%85%B3%E4%BA%8E%E5%BC%80%E5%A7%8B%E5%86%99%E6%95%99%E7%A8%8B%E7%9A%84%E4%BA%8B/"/>
    <id>http://www.zphj1987.com/2015/12/12/关于开始写教程的事/</id>
    <published>2015-12-11T16:37:22.000Z</published>
    <updated>2015-12-11T17:48:30.321Z</updated>
    <content type="html"><![CDATA[<p>在加入到ceph社区的群里以后，尝试着去回答一些有关ceph的问题，发现很多问题其实自己都遇到过，而且很多问题是反复的会被人提起，对于新手来说，由于资源太多，可能就无法比较系统的去学习这个东西，网上的文档也很多，到底从哪里开始，怎么去做，遇到的问题到底是什么造成的，这些都很难一下找到解决办法</p>
<p>有一天想到了是不是自己也可以尝试着去做一下这个事情，网上也会有相关的教程，但是这个实在太少太少，一来专业的讲师可能不会非常的熟悉集群，二来非常熟悉集群的人，也不一定有精力去完成这个事情，而我也不确定能不能很好的去做这个事情，但是总算是起步了</p>
<a id="more"></a>
<p>关于教程，我想一方面需要有视频，一方面是要有很好的文档作为支撑的，最好观看视频的人，可以根据这个文档去一步一步实现视频里面所能实现的东西，作为技术来说文档一般可以很好的去完成一个配置，但是视频的效果也许会更直接，在你还没看完文档的情况下，就能清楚的知道，这个到底是不是我要的，还有一个就是在有时间情况下，我可以对所提到的问题进行反馈</p>
<p>视频的质量自己也不好评判，只是记录了自己的操作，和一些个人的理解，通过相同的操作，能够实现你所想要的，这里面举个最简单的例子，在做ceph的osd的部署的时候，格式化osd的方式就有五种之多，这个对于我自己来说，进行操作的时候，都需要验证几次才能确定这样能去部署好，然后总结下来，当然你可以选择你自己想要的一种即可</p>
<p>前期可能出的都是比较基础的操作，在一定的时候会去尝试讲解一些国外大牛做的ppt，在一些峰会上，总会有一些比较好的经验总结，这些都是值得学习的，有的时候也能提供一些不一样的思路</p>
<p>关于视频，这个我想了下，还是准备收费的，关于收费的问题，这想提出我自己的一个想法，我会在博客中提到我的视频会讲到哪些东西，如果值得看，你就可以通过支付宝的方式进行购买，并告诉我您需要哪个资源，如果你想先看再考虑是不是要付钱，这个也是可以的，如果你付了钱看完了视频，觉得这个视频也就这样，看的东西我都知道，那么你也可以告诉我，我会从支付宝上原路退回的，所以就算这样的：</p>
<p>视频的获取是会收费的，都是10块钱就可以获取，如果你觉得这个帮助你很多，你也可以付多点，这个我不会介意的，这个完全自愿我会发资源链接给你<br>可以先获取资源，再考虑要不要付费<br>也可以付费了后，不满意退费<br>所以，我想这个对于大多数人应该是个可以接受的方式，10块钱不多，当然得由您来判断它的价值了，如果有我的视频没有提到的，而您又比较关心的问题，我也可以尝试做一个新的专题</p>
<p>最后一点，这个视频是不涉及版权的，你可以随便使用，但是如果你想分享给其他朋友的时候，我希望您能让他来我的博客购买，对于购买视频的朋友，我在有空的时候去回答您关于视频当中的问题的，当然我也有我自己的工作，这些可能只能在空余时间进行了</p>
<p>最后希望大家都能成为朋友，毕竟都是这一行的，在不涉及到各自公司的机密技术的情况下，共同进步应该是对整个生态圈是有好处的，好了就写到这里了，欢迎大家多多支持，多多提出宝贵的意见，共同进步</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在加入到ceph社区的群里以后，尝试着去回答一些有关ceph的问题，发现很多问题其实自己都遇到过，而且很多问题是反复的会被人提起，对于新手来说，由于资源太多，可能就无法比较系统的去学习这个东西，网上的文档也很多，到底从哪里开始，怎么去做，遇到的问题到底是什么造成的，这些都很难一下找到解决办法</p>
<p>有一天想到了是不是自己也可以尝试着去做一下这个事情，网上也会有相关的教程，但是这个实在太少太少，一来专业的讲师可能不会非常的熟悉集群，二来非常熟悉集群的人，也不一定有精力去完成这个事情，而我也不确定能不能很好的去做这个事情，但是总算是起步了</p>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ceph集群的安装和配置教程]]></title>
    <link href="http://www.zphj1987.com/2015/12/12/ceph%E9%9B%86%E7%BE%A4%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"/>
    <id>http://www.zphj1987.com/2015/12/12/ceph集群的安装和配置教程/</id>
    <published>2015-12-11T16:36:48.000Z</published>
    <updated>2015-12-11T17:51:41.040Z</updated>
    <content type="html"><![CDATA[<h3 id="本篇主题：">本篇主题：</h3><p>1、怎样配置ssh免登陆访问<br>2、为什么搭建集群要关闭防火墙和selinux，如何关闭<br>3、从哪里获取ceph的安装包，怎样安装才是快速正确的<br>4、为什么要配置时间同步服务，怎样配置<br>5、怎样创建集群<br>6、怎样使用不同的方式增加osd（这里我总结了五种）</p>
<ul>
<li>默认方式</li>
<li>磁盘journal</li>
<li>目录配置方式</li>
<li>btrfs文件系统</li>
<li>disk+ssd方式</li>
</ul>
<p>7、怎样配置文件系统<br>8、怎样配置块设备系统<br>9、怎样配置S3服务<br>10、如何干净的将集群清理到初始状态</p>
<blockquote>
<p>（本篇基于centos7,其他系统除了安装方式其他通用）</p>
</blockquote>
<h3 id="本篇资源:">本篇资源:</h3><p>包括了视频，操作文档，相关安装包资源，S3的windows客户端</p>
<a id="more"></a>
<h3 id="付费方式：支付宝">付费方式：支付宝</h3><p>10块钱就可以获取，如果你觉得这个帮助你很多，你也可以付多点<br>可以先获取资源，再考虑要不要付费<br>可以付费了后，不满意退费<br>支付码如下：</p>
<p><img src="http://7xo9we.com1.z0.glb.clouddn.com/zhifubao.png" alt=""></p>
<h3 id="资源获取方式：">资源获取方式：</h3><pre><code>qq：199383004
</code></pre><p>资源为百度云链接 </p>
<p>这个视频是不涉及版权的，你可以随便使用，如果你想分享给其他朋友的时候，希望您能让他来我的博客购买，对于购买视频的朋友，我在有空的时候去回答您关于视频当中的问题的,在得到您的认可的情况下希望您能推荐更多的人来购买</p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="本篇主题：">本篇主题：</h3><p>1、怎样配置ssh免登陆访问<br>2、为什么搭建集群要关闭防火墙和selinux，如何关闭<br>3、从哪里获取ceph的安装包，怎样安装才是快速正确的<br>4、为什么要配置时间同步服务，怎样配置<br>5、怎样创建集群<br>6、怎样使用不同的方式增加osd（这里我总结了五种）</p>
<ul>
<li>默认方式</li>
<li>磁盘journal</li>
<li>目录配置方式</li>
<li>btrfs文件系统</li>
<li>disk+ssd方式</li>
</ul>
<p>7、怎样配置文件系统<br>8、怎样配置块设备系统<br>9、怎样配置S3服务<br>10、如何干净的将集群清理到初始状态</p>
<blockquote>
<p>（本篇基于centos7,其他系统除了安装方式其他通用）</p>
</blockquote>
<h3 id="本篇资源:">本篇资源:</h3><p>包括了视频，操作文档，相关安装包资源，S3的windows客户端</p>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在线调整ceph的参数]]></title>
    <link href="http://www.zphj1987.com/2015/11/18/%E5%9C%A8%E7%BA%BF%E8%B0%83%E6%95%B4ceph%E7%9A%84%E5%8F%82%E6%95%B0/"/>
    <id>http://www.zphj1987.com/2015/11/18/在线调整ceph的参数/</id>
    <published>2015-11-18T15:11:44.000Z</published>
    <updated>2015-11-18T15:13:22.757Z</updated>
    <content type="html"><![CDATA[<p>能够动态的进行系统参数的调整是一个很重要并且有用的属性<br>ceph的集群提供两种方式的调整，使用tell的方式和daemon设置的方式</p>
<h3 id="一、tell方式设置">一、tell方式设置</h3><p>调整配置使用命令：</p>
<h4 id="调整mon的参数">调整mon的参数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ceph tell mon.* injectargs '--&#123;tunable value_to_be_set&#125;'</span></span><br></pre></td></tr></table></figure>
<h4 id="调整osd的参数">调整osd的参数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ceph tell osd.* injectargs '--&#123;tunable value_to_be_set&#125;'</span></span><br></pre></td></tr></table></figure>
<h3 id="调整mds的参数">调整mds的参数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ceph tell mds.* injectargs '--&#123;tunable value_to_be_set&#125;'</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>例子：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab5134 ~]<span class="comment"># ceph tell mon.* injectargs '--mon_osd_report_timeout 400'</span></span><br><span class="line">injectargs:mon_osd_report_timeout = <span class="string">'400'</span></span><br></pre></td></tr></table></figure></p>
<p>除了上面的tell的方式调整，还可以使用daemon的方式进行设置</p>
<h3 id="二、daemon方式设置">二、daemon方式设置</h3><h4 id="1、获取当前的参数">1、获取当前的参数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab5134 ~]<span class="comment"># ceph daemon osd.1 config get mon_osd_full_ratio</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"mon_osd_full_ratio"</span>: <span class="string">"0.98"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2、修改配置">2、修改配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab5134 ~]<span class="comment"># ceph daemon osd.1 config set mon_osd_full_ratio 0.97</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"success"</span>: <span class="string">"mon_osd_full_ratio = '0.97' "</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、检查配置">3、检查配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab5134 ~]<span class="comment"># ceph daemon osd.1 config get mon_osd_full_ratio</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"mon_osd_full_ratio"</span>: <span class="string">"0.97"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意重启进程后配置会恢复到默认参数，在进行在线调整后，如果这个参数是后续是需要使用的，那么就需要将相关的参数写入到配置文件ceph.conf当中</p>
<h3 id="两种设置的使用场景">两种设置的使用场景</h3><p>使用tell的方式适合对整个集群进行设置，使用*号进行匹配，就可以对整个集群的角色进行设置，而出现节点异常无法设置时候，只会在命令行当中进行报错，不太便于查找</p>
<p>使用daemon进行设置的方式就是一个个的去设置，这样可以比较好的反馈，这个设置是需要在设置的角色所在的主机上进行设置，daemon的方式还提供通过asok去获取到进行的其他的信息，可以使用 ceph daemon osd.1 help去查询相关的可以使用的命令</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>能够动态的进行系统参数的调整是一个很重要并且有用的属性<br>ceph的集群提供两种方式的调整，使用tell的方式和daemon设置的方式</p>
<h3 id="一、tell方式设置">一、tell方式设置</h3><p>调整配置使用命令：</p>
<h4 id="调整mon的参数">调整mon的参数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ceph tell mon.* injectargs '--&#123;tunable value_to_be_set&#125;'</span></span><br></pre></td></tr></table></figure>
<h4 id="调整osd的参数">调整osd的参数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ceph tell osd.* injectargs '--&#123;tunable value_to_be_set&#125;'</span></span><br></pre></td></tr></table></figure>
<h3 id="调整mds的参数">调整mds的参数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ceph tell mds.* injectargs '--&#123;tunable value_to_be_set&#125;'</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[验证rbd的缓存是否开启]]></title>
    <link href="http://www.zphj1987.com/2015/11/16/%E9%AA%8C%E8%AF%81rbd%E7%9A%84%E7%BC%93%E5%AD%98%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF/"/>
    <id>http://www.zphj1987.com/2015/11/16/验证rbd的缓存是否开启/</id>
    <published>2015-11-16T08:49:16.000Z</published>
    <updated>2015-11-16T08:50:05.286Z</updated>
    <content type="html"><![CDATA[<p>简单快速的在客户端验证rbd的cache是否开启<br>首先修改配置文件<br>在ceph.conf中添加：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">rbd cache = <span class="literal">true</span></span><br><span class="line">rbd cache writethrough until flush = <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>开启以后，在这台机器上进行测试<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node8109 ~]<span class="comment"># rbd -p rbd bench-write zp  --io-size 4096 --io-threads 256  --io-total 102400000   --io-pattern seq</span></span><br><span class="line">bench-write  io_size <span class="number">4096</span> io_threads <span class="number">256</span> bytes <span class="number">102400000</span> pattern seq</span><br><span class="line">  SEC       OPS   OPS/SEC   BYTES/SEC</span><br><span class="line">elapsed:     <span class="number">0</span>  ops:    <span class="number">25000</span>  ops/sec: <span class="number">26830.05</span>  bytes/sec: <span class="number">109895890.09</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到io还是何况的达到了26830每秒<br><a id="more"></a><br>下面进行关闭后再测试：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node8109 ~]<span class="comment"># rbd -p rbd bench-write zp  --io-size 4096 --io-threads 256  --io-total 102400000   --io-pattern seq</span></span><br><span class="line">bench-write  io_size <span class="number">4096</span> io_threads <span class="number">256</span> bytes <span class="number">102400000</span> pattern seq</span><br><span class="line">  SEC       OPS   OPS/SEC   BYTES/SEC</span><br><span class="line">    <span class="number">1</span>       <span class="number">893</span>   <span class="number">1076.16</span>  <span class="number">4407933.78</span></span><br><span class="line">    <span class="number">2</span>      <span class="number">1344</span>    <span class="number">795.81</span>  <span class="number">3259636.35</span></span><br><span class="line">    <span class="number">3</span>      <span class="number">1794</span>    <span class="number">655.20</span>  <span class="number">2683695.60</span></span><br><span class="line">    <span class="number">4</span>      <span class="number">2198</span>    <span class="number">613.23</span>  <span class="number">2511789.77</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到大概只有600左右的IOPS</p>
<p>结论：<br>开启和关闭cache的差别还是很大的，可以通过上面简单的测试来验证rbd的cache是否开启</p>
<p>Power by  Sebastien Han’s blog</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>简单快速的在客户端验证rbd的cache是否开启<br>首先修改配置文件<br>在ceph.conf中添加：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">rbd cache = <span class="literal">true</span></span><br><span class="line">rbd cache writethrough until flush = <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>开启以后，在这台机器上进行测试<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node8109 ~]<span class="comment"># rbd -p rbd bench-write zp  --io-size 4096 --io-threads 256  --io-total 102400000   --io-pattern seq</span></span><br><span class="line">bench-write  io_size <span class="number">4096</span> io_threads <span class="number">256</span> bytes <span class="number">102400000</span> pattern seq</span><br><span class="line">  SEC       OPS   OPS/SEC   BYTES/SEC</span><br><span class="line">elapsed:     <span class="number">0</span>  ops:    <span class="number">25000</span>  ops/sec: <span class="number">26830.05</span>  bytes/sec: <span class="number">109895890.09</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到io还是何况的达到了26830每秒<br>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何删除一台OSD主机]]></title>
    <link href="http://www.zphj1987.com/2015/11/12/%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E4%B8%80%E5%8F%B0OSD%E4%B8%BB%E6%9C%BA/"/>
    <id>http://www.zphj1987.com/2015/11/12/如何删除一台OSD主机/</id>
    <published>2015-11-12T13:33:41.000Z</published>
    <updated>2015-11-12T13:35:14.130Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>在ceph的一台OSD主机出现故障的时候，数据可以通过副本的机制进行恢复，之后通过删除osd的操作也能够将故障osd从osd tree当中删除掉，但是故障的 osd 的主机仍然会留在集群当中，通过 ceph osd tree 或者打印 crush map 都可以看到这个损坏的节点主机名，所以这里讲下怎么删除掉这个无用的host</p>
</blockquote>
<p>首先集群环境为两台主机 node8109 node8110 , node8110主机出现故障需要清理掉</p>
<h4 id="先看下当前的osd_tree状态">先看下当前的osd tree状态</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node8109 webui]<span class="comment"># ceph osd tree</span></span><br><span class="line">ID WEIGHT  TYPE NAME             UP/DOWN REWEIGHT PRIMARY-AFFINITY </span><br><span class="line">-<span class="number">1</span> <span class="number">4.00000</span> root default                                            </span><br><span class="line">-<span class="number">3</span> <span class="number">4.00000</span>     rack localrack                                      </span><br><span class="line">-<span class="number">2</span> <span class="number">2.00000</span>         host node8109                                   </span><br><span class="line"> <span class="number">0</span> <span class="number">1.00000</span>             osd.<span class="number">0</span>          up  <span class="number">1.00000</span>          <span class="number">1.00000</span> </span><br><span class="line"> <span class="number">1</span> <span class="number">1.00000</span>             osd.<span class="number">1</span>          up  <span class="number">1.00000</span>          <span class="number">1.00000</span> </span><br><span class="line">-<span class="number">4</span> <span class="number">2.00000</span>         host node8110                                   </span><br><span class="line"> <span class="number">2</span> <span class="number">1.00000</span>             osd.<span class="number">2</span>        down  <span class="number">1.00000</span>          <span class="number">1.00000</span> </span><br><span class="line"> <span class="number">3</span> <span class="number">1.00000</span>             osd.<span class="number">3</span>        down  <span class="number">1.00000</span>          <span class="number">1.00000</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="查看osd的状态">查看osd的状态</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node8109 webui]<span class="comment"># ceph osd stat</span></span><br><span class="line">     osdmap e66: <span class="number">4</span> osds: <span class="number">2</span> up, <span class="number">4</span> <span class="keyword">in</span>; <span class="number">52</span> remapped pgs</span><br></pre></td></tr></table></figure>
<h4 id="首先out掉osd">首先out掉osd</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node8109 ~]<span class="comment"># ceph osd out 2</span></span><br><span class="line">marked out osd.<span class="number">2</span>. </span><br><span class="line">[root@node8109 ~]<span class="comment"># ceph osd out 3</span></span><br><span class="line">marked out osd.<span class="number">3</span>.</span><br></pre></td></tr></table></figure>
<h4 id="从crush里面删除osd">从crush里面删除osd</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node8109 ~]<span class="comment"># ceph osd crush remove osd.2</span></span><br><span class="line">removed item id <span class="number">2</span> name <span class="string">'osd.2'</span> from crush map</span><br><span class="line">[root@node8109 ~]<span class="comment"># ceph osd crush remove osd.3</span></span><br><span class="line">removed item id <span class="number">3</span> name <span class="string">'osd.3'</span> from crush map</span><br></pre></td></tr></table></figure>
<h4 id="从集群中删除OSD">从集群中删除OSD</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node8109 ~]<span class="comment"># ceph osd rm osd.3</span></span><br><span class="line">removed osd.<span class="number">3</span></span><br><span class="line">[root@node8109 ~]<span class="comment"># ceph osd rm osd.2</span></span><br><span class="line">removed osd.<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="从集群认证里面删除osd">从集群认证里面删除osd</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node8109 ~]<span class="comment"># ceph auth del osd.2</span></span><br><span class="line">updated</span><br><span class="line">[root@node8109 ~]<span class="comment"># ceph auth del osd.3</span></span><br><span class="line">updated</span><br></pre></td></tr></table></figure>
<hr>
<p>查看当前的crush map<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@node8109 ~]<span class="comment"># ceph osd tree</span></span><br><span class="line">ID WEIGHT  TYPE NAME             UP/DOWN REWEIGHT PRIMARY-AFFINITY </span><br><span class="line">-<span class="number">1</span> <span class="number">2.00000</span> root default                                            </span><br><span class="line">-<span class="number">3</span> <span class="number">2.00000</span>     rack localrack                                      </span><br><span class="line">-<span class="number">2</span> <span class="number">2.00000</span>         host node8109                                   </span><br><span class="line"> <span class="number">0</span> <span class="number">1.00000</span>             osd.<span class="number">0</span>          up  <span class="number">1.00000</span>          <span class="number">1.00000</span> </span><br><span class="line"> <span class="number">1</span> <span class="number">1.00000</span>             osd.<span class="number">1</span>          up  <span class="number">1.00000</span>          <span class="number">1.00000</span> </span><br><span class="line">-<span class="number">4</span>       <span class="number">0</span>         host node8110</span><br></pre></td></tr></table></figure></p>
<p>下面有两种方法从osd tree 删除掉node8110,为命令方式和修改crush map 方式</p>
<h3 id="方式一：命令方式">方式一：命令方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node8109 ~]<span class="comment"># ceph osd crush remove node8110</span></span><br><span class="line">removed item id -<span class="number">4</span> name <span class="string">'node8110'</span> from crush map</span><br><span class="line">[root@node8109 ~]<span class="comment"># ceph osd tree</span></span><br><span class="line">ID WEIGHT  TYPE NAME             UP/DOWN REWEIGHT PRIMARY-AFFINITY </span><br><span class="line">-<span class="number">1</span> <span class="number">2.00000</span> root default                                            </span><br><span class="line">-<span class="number">3</span> <span class="number">2.00000</span>     rack localrack                                      </span><br><span class="line">-<span class="number">2</span> <span class="number">2.00000</span>         host node8109                                   </span><br><span class="line"> <span class="number">0</span> <span class="number">1.00000</span>             osd.<span class="number">0</span>          up  <span class="number">1.00000</span>          <span class="number">1.00000</span> </span><br><span class="line"> <span class="number">1</span> <span class="number">1.00000</span>             osd.<span class="number">1</span>          up  <span class="number">1.00000</span>          <span class="number">1.00000</span></span><br></pre></td></tr></table></figure>
<h3 id="方式二：通过修改_crush_map_的方式">方式二：通过修改 crush map 的方式</h3><h4 id="导出当前的crush_map">导出当前的crush map</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node8109 ~]<span class="comment">#ceph osd getcrushmap -o crushmap.txt</span></span><br><span class="line">[root@node8109 ~]<span class="comment">#crushtool -d crushmap.txt -o crushmap-decompile</span></span><br><span class="line">[root@node8109 ~]<span class="comment"># vim crushmap-decompile</span></span><br></pre></td></tr></table></figure>
<h4 id="删除掉node8109相关的信息">删除掉node8109相关的信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node8109 ~]<span class="comment">#crushtool -c crushmap-decompile  -o crushmap-compile</span></span><br><span class="line">[root@node8109 ~]<span class="comment"># ceph osd setcrushmap -i crushmap-compile </span></span><br><span class="line"><span class="built_in">set</span> crush map</span><br><span class="line">[root@node8109 ~]<span class="comment"># ceph osd tree</span></span><br><span class="line">ID WEIGHT  TYPE NAME             UP/DOWN REWEIGHT PRIMARY-AFFINITY </span><br><span class="line">-<span class="number">1</span> <span class="number">2.00000</span> root default                                            </span><br><span class="line">-<span class="number">3</span> <span class="number">2.00000</span>     rack localrack                                      </span><br><span class="line">-<span class="number">2</span> <span class="number">2.00000</span>         host node8109                                   </span><br><span class="line"> <span class="number">0</span> <span class="number">1.00000</span>             osd.<span class="number">0</span>          up  <span class="number">1.00000</span>          <span class="number">1.00000</span> </span><br><span class="line"> <span class="number">1</span> <span class="number">1.00000</span>             osd.<span class="number">1</span>          up  <span class="number">1.00000</span>          <span class="number">1.00000</span></span><br></pre></td></tr></table></figure>
<h3 id="总结：">总结：</h3><p>从上面的两种方式可以看出，使用命令的方式更为简单直接，而修改crush map的方式需要去做修改的操作，有一定的修改错误的风险，所以在做crush map的相关操作的时候，建议是能用命令方式做的就用命令方式去做操作</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>在ceph的一台OSD主机出现故障的时候，数据可以通过副本的机制进行恢复，之后通过删除osd的操作也能够将故障osd从osd tree当中删除掉，但是故障的 osd 的主机仍然会留在集群当中，通过 ceph osd tree 或者打印 crush map 都可以看到这个损坏的节点主机名，所以这里讲下怎么删除掉这个无用的host</p>
</blockquote>
<p>首先集群环境为两台主机 node8109 node8110 , node8110主机出现故障需要清理掉</p>
<h4 id="先看下当前的osd_tree状态">先看下当前的osd tree状态</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node8109 webui]<span class="comment"># ceph osd tree</span></span><br><span class="line">ID WEIGHT  TYPE NAME             UP/DOWN REWEIGHT PRIMARY-AFFINITY </span><br><span class="line">-<span class="number">1</span> <span class="number">4.00000</span> root default                                            </span><br><span class="line">-<span class="number">3</span> <span class="number">4.00000</span>     rack localrack                                      </span><br><span class="line">-<span class="number">2</span> <span class="number">2.00000</span>         host node8109                                   </span><br><span class="line"> <span class="number">0</span> <span class="number">1.00000</span>             osd.<span class="number">0</span>          up  <span class="number">1.00000</span>          <span class="number">1.00000</span> </span><br><span class="line"> <span class="number">1</span> <span class="number">1.00000</span>             osd.<span class="number">1</span>          up  <span class="number">1.00000</span>          <span class="number">1.00000</span> </span><br><span class="line">-<span class="number">4</span> <span class="number">2.00000</span>         host node8110                                   </span><br><span class="line"> <span class="number">2</span> <span class="number">1.00000</span>             osd.<span class="number">2</span>        down  <span class="number">1.00000</span>          <span class="number">1.00000</span> </span><br><span class="line"> <span class="number">3</span> <span class="number">1.00000</span>             osd.<span class="number">3</span>        down  <span class="number">1.00000</span>          <span class="number">1.00000</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mon失效处理方法]]></title>
    <link href="http://www.zphj1987.com/2015/11/01/Mon%E5%A4%B1%E6%95%88%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/"/>
    <id>http://www.zphj1987.com/2015/11/01/Mon失效处理方法/</id>
    <published>2015-11-01T15:34:26.000Z</published>
    <updated>2015-11-01T15:38:49.630Z</updated>
    <content type="html"><![CDATA[<p>假设环境为三个mon，主机名为mon1、mon2、mon3，现在mon3上面的系统盘损坏，mon的数据完全丢失，现在需要对mon3进行恢复处理</p>
<p>1、停止所有mon进程，可以不停其他进程，需要停止内核客户端以及对外的服务，防止卡死<br>在mon1机器上执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/ceph stop mon</span><br></pre></td></tr></table></figure></p>
<p>在mon2机器上执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/ceph stop mon</span><br></pre></td></tr></table></figure></p>
<p>2、分别在mon主机上获取当前的monmap<br>在mon1机器上执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph-mon -i mon1 --extract-monmap /tmp/monmap</span><br></pre></td></tr></table></figure></p>
<p>备份原始monmap<br><a id="more"></a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /tmp/monmap /tmp/monmapbk</span><br></pre></td></tr></table></figure></p>
<p>在mon2机器上执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph-mon -i mon2 --extract-monmap /tmp/monmap</span><br></pre></td></tr></table></figure></p>
<p>备份原始monmap<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /tmp/monmap /tmp/monmapbk</span><br></pre></td></tr></table></figure></p>
<p>3、处理monmap，去掉损坏的mon3的map信息<br>在mon1机器上执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">monmaptool /tmp/monmap --rm mon3</span><br></pre></td></tr></table></figure></p>
<p>在mon2机器上执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">monmaptool /tmp/monmap --rm mon3</span><br></pre></td></tr></table></figure></p>
<p>4、导入修改后的monmap信息<br>在mon1机器上执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph-mon -i mon1 --inject-monmap /tmp/monmap</span><br></pre></td></tr></table></figure></p>
<p>在mon2机器上执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph-mon -i mon1 --inject-monmap /tmp/monmap</span><br></pre></td></tr></table></figure></p>
<p>5、启动mon进程<br>在mon1机器上执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/ceph start mon</span><br></pre></td></tr></table></figure></p>
<p>在mon2机器上执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/ceph start mon</span><br></pre></td></tr></table></figure></p>
<p>6、检查当前的mon信息，应该显示的是只有两个mon,再新加mon即可<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph <span class="operator">-s</span></span><br></pre></td></tr></table></figure></p>
<hr>
<p>写于：2015年11月1日</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>假设环境为三个mon，主机名为mon1、mon2、mon3，现在mon3上面的系统盘损坏，mon的数据完全丢失，现在需要对mon3进行恢复处理</p>
<p>1、停止所有mon进程，可以不停其他进程，需要停止内核客户端以及对外的服务，防止卡死<br>在mon1机器上执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/ceph stop mon</span><br></pre></td></tr></table></figure></p>
<p>在mon2机器上执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/ceph stop mon</span><br></pre></td></tr></table></figure></p>
<p>2、分别在mon主机上获取当前的monmap<br>在mon1机器上执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph-mon -i mon1 --extract-monmap /tmp/monmap</span><br></pre></td></tr></table></figure></p>
<p>备份原始monmap<br>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在页面中嵌入自适应视频的方法]]></title>
    <link href="http://www.zphj1987.com/2015/10/13/%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%B5%8C%E5%85%A5%E8%87%AA%E9%80%82%E5%BA%94%E8%A7%86%E9%A2%91%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://www.zphj1987.com/2015/10/13/在页面中嵌入自适应视频的方法/</id>
    <published>2015-10-13T13:50:23.000Z</published>
    <updated>2015-10-13T14:46:32.123Z</updated>
    <content type="html"><![CDATA[<p>准备在博客中嵌入视频，从视频网站获取的embed代码是指定宽度和高度的，这样在一些窗口或者移动端进行访问的时候，就可能视频溢出屏幕了，体验不好，实际上这几年响应式网站比较流行，也就是能让内容自动的适应窗口的大小</p>
<p>屏幕的宽度可以用 <code>width：100%</code> 进行设置，高度看到有个 <code>height:100%</code> 设置后height实际取的是上一层的高度的百分比，如果没设置的话，这个就为0，看到嵌入的视频就没有高度了，网上关于这个的资料很多，可以搜索下</p>
<p>关于视频的自适应看到  <a href="https://developers.google.com/web/fundamentals/media/video/size-videos-correctly?hl=zh-cn#section" title="google 自适应设置建议" target="_blank" rel="external">google 自适应设置建议</a> 这个介绍的很好<br><a id="more"></a><br>主要是这段代码:<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="class">.video-container</span> <span class="rules">&#123;</span><br><span class="line">        <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">padding-bottom</span>:<span class="value"> <span class="number">56.25%</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">padding-top</span>:<span class="value"> <span class="number">30px</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">overflow</span>:<span class="value"> hidden</span></span>;</span><br><span class="line">    <span class="rule">&#125;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="class">.video-container</span> <span class="tag">iframe</span>,</span><br><span class="line">    <span class="class">.video-container</span> <span class="tag">object</span>,</span><br><span class="line">    <span class="class">.video-container</span> <span class="tag">embed</span> <span class="rules">&#123;</span><br><span class="line">        <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">        <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">    <span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面的56.25%实际是16:9的视频的值，这个可以根据自己的视频高宽比进行设置</p>
<p>我自己的代码是这样的：<br>css的代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="class">.article-entry</span> <span class="class">.video-container</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">position</span>:<span class="value"> relative</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">padding-bottom</span>:<span class="value"> <span class="number">56.25%</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">padding-top</span>:<span class="value"> <span class="number">30px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">overflow</span>:<span class="value"> hidden</span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="class">.article-entry</span> <span class="class">.video-container</span> <span class="tag">embed</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br><span class="line"><span class="class">.article-entry</span> <span class="class">.video-container</span> <span class="tag">object</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">position</span>:<span class="value"> absolute</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">left</span>:<span class="value"> <span class="number">0</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>嵌入的页面html代码为：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;div class="video-container"&gt; &lt;object&gt;</span><br><span class="line">&lt;param name="allowFullScreen" value="true"&gt;&lt;param name="flashVars" value="id=23750026 " /&gt;&lt;param name="movie" value="http://i7.imgs.letv.com/player/swfPlayer.swf?autoplay=0" /&gt;&lt;embed   src="http://i7.imgs.letv.com/player/swfPlayer.swf?autoplay=0" flashVars="id=23750026"allowFullScreen="true" type="application/x-shockwave-flash" &gt;&lt;/embed&gt;&lt;/object&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>添加了一个class标签，去掉了网站视频分享代码里面的width和height的值<br>下面为一个视频的例子：可以调整浏览器查看效果</p>
<div class="video-container"><object><param name="allowFullScreen" value="true"><param name="flashVars" value="id=23739460 "><param name="movie" value="http://i7.imgs.letv.com/player/swfPlayer.swf?autoplay=0"><embed src="http://i7.imgs.letv.com/player/swfPlayer.swf?autoplay=0" flashvars="id=23739460" allowfullscreen="true" type="application/x-shockwave-flash"></object><br></div>

<p><em>ps：测试了很多网站的视频上传，发现还是乐视的清晰度最高，没有压缩很多，并且视频提供高清的观看 </em></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>准备在博客中嵌入视频，从视频网站获取的embed代码是指定宽度和高度的，这样在一些窗口或者移动端进行访问的时候，就可能视频溢出屏幕了，体验不好，实际上这几年响应式网站比较流行，也就是能让内容自动的适应窗口的大小</p>
<p>屏幕的宽度可以用 <code>width：100%</code> 进行设置，高度看到有个 <code>height:100%</code> 设置后height实际取的是上一层的高度的百分比，如果没设置的话，这个就为0，看到嵌入的视频就没有高度了，网上关于这个的资料很多，可以搜索下</p>
<p>关于视频的自适应看到  <a href="https://developers.google.com/web/fundamentals/media/video/size-videos-correctly?hl=zh-cn#section" title="google 自适应设置建议">google 自适应设置建议</a> 这个介绍的很好<br>]]>
    
    </summary>
    
      <category term="杂七杂八" scheme="http://www.zphj1987.com/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[inkscope管理平台试用]]></title>
    <link href="http://www.zphj1987.com/2015/10/12/inkscope%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0%E8%AF%95%E7%94%A8/"/>
    <id>http://www.zphj1987.com/2015/10/12/inkscope管理平台试用/</id>
    <published>2015-10-12T13:28:22.000Z</published>
    <updated>2015-10-13T14:46:38.365Z</updated>
    <content type="html"><![CDATA[<p>下面为inkscope的管理平台的操作记录，一直听说过这个管理平台，但一直没有真正的去配置过，花了一点时间进行了配置</p>
<p>inkscope的管理平台总结下有下面几个：</p>
<ul>
<li>使用sysprobe获取节点的操作系统监控信息</li>
<li>使用cephprobe去跟ceph集群进行交互，调用了ceph-rest-api进行集群的数据和操作交互</li>
<li>使用mongodb进行监控信息的存储</li>
</ul>
<p>总体来说架构简单，很容易配置，并且官方提供了包，是比较成熟的管理平台了，具体的可以看下面的这个视频<br><a id="more"></a></p>
<div class="video-container"> <object><br><param name="allowFullScreen" value="true"><param name="flashVars" value="id=23750026 "><param name="movie" value="http://i7.imgs.letv.com/player/swfPlayer.swf?autoplay=0"><embed src="http://i7.imgs.letv.com/player/swfPlayer.swf?autoplay=0" flashvars="id=23750026" allowfullscreen="true" type="application/x-shockwave-flash"></object><br></div>

]]></content>
    <summary type="html">
    <![CDATA[<p>下面为inkscope的管理平台的操作记录，一直听说过这个管理平台，但一直没有真正的去配置过，花了一点时间进行了配置</p>
<p>inkscope的管理平台总结下有下面几个：</p>
<ul>
<li>使用sysprobe获取节点的操作系统监控信息</li>
<li>使用cephprobe去跟ceph集群进行交互，调用了ceph-rest-api进行集群的数据和操作交互</li>
<li>使用mongodb进行监控信息的存储</li>
</ul>
<p>总体来说架构简单，很容易配置，并且官方提供了包，是比较成熟的管理平台了，具体的可以看下面的这个视频<br>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[查询osd上的pg数]]></title>
    <link href="http://www.zphj1987.com/2015/10/04/%E6%9F%A5%E8%AF%A2osd%E4%B8%8A%E7%9A%84pg%E6%95%B0/"/>
    <id>http://www.zphj1987.com/2015/10/04/查询osd上的pg数/</id>
    <published>2015-10-03T16:02:06.000Z</published>
    <updated>2015-10-08T16:13:00.758Z</updated>
    <content type="html"><![CDATA[<p>本文中的命令的第一版来源于国外的一个博客，后面的版本为我自己修改的版本</p>
<p>查询的命令如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph pg dump | awk <span class="string">'</span><br><span class="line"> /^pg_stat/ &#123; col=1; while($col!="up") &#123;col++&#125;; col++ &#125;</span><br><span class="line"> /^[0-9a-f]+\.[0-9a-f]+/ &#123; match($0,/^[0-9a-f]+/); pool=substr($0, RSTART, RLENGTH); poollist[pool]=0;</span><br><span class="line"> up=$col; i=0; RSTART=0; RLENGTH=0; delete osds; while(match(up,/[0-9]+/)&gt;0) &#123; osds[++i]=substr(up,RSTART,RLENGTH); up = substr(up, RSTART+RLENGTH) &#125;</span><br><span class="line"> for(i in osds) &#123;array[osds[i],pool]++; osdlist[osds[i]];&#125;</span><br><span class="line">&#125;</span><br><span class="line">END &#123;</span><br><span class="line"> printf("\n");</span><br><span class="line"> printf("pool :\t"); for (i in poollist) printf("%s\t",i); printf("| SUM \n");</span><br><span class="line"> for (i in poollist) printf("--------"); printf("----------------\n");</span><br><span class="line"> for (i in osdlist) &#123; printf("osd.%i\t", i); sum=0;</span><br><span class="line"> for (j in poollist) &#123; printf("%i\t", array[i,j]); sum+=array[i,j]; poollist[j]+=array[i,j] &#125;; printf("| %i\n",sum) &#125;</span><br><span class="line"> for (i in poollist) printf("--------"); printf("----------------\n");</span><br><span class="line"> printf("SUM :\t"); for (i in poollist) printf("%s\t",poollist[i]); printf("|\n");</span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>默认的输出如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pool :	<span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	| SUM </span><br><span class="line">----------------------------------------</span><br><span class="line">osd.<span class="number">4</span>	<span class="number">54</span>	<span class="number">133</span>	<span class="number">79</span>	| <span class="number">266</span></span><br><span class="line">osd.<span class="number">5</span>	<span class="number">57</span>	<span class="number">104</span>	<span class="number">88</span>	| <span class="number">249</span></span><br><span class="line">osd.<span class="number">6</span>	<span class="number">61</span>	<span class="number">132</span>	<span class="number">86</span>	| <span class="number">279</span></span><br><span class="line">osd.<span class="number">7</span>	<span class="number">54</span>	<span class="number">114</span>	<span class="number">85</span>	| <span class="number">253</span></span><br><span class="line">osd.<span class="number">8</span>	<span class="number">63</span>	<span class="number">123</span>	<span class="number">85</span>	| <span class="number">271</span></span><br><span class="line">osd.<span class="number">0</span>	<span class="number">62</span>	<span class="number">120</span>	<span class="number">87</span>	| <span class="number">269</span></span><br><span class="line">osd.<span class="number">1</span>	<span class="number">52</span>	<span class="number">126</span>	<span class="number">81</span>	| <span class="number">259</span></span><br><span class="line">osd.<span class="number">2</span>	<span class="number">52</span>	<span class="number">103</span>	<span class="number">88</span>	| <span class="number">243</span></span><br><span class="line">osd.<span class="number">3</span>	<span class="number">57</span>	<span class="number">125</span>	<span class="number">89</span>	| <span class="number">271</span></span><br><span class="line">----------------------------------------</span><br><span class="line">SUM :	<span class="number">512</span>	<span class="number">1080</span>	<span class="number">768</span>	|</span><br></pre></td></tr></table></figure></p>
<p>这个有个问题就是osd是乱序的，并且对于一个存储池来说不清楚哪个osd的pg是最多的</p>
<h3 id="重构第一版：">重构第一版：</h3><p>跟上面的相比按顺序来排列</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ceph pg dump | awk <span class="string">'</span><br><span class="line"> /^pg_stat/ &#123; col=1; while($col!="up") &#123;col++&#125;; col++ &#125;</span><br><span class="line"> /^[0-9a-f]+\.[0-9a-f]+/ &#123; match($0,/^[0-9a-f]+/); pool=substr($0, RSTART, RLENGTH); poollist[pool]=0;</span><br><span class="line"> up=$col; i=0; RSTART=0; RLENGTH=0; delete osds; while(match(up,/[0-9]+/)&gt;0) &#123; osds[++i]=substr(up,RSTART,RLENGTH); up = substr(up, RSTART+RLENGTH) &#125;</span><br><span class="line"> for(i in osds) &#123;array[osds[i],pool]++; osdlist[osds[i]];&#125;</span><br><span class="line">&#125;</span><br><span class="line">END &#123;</span><br><span class="line"> printf("\n");</span><br><span class="line"> slen=asorti(poollist,newpoollist);</span><br><span class="line"> printf("pool :\t");for (i=1;i&lt;=slen;i++) &#123;printf("%s\t", newpoollist[i])&#125;; printf("| SUM \n");</span><br><span class="line"> for (i in poollist) printf("--------"); printf("----------------\n");</span><br><span class="line"> slen1=asorti(osdlist,newosdlist)</span><br><span class="line"> delete poollist;</span><br><span class="line"> for (i=1;i&lt;=slen1;i++) &#123; printf("osd.%i\t", newosdlist[i]); sum=0; </span><br><span class="line"> for (j=1;j&lt;=slen;j++)  &#123; printf("%i\t", array[newosdlist[i],newpoollist[j]]); sum+=array[newosdlist[i],newpoollist[j]]; poollist[j]+=array[newosdlist[i],newpoollist[j]] &#125;; printf("| %i\n",sum)</span><br><span class="line">&#125; </span><br><span class="line">for (i in poollist) printf("--------"); printf("----------------\n");</span><br><span class="line">slen2=asorti(poollist,newpoollist);</span><br><span class="line"> printf("SUM :\t"); for (i=1;i&lt;=slen2;i++) printf("%s\t",poollist[newpoollist[i]]); printf("|\n");</span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure>
<p>输出结果为下面的，可以看到现在是按顺序来的，存储池是顺序的，osd编号也是顺序的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pool :	<span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	| SUM </span><br><span class="line">----------------------------------------</span><br><span class="line">osd.<span class="number">0</span>	<span class="number">62</span>	<span class="number">120</span>	<span class="number">87</span>	| <span class="number">269</span></span><br><span class="line">osd.<span class="number">1</span>	<span class="number">52</span>	<span class="number">126</span>	<span class="number">81</span>	| <span class="number">259</span></span><br><span class="line">osd.<span class="number">2</span>	<span class="number">52</span>	<span class="number">103</span>	<span class="number">88</span>	| <span class="number">243</span></span><br><span class="line">osd.<span class="number">3</span>	<span class="number">57</span>	<span class="number">125</span>	<span class="number">89</span>	| <span class="number">271</span></span><br><span class="line">osd.<span class="number">4</span>	<span class="number">54</span>	<span class="number">133</span>	<span class="number">79</span>	| <span class="number">266</span></span><br><span class="line">osd.<span class="number">5</span>	<span class="number">57</span>	<span class="number">104</span>	<span class="number">88</span>	| <span class="number">249</span></span><br><span class="line">osd.<span class="number">6</span>	<span class="number">61</span>	<span class="number">132</span>	<span class="number">86</span>	| <span class="number">279</span></span><br><span class="line">osd.<span class="number">7</span>	<span class="number">54</span>	<span class="number">114</span>	<span class="number">85</span>	| <span class="number">253</span></span><br><span class="line">osd.<span class="number">8</span>	<span class="number">63</span>	<span class="number">123</span>	<span class="number">85</span>	| <span class="number">271</span></span><br><span class="line">----------------------------------------</span><br><span class="line">SUM :	<span class="number">512</span>	<span class="number">1080</span>	<span class="number">768</span>	|</span><br></pre></td></tr></table></figure>
<h3 id="重构第三版：">重构第三版：</h3><p>包含osd pool的排序，包含osd的排序，输出平均pg数目，输出最大的osd编号，输出超过平均值的百分比</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph pg dump | awk <span class="string">'</span><br><span class="line"> /^pg_stat/ &#123; col=1; while($col!="up") &#123;col++&#125;; col++ &#125;</span><br><span class="line"> /^[0-9a-f]+\.[0-9a-f]+/ &#123; match($0,/^[0-9a-f]+/); pool=substr($0, RSTART, RLENGTH); poollist[pool]=0;</span><br><span class="line"> up=$col; i=0; RSTART=0; RLENGTH=0; delete osds; while(match(up,/[0-9]+/)&gt;0) &#123; osds[++i]=substr(up,RSTART,RLENGTH); up = substr(up, RSTART+RLENGTH) &#125;</span><br><span class="line"> for(i in osds) &#123;array[osds[i],pool]++; osdlist[osds[i]];&#125;</span><br><span class="line">&#125;</span><br><span class="line">END &#123;</span><br><span class="line"> printf("\n");</span><br><span class="line"> slen=asorti(poollist,newpoollist);</span><br><span class="line"> printf("pool :\t");for (i=1;i&lt;=slen;i++) &#123;printf("%s\t", newpoollist[i])&#125;; printf("| SUM \n");</span><br><span class="line"> for (i in poollist) printf("--------"); printf("----------------\n");</span><br><span class="line"> slen1=asorti(osdlist,newosdlist)</span><br><span class="line"> delete poollist;</span><br><span class="line"> for (i=1;i&lt;=slen1;i++) &#123; printf("osd.%i\t", newosdlist[i]); sum=0; </span><br><span class="line"> for (j=1;j&lt;=slen;j++)  &#123; printf("%i\t", array[newosdlist[i],newpoollist[j]]); sum+=array[newosdlist[i],newpoollist[j]]; poollist[j]+=array[newosdlist[i],newpoollist[j]];if(array[newosdlist[i],newpoollist[j]] != 0)&#123;poolhasid[j]+=1 &#125;;if(array[newosdlist[i],newpoollist[j]]&gt;maxpoolosd[j])&#123;maxpoolosd[j]=array[newosdlist[i],newpoollist[j]];maxosdid[j]=newosdlist[i]&#125;&#125;; printf("| %i\n",sum)&#125; </span><br><span class="line">for (i in poollist) printf("--------"); printf("----------------\n");</span><br><span class="line">slen2=asorti(poollist,newpoollist);</span><br><span class="line"> printf("SUM :\t"); for (i=1;i&lt;=slen2;i++) printf("%s\t",poollist[newpoollist[i]]); printf("|\n");</span><br><span class="line"> printf("AVE :\t"); for (i=1;i&lt;=slen2;i++) printf("%d\t",poollist[newpoollist[i]]/poolhasid[i]); printf("|\n");</span><br><span class="line"> printf("max :\t"); for (i=1;i&lt;=slen2;i++) printf("%s\t",maxpoolosd[i]); printf("|\n");</span><br><span class="line"> printf("osdid :\t"); for (i=1;i&lt;=slen2;i++) printf("osd.%s\t",maxosdid[i]); printf("|\n");</span><br><span class="line"> printf("per:\t"); for (i=1;i&lt;=slen2;i++) printf("%.1f%\t",100*(maxpoolosd[i]-poollist[newpoollist[i]]/poolhasid[i])/(poollist[newpoollist[i]]/poolhasid[i])); printf("|\n");</span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure>
<p>输出如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pool :	<span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	| SUM </span><br><span class="line">----------------------------------------</span><br><span class="line">osd.<span class="number">0</span>	<span class="number">62</span>	<span class="number">120</span>	<span class="number">87</span>	| <span class="number">269</span></span><br><span class="line">osd.<span class="number">1</span>	<span class="number">52</span>	<span class="number">126</span>	<span class="number">81</span>	| <span class="number">259</span></span><br><span class="line">osd.<span class="number">2</span>	<span class="number">52</span>	<span class="number">103</span>	<span class="number">88</span>	| <span class="number">243</span></span><br><span class="line">osd.<span class="number">3</span>	<span class="number">57</span>	<span class="number">125</span>	<span class="number">89</span>	| <span class="number">271</span></span><br><span class="line">osd.<span class="number">4</span>	<span class="number">54</span>	<span class="number">133</span>	<span class="number">79</span>	| <span class="number">266</span></span><br><span class="line">osd.<span class="number">5</span>	<span class="number">57</span>	<span class="number">104</span>	<span class="number">88</span>	| <span class="number">249</span></span><br><span class="line">osd.<span class="number">6</span>	<span class="number">61</span>	<span class="number">132</span>	<span class="number">86</span>	| <span class="number">279</span></span><br><span class="line">osd.<span class="number">7</span>	<span class="number">54</span>	<span class="number">114</span>	<span class="number">85</span>	| <span class="number">253</span></span><br><span class="line">osd.<span class="number">8</span>	<span class="number">63</span>	<span class="number">123</span>	<span class="number">85</span>	| <span class="number">271</span></span><br><span class="line">----------------------------------------</span><br><span class="line">SUM :	<span class="number">512</span>	<span class="number">1080</span>	<span class="number">768</span>	|</span><br><span class="line">AVE :	<span class="number">56</span>	<span class="number">120</span>	<span class="number">85</span>	|</span><br><span class="line">max :	<span class="number">63</span>	<span class="number">133</span>	<span class="number">89</span>	|</span><br><span class="line">osdid :	osd.<span class="number">8</span>	osd.<span class="number">4</span>	osd.<span class="number">3</span>	|</span><br><span class="line">per:	<span class="number">10.7</span>%	<span class="number">10.8</span>%	<span class="number">4.3</span>%	|</span><br></pre></td></tr></table></figure></p>
<hr>
<p>上面的处理使用的是awk处理，开始的时候看不懂什么意思，然后就去看了这本书 <code>The AWK Programming Language</code> ,网上说这个是awk的圣经，这本书在京东卖1000RMB+,可见这本书的价值，下载地址为： <a href="http://pan.baidu.com/s/1gdwbF71" target="_blank" rel="external">http://pan.baidu.com/s/1gdwbF71</a>，关于原始脚本的意思在这里做一个简单的语法的解释，以及作者脚本的逻辑。</p>
<hr>
<h3 id="语法的解释">语法的解释</h3><blockquote>
<p>/^pg_stat/ { col=1; while($col!=”up”) {col++}; col++ }</p>
</blockquote>
<p>这个是匹配pg dump 的输出结果里面pg_stat那个字段，开始计数为1，不是up值就将col的值加1，这个匹配到的就是我们经常看到的[1,10]这个值最后的col++是将col值+1,因为字段里面有up,up_primary,我们需要的是up_primary</p>
<blockquote>
<p>/^[0-9a-f]+.[0-9a-f]+/ { match($0,/^[0-9a-f]+/); pool=substr($0, RSTART, RLENGTH); poollist[pool]=0;</p>
</blockquote>
<p>这个是匹配前面的 1.17a pg号 ，使用自带的match函数 做字符串的过滤统计匹配.号前面的存储池ID， 并得到 RSTART, RLENGTH 值，这个是取到前面的存储池ID，使用substr 函数，就可以得到pool的值了，poollist[pool]=0，是将数组的值置为0</p>
<blockquote>
<p>up=$col; i=0; RSTART=0; RLENGTH=0; delete osds; while(match(up,/[0-9]+/)&gt;0) { osds[++i]=substr(up,RSTART,RLENGTH); up = substr(up, RSTART+RLENGTH) }</p>
</blockquote>
<p>先将变量置0，然后将osd编号一个个输入到osds[i]的数组当中去</p>
<blockquote>
<p>for(i in osds) {array[osds[i],pool]++; osdlist[osds[i]];}</p>
</blockquote>
<p>将osds数组中的值输入到数组当中去，并且记录成osdlist，和数组array[osd[i],pool]</p>
<blockquote>
<p>printf(“\n”);<br> printf(“pool :\t”); for (i in poollist) printf(“%s\t”,i); printf(“| SUM \n”);</p>
</blockquote>
<p>打印osd pool的编号</p>
<blockquote>
<p>for (i in poollist) printf(“————“); printf(“————————\n”);</p>
</blockquote>
<p>根据osd pool的长度打印——</p>
<blockquote>
<p>for (i in osdlist) { printf(“osd.%i\t”, i); sum=0;</p>
</blockquote>
<p>打印osd的编号</p>
<blockquote>
<p>for (j in poollist) { printf(“%i\t”, array[i,j]); sum+=array[i,j]; poollist[j]+=array[i,j] }; printf(“| %i\n”,sum) }<br>打印对应的osd的pg数目，并做求和的统计</p>
<p>for (i in poollist) printf(“————“); printf(“————————\n”);<br> printf(“SUM :\t”); for (i in poollist) printf(“%s\t”,poollist[i]); printf(“|\n”);</p>
</blockquote>
<p>打印新的poollist里面的求和的值</p>
<p>修改版本里面用到的函数</p>
<blockquote>
<p>slen1=asorti(osdlist,newosdlist)</p>
</blockquote>
<p>这个是将数组里面的下标进行排序，这里是对osd和poollist的编号进行排序 slen1是拿到数组的长度，使用for进行遍历输出</p>
<hr>
<h3 id="脚本的逻辑">脚本的逻辑</h3><ul>
<li>匹配到pg的id和pg对应的osd，</li>
<li>使用数组的方式，将统计到的osd id存储起来，</li>
<li>然后打印数组</li>
</ul>
<hr>
<p>其他资源：<br>pg设置的计算器：<br><a href="http://ceph.com/pgcalc/" target="_blank" rel="external">http://ceph.com/pgcalc/</a><br>pg的查询和设置：<br><a href="http://ceph.com/docs/master/rados/operations/placement-groups/" target="_blank" rel="external">http://ceph.com/docs/master/rados/operations/placement-groups/</a></p>
<hr>
<p>引用博客地址如下：</p>
<p><a href="http://cephnotes.ksperis.com/blog/2015/02/23/get-the-number-of-placement-groups-per-osd/" target="_blank" rel="external">http://cephnotes.ksperis.com/blog/2015/02/23/get-the-number-of-placement-groups-per-osd/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文中的命令的第一版来源于国外的一个博客，后面的版本为我自己修改的版本</p>
<p>查询的命令如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph pg dump | awk <span class="string">'</span><br><span class="line"> /^pg_stat/ &#123; col=1; while($col!="up") &#123;col++&#125;; col++ &#125;</span><br><span class="line"> /^[0-9a-f]+\.[0-9a-f]+/ &#123; match($0,/^[0-9a-f]+/); pool=substr($0, RSTART, RLENGTH); poollist[pool]=0;</span><br><span class="line"> up=$col; i=0; RSTART=0; RLENGTH=0; delete osds; while(match(up,/[0-9]+/)&gt;0) &#123; osds[++i]=substr(up,RSTART,RLENGTH); up = substr(up, RSTART+RLENGTH) &#125;</span><br><span class="line"> for(i in osds) &#123;array[osds[i],pool]++; osdlist[osds[i]];&#125;</span><br><span class="line">&#125;</span><br><span class="line">END &#123;</span><br><span class="line"> printf("\n");</span><br><span class="line"> printf("pool :\t"); for (i in poollist) printf("%s\t",i); printf("| SUM \n");</span><br><span class="line"> for (i in poollist) printf("--------"); printf("----------------\n");</span><br><span class="line"> for (i in osdlist) &#123; printf("osd.%i\t", i); sum=0;</span><br><span class="line"> for (j in poollist) &#123; printf("%i\t", array[i,j]); sum+=array[i,j]; poollist[j]+=array[i,j] &#125;; printf("| %i\n",sum) &#125;</span><br><span class="line"> for (i in poollist) printf("--------"); printf("----------------\n");</span><br><span class="line"> printf("SUM :\t"); for (i in poollist) printf("%s\t",poollist[i]); printf("|\n");</span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[rbd的数据在哪里]]></title>
    <link href="http://www.zphj1987.com/2015/09/28/rbd%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%93%AA%E9%87%8C/"/>
    <id>http://www.zphj1987.com/2015/09/28/rbd的数据在哪里/</id>
    <published>2015-09-28T08:06:29.000Z</published>
    <updated>2015-09-28T08:21:56.250Z</updated>
    <content type="html"><![CDATA[<h3 id="创建一个rbd">创建一个rbd</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># rbd create test1 --size 4000</span></span><br></pre></td></tr></table></figure>
<h3 id="查看rbd信息">查看rbd信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># rbd info test1</span></span><br><span class="line">rbd image <span class="string">'test1'</span>:</span><br><span class="line">	size <span class="number">4000</span> MB <span class="keyword">in</span> <span class="number">1000</span> objects</span><br><span class="line">	order <span class="number">22</span> (<span class="number">4096</span> kB objects)</span><br><span class="line">	block_name_prefix: rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567</span><br><span class="line">	format: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以看出是没写入真实数据的<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># ceph df|grep rbd</span></span><br><span class="line">    rbd          <span class="number">0</span>       <span class="number">133</span>         <span class="number">0</span>        <span class="number">30627</span>M           <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h3 id="查询rbd池里面的对象信息">查询rbd池里面的对象信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># rados ls -p rbd</span></span><br><span class="line"><span class="built_in">test</span>1.rbd</span><br><span class="line">rbd_directory</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>查看下这两个对象的内容<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment">#rados -p rbd get test1.rbd test1rbd.txt</span></span><br><span class="line">[root@mytest ~]<span class="comment"># echo -e `cat test1rbd.txt`</span></span><br><span class="line">&lt;&lt;&lt; Rados Block Device Image &gt;&gt;&gt; rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567RBD001.<span class="number">005</span></span><br></pre></td></tr></table></figure></p>
<p>这个是记录的rbd镜像的信息<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># rados -p rbd get rbd_directory rbddirectory.txt</span></span><br><span class="line">[root@mytest ~]<span class="comment"># echo -e `cat rbddirectory.txt`</span></span><br><span class="line"><span class="built_in">test</span>1</span><br></pre></td></tr></table></figure></p>
<p>这个是记录的rbd的目录信息</p>
<h3 id="rbd映射到本地">rbd映射到本地</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># rbd map test1</span></span><br><span class="line">/dev/rbd0</span><br></pre></td></tr></table></figure>
<h3 id="格式化rbd设备">格式化rbd设备</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># mkfs.xfs /dev/rbd/rbd/test1 </span></span><br><span class="line"><span class="built_in">log</span> stripe unit (<span class="number">4194304</span> bytes) is too large (maximum is <span class="number">256</span>KiB)</span><br><span class="line"><span class="built_in">log</span> stripe unit adjusted to <span class="number">32</span>KiB</span><br><span class="line">meta-data=/dev/rbd/rbd/<span class="built_in">test</span>1     isize=<span class="number">256</span>    agcount=<span class="number">9</span>, agsize=<span class="number">126976</span> blks</span><br><span class="line">         =                       sectsz=<span class="number">512</span>   attr=<span class="number">2</span>, projid32bit=<span class="number">1</span></span><br><span class="line">         =                       crc=<span class="number">0</span>        finobt=<span class="number">0</span></span><br><span class="line">data     =                       bsize=<span class="number">4096</span>   blocks=<span class="number">1024000</span>, imaxpct=<span class="number">25</span></span><br><span class="line">         =                       sunit=<span class="number">1024</span>   swidth=<span class="number">1024</span> blks</span><br><span class="line">naming   =version <span class="number">2</span>              bsize=<span class="number">4096</span>   ascii-ci=<span class="number">0</span> ftype=<span class="number">0</span></span><br><span class="line"><span class="built_in">log</span>      =internal <span class="built_in">log</span>           bsize=<span class="number">4096</span>   blocks=<span class="number">2560</span>, version=<span class="number">2</span></span><br><span class="line">         =                       sectsz=<span class="number">512</span>   sunit=<span class="number">8</span> blks, lazy-count=<span class="number">1</span></span><br><span class="line">realtime =none                   extsz=<span class="number">4096</span>   blocks=<span class="number">0</span>, rtextents=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="查看当前的rbd池里面的对象信息">查看当前的rbd池里面的对象信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest mnt]<span class="comment"># rados -p rbd ls</span></span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">0000000001</span>f0</span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">0000000001</span>f1</span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">000000000174</span></span><br><span class="line"><span class="built_in">test</span>1.rbd</span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">0000000002</span>e8</span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">0000000001</span>f2</span><br><span class="line">rbd_directory</span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">0000000000</span>f8</span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">0000000003</span>e0</span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">000000000000</span></span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">00000000007</span>c</span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">0000000003</span>e7</span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">00000000026</span>c</span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">000000000001</span></span><br><span class="line">rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">000000000364</span></span><br></pre></td></tr></table></figure>
<p>可以看到格式化过程中写入了一些对象信息，这些应该是存储文件系统信息的，写入的对象，数据的写入的前缀是rb.0.fa6c.6b8b4567</p>
<h3 id="查看对象数据在哪里">查看对象数据在哪里</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest <span class="number">0.1</span>_head]<span class="comment"># ceph osd map rbd rb.0.fa6c.6b8b4567.0000000001f0</span></span><br><span class="line">osdmap e78 pool <span class="string">'rbd'</span> (<span class="number">0</span>) object <span class="string">'rb.0.fa6c.6b8b4567.0000000001f0'</span> -&gt; pg <span class="number">0.1</span>cdfe181 (<span class="number">0.1</span>) -&gt; up ([<span class="number">1</span>], p1) acting ([<span class="number">1</span>], p1)</span><br></pre></td></tr></table></figure>
<p>可以查看到数据是在节点1的pg 0.1 里面</p>
<h3 id="去节点一上查看">去节点一上查看</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest <span class="number">0.1</span>_head]<span class="comment"># ll  /var/lib/ceph/osd/ceph-1/current/0.1_head/</span></span><br><span class="line">total <span class="number">4100</span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root       <span class="number">0</span> Aug <span class="number">10</span> <span class="number">14</span>:<span class="number">02</span> __head_00000001__0</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">4194304</span> Aug <span class="number">23</span> <span class="number">12</span>:<span class="number">36</span> rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567.<span class="number">0000000001</span>f0__head_1CDFE181__0</span><br></pre></td></tr></table></figure>
<p>可以看到这个对象</p>
<p>上面的步骤实现的是: </p>
<ul>
<li>查看一个rbd image</li>
<li>查看这个image 里面的包含的对象    </li>
<li>查看这个 rbd image的对象在哪个具体的磁盘上</li>
</ul>
<p>无法实现的是查询文件系统之上的某个文件在哪里，这个在cephfs 文件系统接口中是有的</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="创建一个rbd">创建一个rbd</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># rbd create test1 --size 4000</span></span><br></pre></td></tr></table></figure>
<h3 id="查看rbd信息">查看rbd信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># rbd info test1</span></span><br><span class="line">rbd image <span class="string">'test1'</span>:</span><br><span class="line">	size <span class="number">4000</span> MB <span class="keyword">in</span> <span class="number">1000</span> objects</span><br><span class="line">	order <span class="number">22</span> (<span class="number">4096</span> kB objects)</span><br><span class="line">	block_name_prefix: rb.<span class="number">0</span>.fa6c.<span class="number">6</span>b8b4567</span><br><span class="line">	format: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以看出是没写入真实数据的<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># ceph df|grep rbd</span></span><br><span class="line">    rbd          <span class="number">0</span>       <span class="number">133</span>         <span class="number">0</span>        <span class="number">30627</span>M           <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h3 id="查询rbd池里面的对象信息">查询rbd池里面的对象信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># rados ls -p rbd</span></span><br><span class="line"><span class="built_in">test</span>1.rbd</span><br><span class="line">rbd_directory</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[批量下载instagram图片]]></title>
    <link href="http://www.zphj1987.com/2015/09/28/%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BDinstagram%E5%9B%BE%E7%89%87/"/>
    <id>http://www.zphj1987.com/2015/09/28/批量下载instagram图片/</id>
    <published>2015-09-28T05:54:09.000Z</published>
    <updated>2015-09-28T06:09:12.916Z</updated>
    <content type="html"><![CDATA[<h3 id="下载图片：">下载图片：</h3><p>通过下面的网址可以批量下载图片，需要翻墙</p>
<p><a href="http://instrport.me/" target="_blank" rel="external">http://instrport.me/</a></p>
<h3 id="处理图片到blog可用">处理图片到blog可用</h3><p>使用脚本运行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="shebang">#! /bin/sh</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `ls ./ins`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">year=`<span class="built_in">echo</span> <span class="variable">$file</span>|cut <span class="operator">-f</span> <span class="number">1</span> <span class="operator">-d</span> -`</span><br><span class="line">mouth=`<span class="built_in">echo</span> <span class="variable">$file</span>|cut <span class="operator">-f</span> <span class="number">2</span> <span class="operator">-d</span> -`</span><br><span class="line">	</span><br><span class="line"><span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">"&#123;\"src\":\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/<span class="variable">$file</span>\",\"text\":\"\",\"y\":<span class="variable">$year</span>,\"m\":<span class="variable">$mouth</span>&#125;,\c"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<p>替换instagram中的相应字段即可</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="下载图片：">下载图片：</h3><p>通过下面的网址可以批量下载图片，需要翻墙</p>
<p><a href="http://instrport.me/" target="_blank" rel="external">http://instrport.me/</]]>
    </summary>
    
      <category term="instagram" scheme="http://www.zphj1987.com/tags/instagram/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[删除ceph集群mds]]></title>
    <link href="http://www.zphj1987.com/2015/09/24/%E5%88%A0%E9%99%A4ceph%E9%9B%86%E7%BE%A4mds/"/>
    <id>http://www.zphj1987.com/2015/09/24/删除ceph集群mds/</id>
    <published>2015-09-24T03:10:49.000Z</published>
    <updated>2015-09-28T08:24:14.398Z</updated>
    <content type="html"><![CDATA[<p>ceph集群新搭建以后是只有一个默认的存储池rbd的池</p>
<h2 id="创建文件接口集群">创建文件接口集群</h2><h3 id="1-创建一个元数据池">1.创建一个元数据池</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># ceph osd pool create metadata  20 20</span></span><br><span class="line">pool <span class="string">'metadata'</span> created</span><br></pre></td></tr></table></figure>
<h3 id="2-创建一个数据池">2.创建一个数据池</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># ceph osd pool create data   20 20</span></span><br><span class="line">pool <span class="string">'data'</span> created</span><br></pre></td></tr></table></figure>
<h3 id="3-创建一个文件系统">3.创建一个文件系统</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># ceph fs new ceph  metadata data</span></span><br><span class="line">new fs with metadata pool <span class="number">4</span> and data pool <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="4-创建一个mds">4.创建一个mds</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># ceph-deploy mds create mytest</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="5-部署完检查状态">5.部署完检查状态</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ceph]<span class="comment"># ceph -s</span></span><br><span class="line">    cluster <span class="number">7</span>e5469ac-ae1f-<span class="number">494</span>f-<span class="number">9913</span>-<span class="number">901</span>f60c0a76b</span><br><span class="line">     health HEALTH_OK</span><br><span class="line">     monmap e1: <span class="number">1</span> mons at &#123;mytest=<span class="number">192.168</span>.<span class="number">0.76</span>:<span class="number">6789</span>/<span class="number">0</span>&#125;</span><br><span class="line">            election epoch <span class="number">1</span>, quorum <span class="number">0</span> mytest</span><br><span class="line">     mdsmap e60: <span class="number">1</span>/<span class="number">1</span>/<span class="number">1</span> up &#123;<span class="number">0</span>=mytest=up:active&#125;</span><br><span class="line">     osdmap e70: <span class="number">2</span> osds: <span class="number">2</span> up, <span class="number">2</span> <span class="keyword">in</span></span><br><span class="line">      pgmap v252: <span class="number">104</span> pgs, <span class="number">3</span> pools, <span class="number">1962</span> bytes data, <span class="number">20</span> objects</span><br><span class="line">            <span class="number">75144</span> kB used, <span class="number">30624</span> MB / <span class="number">30697</span> MB avail</span><br><span class="line">                 <span class="number">104</span> active+clean</span><br><span class="line">  client io <span class="number">108</span> B/s wr, <span class="number">0</span> op/s</span><br></pre></td></tr></table></figure>
<h2 id="删除文件接口集群（删除mds）">删除文件接口集群（删除mds）</h2><h3 id="1-停止mds进程">1.停止mds进程</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ceph]<span class="comment"># /etc/init.d/ceph stop mds</span></span><br><span class="line">=== mds.mytest === </span><br><span class="line">Stopping Ceph mds.mytest on mytest...kill <span class="number">9638</span>...done</span><br></pre></td></tr></table></figure>
<h3 id="2-将mds状态标记为失效">2.将mds状态标记为失效</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ceph]<span class="comment"># ceph mds fail 0</span></span><br><span class="line">failed mds.<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="3-删除ceph文件系统">3.删除ceph文件系统</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ceph]<span class="comment"># ceph fs rm ceph --yes-i-really-mean-it</span></span><br></pre></td></tr></table></figure>
<h3 id="4-删除完了检查状态">4.删除完了检查状态</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ceph]<span class="comment"># ceph -s</span></span><br><span class="line">    cluster <span class="number">7</span>e5469ac-ae1f-<span class="number">494</span>f-<span class="number">9913</span>-<span class="number">901</span>f60c0a76b</span><br><span class="line">     health HEALTH_OK</span><br><span class="line">     monmap e1: <span class="number">1</span> mons at &#123;mytest=<span class="number">192.168</span>.<span class="number">0.76</span>:<span class="number">6789</span>/<span class="number">0</span>&#125;</span><br><span class="line">            election epoch <span class="number">1</span>, quorum <span class="number">0</span> mytest</span><br><span class="line">     osdmap e71: <span class="number">2</span> osds: <span class="number">2</span> up, <span class="number">2</span> <span class="keyword">in</span></span><br><span class="line">      pgmap v253: <span class="number">104</span> pgs, <span class="number">3</span> pools, <span class="number">1962</span> bytes data, <span class="number">20</span> objects</span><br><span class="line">            <span class="number">75144</span> kB used, <span class="number">30624</span> MB / <span class="number">30697</span> MB avail</span><br><span class="line">                 <span class="number">104</span> active+clean</span><br></pre></td></tr></table></figure>
<p>可以看到已经没有了mds的那一条了</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ceph集群新搭建以后是只有一个默认的存储池rbd的池</p>
<h2 id="创建文件接口集群">创建文件接口集群</h2><h3 id="1-创建一个元数据池">1.创建一个元数据池</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># ceph osd pool create metadata  20 20</span></span><br><span class="line">pool <span class="string">'metadata'</span> created</span><br></pre></td></tr></table></figure>
<h3 id="2-创建一个数据池">2.创建一个数据池</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># ceph osd pool create data   20 20</span></span><br><span class="line">pool <span class="string">'data'</span> created</span><br></pre></td></tr></table></figure>
<h3 id="3-创建一个文件系统">3.创建一个文件系统</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># ceph fs new ceph  metadata data</span></span><br><span class="line">new fs with metadata pool <span class="number">4</span> and data pool <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="4-创建一个mds">4.创建一个mds</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@mytest ~]<span class="comment"># ceph-deploy mds create mytest</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ceph客户端服务端属性匹配关系]]></title>
    <link href="http://www.zphj1987.com/2015/09/18/ceph%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%B1%9E%E6%80%A7%E5%8C%B9%E9%85%8D%E5%85%B3%E7%B3%BB/"/>
    <id>http://www.zphj1987.com/2015/09/18/ceph客户端服务端属性匹配关系/</id>
    <published>2015-09-18T03:24:08.000Z</published>
    <updated>2015-09-22T16:15:49.600Z</updated>
    <content type="html"><![CDATA[<p>ceph的server是定期会发布版本，而它的客户端是放到linux 内核当中的，一些属性的支持是依赖于内核版本的，这样就存在一些问题，一些功能后端支持，而客户端旧了；还有可能是客户端用的很新的内核，而后端比较旧不支持，所以查看了下内核中的 <code>features</code> 文件，可以看到这个对应关系，总结了下就是下面的列表</p>
<p>注意表中：</p>
<ul>
<li><strong>S</strong>=SUPPORTED_DEFAULT     代表客户端支持这个属性</li>
<li><strong>R</strong>=REQUIRED_DEFAULT      代表需要服务端支持这个属性</li>
</ul>
<p><img src="http://7xi6lo.com1.z0.glb.clouddn.com/属性匹配的问题.png" alt=""></p>
<p><code>missing 2040000</code> 意思是 <code>CEPH_FEATURE_CRUSH_TUNABLES (40000)</code> 和 <code>CEPH_FEATURE_CRUSH_TUNABLES2 (2000000)</code> 不被当前客户端支持，一般要么关闭新的server端的这个属性，或者升级到支持的版本的内核.</p>
<p>内核代码查看地址：<a href="http://lxr.free-electrons.com/source/include/linux/ceph/ceph_features.h" target="_blank" rel="external">http://lxr.free-electrons.com/source/include/linux/ceph/ceph_features.h</a></p>
<p>写于：2015年09月18日夜</p>
<p><strong>Power by zphj1987</strong></p>
<p><strong>QQ:199383004</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ceph的server是定期会发布版本，而它的客户端是放到linux 内核当中的，一些属性的支持是依赖于内核版本的，这样就存在一些问题，一些功能后端支持，而客户端旧了；还有可能是客户端用的很新的内核，而后端比较旧不支持，所以查看了下内核中的 <code>features</]]>
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nginx配置代理缓存]]></title>
    <link href="http://www.zphj1987.com/2015/07/14/nginx%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98/"/>
    <id>http://www.zphj1987.com/2015/07/14/nginx配置代理缓存/</id>
    <published>2015-07-14T01:57:21.000Z</published>
    <updated>2015-09-23T07:27:31.203Z</updated>
    <content type="html"><![CDATA[<p>nginx可以实现反向代理的配置，并且可以使用缓存来加速，本文是简单的实现功能的配置，暂时没有做其他的优化的部分的配置，从网上的资料来看，很多配置都是没有讲哪些是必须配置的，我自己在配置过程中就发现没有生成缓存文件，下面来记录下配置的内容<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">upstream test&#123;&#10;            server 127.0.0.1:8080;&#10;        &#125;&#10;&#10;proxy_cache_path /var/cache/nginx/proxy_cache keys_zone=cache_zone:2000m max_size=1000m;&#10;&#10;server &#123;&#10;    listen       80;&#10;    server_name  localhost;&#10;    location / &#123;&#10;        proxy_pass http://127.0.0.1:8080;&#10;        proxy_cache cache_zone;&#10;        proxy_cache_valid  200 304 302 24h;&#10;    &#125;&#10;&#10;    error_page   500 502 503 504  /50x.html;&#10;&#10;    location = /50x.html &#123;&#10;        root   /usr/share/nginx/html;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>以上为我的配置文件，说明：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">upstream test&#123;&#10;            server 127.0.0.1:8080;&#10;        &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个字段是配置代理的部分，这个配置没有做多机的配置，只是将本机的nginx的80端口配置到了apache的8080端口，<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">proxy_cache_path /var/cache/nginx/proxy_cache keys_zone=cache_zone:2000m max_size=1000m;</span><br></pre></td></tr></table></figure></p>
<p>这个是配置缓存的放置的路径的，这个路径最好是跟proxy_temp在一个分区上，后面是写得名称，共享内存大小，缓存的最大值<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">location / &#123;&#10;    proxy_pass http://127.0.0.1:8080;&#10;    proxy_cache cache_zone;&#10;    proxy_cache_valid  200 304 302 24h;&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个是缓存的关键配置，proxy_pass是将请求转发到你要代理的机器上，proxy_cache是指明使用的规则，上面的keys_zone，下面的proxy_cache_valid是配置允许缓存的请求，这个地方不配置就无法生成缓存的文件，</p>
<p>到这里基本的代理缓存就配置成功了，可以通过访问来检查是否生成了缓存文件，下载检查下是否web直接将请求返回了前端</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>nginx可以实现反向代理的配置，并且可以使用缓存来加速，本文是简单的实现功能的配置，暂时没有做其他的优化的部分的配置，从网上的资料来看，很多配置都是没有讲哪些是必须配置的，我自己在配置过程中就发现没有生成缓存文件，下面来记录下配置的内容<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">upstream test&#123;&#10;            server 127.0.0.1:8080;&#10;        &#125;&#10;&#10;proxy_cache_path /var/cache/nginx/proxy_cache keys_zone=cache_zone:2000m max_size=1000m;&#10;&#10;server &#123;&#10;    listen       80;&#10;    server_name  localhost;&#10;    location / &#123;&#10;        proxy_pass http://127.0.0.1:8080;&#10;        proxy_cache cache_zone;&#10;        proxy_cache_valid  200 304 302 24h;&#10;    &#125;&#10;&#10;    error_page   500 502 503 504  /50x.html;&#10;&#10;    location = /50x.html &#123;&#10;        root   /usr/share/nginx/html;&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="nginx" scheme="http://www.zphj1987.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux服务器远程网络开机（wake on lan）]]></title>
    <link href="http://www.zphj1987.com/2015/05/27/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9C%E7%A8%8B%E7%BD%91%E7%BB%9C%E5%BC%80%E6%9C%BA%EF%BC%88wake-on-lan%EF%BC%89/"/>
    <id>http://www.zphj1987.com/2015/05/27/linux服务器远程网络开机（wake-on-lan）/</id>
    <published>2015-05-27T06:35:40.000Z</published>
    <updated>2015-09-23T07:27:27.955Z</updated>
    <content type="html"><![CDATA[<h3 id="检查服务器是否支持远程网络开机">检查服务器是否支持远程网络开机</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab5101 ~]<span class="comment"># ethtool eth0</span></span><br><span class="line">    Settings <span class="keyword">for</span> eth0:</span><br><span class="line">        Supported ports: [ TP ]</span><br><span class="line">        Supported link modes: <span class="number">10</span>baseT/Half <span class="number">10</span>baseT/Full </span><br><span class="line">                              <span class="number">100</span>baseT/Half <span class="number">100</span>baseT/Full </span><br><span class="line">                              <span class="number">1000</span>baseT/Full </span><br><span class="line">        Supported pause frame use: No</span><br><span class="line">        Supports auto-negotiation: Yes</span><br><span class="line">        Advertised link modes: </span><br><span class="line">                             <span class="number">10</span>baseT/Half <span class="number">10</span>baseT/Full </span><br><span class="line">                             <span class="number">100</span>baseT/Half <span class="number">100</span>baseT/Full </span><br><span class="line">                             <span class="number">1000</span>baseT/Full </span><br><span class="line">        Advertised pause frame use: No</span><br><span class="line">        Advertised auto-negotiation: Yes</span><br><span class="line">        Speed: <span class="number">1000</span>Mb/s</span><br><span class="line">        Duplex: Full</span><br><span class="line">        Port: Twisted Pair</span><br><span class="line">        PHYAD: <span class="number">2</span></span><br><span class="line">        Transceiver: internal</span><br><span class="line">        Auto-negotiation: onMDI-X: on</span><br><span class="line">        Supports Wake-on: pumbg</span><br><span class="line">        Wake-on: g</span><br><span class="line">        Current message level: <span class="number">0</span>x00000007 (<span class="number">7</span>) </span><br><span class="line">                               drv probe linkLink detected: yes</span><br></pre></td></tr></table></figure>
<p>注意这两项：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Supports Wake-on: pumbg&#10;Wake-on: g</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>可以通过命令设置，也可以去bios中设置<br>d表示禁用，g表示开启<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab5101 ~]<span class="comment"># ethtool -s eth0 wol g</span></span><br></pre></td></tr></table></figure></p>
<p>拿到网卡的mac地址<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab5101 ~]<span class="comment"># ifconfig </span></span><br><span class="line">eth0  Link encap:Ethernet HWaddr <span class="number">00</span>:<span class="number">30</span>:<span class="number">67</span>:<span class="number">6</span>D:<span class="number">3</span>D:<span class="number">7</span>C </span><br><span class="line">     inet addr:<span class="number">192.168</span>.<span class="number">5.101</span> Bcast:<span class="number">192.168</span>.<span class="number">255.255</span> Mask:<span class="number">255.255</span>.<span class="number">0.0</span> </span><br><span class="line">     inet6 addr: fe80::<span class="number">215</span>:<span class="number">17</span>ff:fed0:be85/<span class="number">64</span> Scope:Link</span><br><span class="line">     UP BROADCAST RUNNING MULTICAST MTU:<span class="number">1500</span> Metric:<span class="number">1</span> </span><br><span class="line">     RX packets:<span class="number">17752</span> errors:<span class="number">0</span> dropped:<span class="number">4</span> overruns:<span class="number">0</span> frame:<span class="number">0</span> </span><br><span class="line">     TX packets:<span class="number">1101</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> carrier:<span class="number">0</span> </span><br><span class="line">     collisions:<span class="number">0</span> txqueuelen:<span class="number">1000</span> </span><br><span class="line">     RX bytes:<span class="number">1288183</span> (<span class="number">1.2</span> MiB) TX bytes:<span class="number">262525</span> (<span class="number">256.3</span> KiB) </span><br><span class="line">     Interrupt:<span class="number">16</span> Memory:b1100000-b1120000 </span><br><span class="line">lo   Link encap:Local Loopback inet addr:<span class="number">127.0</span>.<span class="number">0.1</span> Mask:<span class="number">255.0</span>.<span class="number">0.0</span> </span><br><span class="line">     inet6 addr: ::<span class="number">1</span>/<span class="number">128</span> Scope:Host </span><br><span class="line">     UP LOOPBACK RUNNING MTU:<span class="number">65536</span> Metric:<span class="number">1</span> </span><br><span class="line">     RX packets:<span class="number">62566</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> frame:<span class="number">0</span> </span><br><span class="line">     TX packets:<span class="number">62566</span> errors:<span class="number">0</span> dropped:<span class="number">0</span> overruns:<span class="number">0</span> carrier:<span class="number">0</span> </span><br><span class="line">     collisions:<span class="number">0</span> txqueuelen:<span class="number">0</span> </span><br><span class="line">     RX bytes:<span class="number">91540393</span> (<span class="number">87.2</span> MiB) TX bytes:<span class="number">91540393</span> (<span class="number">87.2</span> MiB)</span><br></pre></td></tr></table></figure></p>
<p>得到：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">HWaddr 00:15:17:D0:BE:85</span><br></pre></td></tr></table></figure></p>
<p>在另外一台服务器上执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab901 ~]<span class="comment"># ether-wake -i eth0 00:30:67:6d:3d:7c</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="检查服务器是否支持远程网络开机">检查服务器是否支持远程网络开机</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab5101 ~]<span class="comment"># ethtool eth0</span></span><br><span class="line">    Settings <span class="keyword">for</span> eth0:</span><br><span class="line">        Supported ports: [ TP ]</span><br><span class="line">        Supported link modes: <span class="number">10</span>baseT/Half <span class="number">10</span>baseT/Full </span><br><span class="line">                              <span class="number">100</span>baseT/Half <span class="number">100</span>baseT/Full </span><br><span class="line">                              <span class="number">1000</span>baseT/Full </span><br><span class="line">        Supported pause frame use: No</span><br><span class="line">        Supports auto-negotiation: Yes</span><br><span class="line">        Advertised link modes: </span><br><span class="line">                             <span class="number">10</span>baseT/Half <span class="number">10</span>baseT/Full </span><br><span class="line">                             <span class="number">100</span>baseT/Half <span class="number">100</span>baseT/Full </span><br><span class="line">                             <span class="number">1000</span>baseT/Full </span><br><span class="line">        Advertised pause frame use: No</span><br><span class="line">        Advertised auto-negotiation: Yes</span><br><span class="line">        Speed: <span class="number">1000</span>Mb/s</span><br><span class="line">        Duplex: Full</span><br><span class="line">        Port: Twisted Pair</span><br><span class="line">        PHYAD: <span class="number">2</span></span><br><span class="line">        Transceiver: internal</span><br><span class="line">        Auto-negotiation: onMDI-X: on</span><br><span class="line">        Supports Wake-on: pumbg</span><br><span class="line">        Wake-on: g</span><br><span class="line">        Current message level: <span class="number">0</span>x00000007 (<span class="number">7</span>) </span><br><span class="line">                               drv probe linkLink detected: yes</span><br></pre></td></tr></table></figure>
<p>注意这两项：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Supports Wake-on: pumbg&#10;Wake-on: g</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="linux" scheme="http://www.zphj1987.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[dm-crypt加密磁盘]]></title>
    <link href="http://www.zphj1987.com/2015/05/25/dm-crypt%E5%8A%A0%E5%AF%86%E7%A3%81%E7%9B%98/"/>
    <id>http://www.zphj1987.com/2015/05/25/dm-crypt加密磁盘/</id>
    <published>2015-05-25T06:07:58.000Z</published>
    <updated>2015-05-25T06:14:22.406Z</updated>
    <content type="html"><![CDATA[<h3 id="dm-cry加密方式密码与文件">dm-cry加密方式密码与文件</h3><p>与其它创建加密文件系统的方法相比，dm-crypt系统有着无可比拟的优越性：它的速度更快，易用性更强。除此之外，它的适用面也很广，能够运行在各种块设备上，即使这些设备使用了RAID和 LVM也毫无障碍。</p>
<p>如果看到类似下面的输出，说明AES模块已经加载了。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">cat /proc/crypto&#10;&#10;name         : aes&#10;driver       : aes-generic&#10;module       : kernel&#10;priority     : 100&#10;refcnt       : 3&#10;selftest     : passed&#10;type         : cipher&#10;blocksize    : 16&#10;min keysize  : 16&#10;max keysize  : 32</span><br></pre></td></tr></table></figure></p>
<p>否则可以用modprobe命令来手工加载AES模块。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modprobe aes</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>检查dmsetup软件包是否已经建立了设备映像程序，用如下命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls <span class="operator">-l</span> /dev/mapper/control</span><br></pre></td></tr></table></figure></p>
<p>检查dm-crypt内核模块是否加载<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 mnt]<span class="comment"># dmsetup targets</span></span><br><span class="line">crypt            v1.<span class="number">13.0</span></span><br><span class="line">mirror           v1.<span class="number">13.2</span></span><br><span class="line">striped          v1.<span class="number">5.1</span></span><br><span class="line">linear           v1.<span class="number">2.1</span></span><br><span class="line">error            v1.<span class="number">2.0</span></span><br></pre></td></tr></table></figure></p>
<p>这说明系统已经为加密设备做好了准备。如果没有输出，可以用如下命令来加载dm-crypt模块。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modprobe dm-crypt</span><br></pre></td></tr></table></figure></p>
<p>建立加密设备</p>
<p>这里用 fdisk命令来创建需要加密的磁盘，怎么创建磁盘这里不再冗述。假设这里创建好的磁盘分区是/dev/sdb1<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cryptsetup -y create sdb_cry /dev/sdb1</span><br></pre></td></tr></table></figure></p>
<p>sdb_cry是逻辑卷的名称。输入上面命令后，还要输入2次密码，这个密码就是磁盘加密的密码。请牢记！<br>创建好后，用下面命令检查所建立的逻辑卷：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># dmsetup ls</span></span><br><span class="line">sdb_cry	(<span class="number">252</span>:<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>device-mapper会把它的虚拟设备装载到/dev/mapper下面，所以，你的虚拟块设备应该是/dev/mapper/sdb_cry，尽管用起来和其他块设备没什么不同，实际上它却是经过透明加密的。</p>
<p>创建文件系统：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># mkfs.xfs /dev/mapper/sdb_cry -f</span></span><br></pre></td></tr></table></figure></p>
<p>装载加密磁盘：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># mount /dev/mapper/sdb_cry /mnt</span></span><br><span class="line"></span><br><span class="line">[root@node1 ~]<span class="comment"># cp /etc/networks /mnt/</span></span><br><span class="line">[root@node1 ~]<span class="comment"># cat /mnt/networks </span></span><br><span class="line">default <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line">loopback <span class="number">127.0</span>.<span class="number">0.0</span></span><br><span class="line">link-local <span class="number">169.254</span>.<span class="number">0.0</span></span><br></pre></td></tr></table></figure></p>
<p>卸载加密设备<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cryptsetup remove sdb_cry</span></span><br></pre></td></tr></table></figure></p>
<p>重新加载加密设备<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># cryptsetup create sdb_cry /dev/sdb1</span></span><br></pre></td></tr></table></figure></p>
<p>这里重新挂载会要求输入密码，密码输入不正确，设备会映射过去，但是找不到文件系统，是无法看到数据的</p>
<p>重新挂载<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/mapper/sdb_cry /mnt</span><br></pre></td></tr></table></figure></p>
<p>注意 cryptsetup -y create sdb_cry /dev/sdb1 会重新为磁盘设置新的密码，只要不对磁盘进行格式化，即使设置了新的密码，同样是看不到数据的，设置了新的密码后，只要不格式化，还是能够使用旧的密码来对磁盘进行挂载的</p>
<p>以上为采用密码加密磁盘的方式</p>
<hr>
<p>使用luks方式的加密<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cryptsetup -y -v luksFormat /dev/sdb1</span><br></pre></td></tr></table></figure></p>
<p>输入大写的YES，小写不行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cryptsetup isLuks /dev/sdb1</span><br></pre></td></tr></table></figure></p>
<p>判断设备<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cryptsetup luksOpen /dev/sdb1 sdb1_luks</span><br></pre></td></tr></table></figure></p>
<p>映射设备到/dev/mapper/下面</p>
<p>卸载<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cryptsetup remove sdb1_luks</span><br></pre></td></tr></table></figure></p>
<p>再次加载<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cryptsetup isLuks /dev/sdb1</span><br></pre></td></tr></table></figure></p>
<hr>
<p>采用文件方式的加密</p>
<p>创建加密设备，并指定的文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cryptsetup --key-file /etc/zbkc/key/UUID --key-size <span class="number">256</span> create sdb1_cry /dev/sdb1</span><br></pre></td></tr></table></figure></p>
<p>使用上面的命令后会在/dev/mapper/下生成对应设备</p>
<p>然后格式化使用设备即可</p>
<p>卸载设备<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cryptsetup remove sdb1_cry</span><br></pre></td></tr></table></figure></p>
<p>需要再次使用就<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cryptsetup --key-file /etc/zbkc/key/UUID --key-size <span class="number">256</span> create sdb1_cry /dev/sdb1</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="dm-cry加密方式密码与文件">dm-cry加密方式密码与文件</h3><p>与其它创建加密文件系统的方法相比，dm-crypt系统有着无可比拟的优越性：它的速度更快，易用性更强。除此之外，它的适用面也很广，能够运行在各种块设备上，即使这些设备使用了RAID和 LVM也毫无障碍。</p>
<p>如果看到类似下面的输出，说明AES模块已经加载了。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">cat /proc/crypto&#10;&#10;name         : aes&#10;driver       : aes-generic&#10;module       : kernel&#10;priority     : 100&#10;refcnt       : 3&#10;selftest     : passed&#10;type         : cipher&#10;blocksize    : 16&#10;min keysize  : 16&#10;max keysize  : 32</span><br></pre></td></tr></table></figure></p>
<p>否则可以用modprobe命令来手工加载AES模块。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">modprobe aes</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux系统克隆系统盘]]></title>
    <link href="http://www.zphj1987.com/2015/05/12/linux%E7%B3%BB%E7%BB%9F%E5%85%8B%E9%9A%86%E7%B3%BB%E7%BB%9F%E7%9B%98/"/>
    <id>http://www.zphj1987.com/2015/05/12/linux系统克隆系统盘/</id>
    <published>2015-05-12T06:24:31.000Z</published>
    <updated>2015-09-23T07:27:21.750Z</updated>
    <content type="html"><![CDATA[<p>本文将介绍两种方式的系统盘的完整的备份，两种方式各有优缺点，需要根据实际情况来进行选择</p>
<ul>
<li>使用dd的完整镜像克隆的方式</li>
<li>使用tar去备份数据，安装grub的方式</li>
</ul>
<h4 id="dd方式">dd方式</h4><p>优点：<br>简单，一条命令 dd if=/dev/sda of=/dev/sdb 就可以进行完整的系统备份了</p>
<p>缺点：<br>时间非常长，备份一个系统盘，无论数据多少，系统盘全部会读取一遍，时间比较久<br>备份目的盘需要大于原盘<br>分区无法调整，根原分区一模一样</p>
<h4 id="tar方式">tar方式</h4><p>优点：<br>时间短，只需要备份实际磁盘上的数据即可<br>自定义，可以修改分区的大小，可以控制备份的类容，可以定期备份<br>对目的盘大小无限制，比较灵活</p>
<p>缺点：<br>人为修改东西比较多，需要手动去修改一些信息<br>当然在掌握了一定的linux基础的情况下建议是使用tar方式的，，下面将介绍tar方式的处理方式：</p>
<a id="more"></a>
<h3 id="给准备用来备份的磁盘进行分区和格式化">给准备用来备份的磁盘进行分区和格式化</h3><p>首先使用 df -h 来检查当前的挂载的系统分区：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Filesystem      Size  Used Avail Use% Mounted on&#10;/dev/sdb5       285G  4.1G  266G   2% /&#10;tmpfs           2.0G  4.0K  2.0G   1% /dev/shm&#10;/dev/sdb1       239M   81M  141M  37% /boot&#10;/dev/sdb2       6.7G   17M  6.3G   1% /var/log</span><br></pre></td></tr></table></figure></p>
<p>查看磁盘的大小：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@zhongbo ~]# fdisk -l&#9;&#10;Disk /dev/sdb: 320.1 GB, 320072933376 bytes</span><br></pre></td></tr></table></figure></p>
<p>本例子中备用磁盘为sda,大小为240G：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@zhongbo ~]# fdisk -l /dev/sda &#10;Disk /dev/sda: 240.1 GB, 240057409536 bytes</span><br></pre></td></tr></table></figure></p>
<p>查看系统盘详细的分区信息<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@zhongbo ~]# parted -l&#10;Model: ATA WDC WD3200AAJS-2 (scsi)&#10;Disk /dev/sdb: 320GB&#10;Sector size (logical/physical): 512B/512B&#10;Partition Table: msdos&#10;&#10;Number  Start   End     Size    Type      File system     Flags&#10; 1      1049kB  263MB   262MB   primary   ext4            boot&#10; 2      263MB   7603MB  7340MB  primary   ext4&#10; 3      7603MB  9751MB  2147MB  primary   linux-swap(v1)&#10; 4      9751MB  320GB   310GB   extended&#10; 5      9752MB  320GB   310GB   logical   ext4</span><br></pre></td></tr></table></figure></p>
<p>可以看到分区表模式为msdos，分区信息为含有扩展分区，逻辑分区了，下面为新准备的盘进行分区，分区信息跟原来尽量一样，这个地方也可以根据自己的需要进行调整<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@zhongbo ~]# parted /dev/sda&#10;(parted) mklabel msdos &#10;(parted) mkpart primary 1049kB 263&#10;(parted) mkpart primary 263 7603&#10;(parted) mkpart primary 7603 9751 &#10;(parted) mkpart extended 9751 100%&#10;(parted) mkpart logical 9752 100%&#10;(parted) p                                                                &#10;Model: ATA INTEL SSDSC2BF24 (scsi)&#10;Disk /dev/sda: 240GB&#10;Sector size (logical/physical): 512B/512B&#10;Partition Table: msdos&#10;&#10;Number  Start   End     Size    Type      File system     Flags&#10; 1      1049kB  263MB   262MB   primary   ext4&#10; 2      263MB   7603MB  7340MB  primary   ext4&#10; 3      7603MB  9751MB  2147MB  primary   linux-swap(v1)&#10; 4      9751MB  240GB   230GB   extended                  lba&#10; 5      9752MB  240GB   230GB   logical   ext4</span><br></pre></td></tr></table></figure></p>
<p>格式化硬盘</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@zhongbo ~]<span class="comment"># mkfs.ext4 /dev/sda1  </span></span><br><span class="line">[root@zhongbo ~]<span class="comment"># mkfs.ext4 /dev/sda2</span></span><br><span class="line">[root@zhongbo ~]<span class="comment"># mkswap /dev/sda3 </span></span><br><span class="line">[root@zhongbo ~]<span class="comment"># mkfs.ext4 /dev/sda5</span></span><br></pre></td></tr></table></figure>
<h3 id="备份原始磁盘上的数据到备份目的盘">备份原始磁盘上的数据到备份目的盘</h3><p>在本地系统盘上创建一个备份的目录，将数据打包放到这个目录下面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@zhongbo ~]<span class="comment"># mkdir /backup</span></span><br></pre></td></tr></table></figure>
<p>按这个系统来说需要备份三个分区/ , /var/log/, /boot </p>
<p>开始备份/<br>所有的操作都进入到/目录下操作<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@zhongbo ~]<span class="comment"># cd /</span></span><br><span class="line">[root@zhongbo /]<span class="comment"># tar zcvpf /backup/gen.tar.gz -C /  --exclude=boot/* --exclude=var/log/* --exclude=backup/*  --exclude=lost+found/* --exclude=mnt/*  --exclude=dev/* --exclude=proc/* --exclude=tmp/* --exclude=sys/* .</span></span><br></pre></td></tr></table></figure></p>
<p>注意这里排除了很多不需要备份的目录</p>
<p>备份boot分区<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@zhongbo /]<span class="comment"># tar zcvpf /backup/boot.tar.gz -C /boot/ .</span></span><br></pre></td></tr></table></figure></p>
<p>备份/var/log<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@zhongbo /]<span class="comment"># tar zcvpf /backup/log.tar.gz -C /var/log/ .</span></span><br></pre></td></tr></table></figure></p>
<p>恢复/的数据<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@zhongbo /]<span class="comment"># mkdir /mnt/gen</span></span><br><span class="line">[root@zhongbo /]<span class="comment"># mount /dev/sda5 /mnt/gen/</span></span><br><span class="line">[root@zhongbo /]<span class="comment"># tar zxvpf /backup/gen.tar.gz -C /mnt/gen/</span></span><br></pre></td></tr></table></figure></p>
<p>恢复/boot的数据<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@zhongbo /]<span class="comment"># mkdir /mnt/boot</span></span><br><span class="line">[root@zhongbo /]<span class="comment"># mount /dev/sda1 /mnt/boot/</span></span><br><span class="line">[root@zhongbo /]<span class="comment"># tar zxvpf /backup/boot.tar.gz -C /mnt/boot/</span></span><br></pre></td></tr></table></figure></p>
<p>恢复/var/log<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@zhongbo /]<span class="comment"># mkdir /mnt/log</span></span><br><span class="line">[root@zhongbo /]<span class="comment"># mount /dev/sda2 /mnt/log/</span></span><br><span class="line">[root@zhongbo /]<span class="comment"># tar zxvpf /backup/log.tar.gz -C /mnt/log/</span></span><br></pre></td></tr></table></figure></p>
<h3 id="修改启动文件">修改启动文件</h3><p>拿到新的分区的blkid<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@zhongbo /]# blkid /dev/sda1&#10;/dev/sda1: UUID=&#34;a6ca4369-109c-47ed-a522-7e1752a6681b&#34; TYPE=&#34;ext4&#34; &#10;&#23545;&#24212;boot&#10;[root@zhongbo /]# blkid /dev/sda2&#10;/dev/sda2: UUID=&#34;f775f248-57d8-49a7-9334-60bc75a53685&#34; TYPE=&#34;ext4&#34; &#10;&#23545;&#24212;log&#10;&#10;[root@zhongbo /]# blkid /dev/sda5&#10;/dev/sda5: UUID=&#34;6942c7d6-486c-4d51-bb4d-a126ee0c05b1&#34; TYPE=&#34;ext4&#34;&#10;&#23545;&#24212;/&#10;&#10;[root@zhongbo /]# blkid /dev/sda3&#10;/dev/sda3: UUID=&#34;154784d8-dbe3-45c8-8fcb-cb4f5a14ae44&#34; TYPE=&#34;swap&#34; &#10;&#23545;&#24212;swap</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@zhongbo /]<span class="comment"># vim /mnt/gen/etc/fstab </span></span><br><span class="line">修改对应分区的uuid信息</span><br><span class="line"></span><br><span class="line">修改menu.list </span><br><span class="line">[root@zhongbo ~]<span class="comment"># vim /mnt/boot/grub/menu.lst</span></span><br><span class="line">修改root= 根分区的uuid，第一次做的时候，就是在这个地方忘了修改，进入系统后能够看到启动画面，但是没法启动内核，修改好了后，就可以正常的启动了</span><br></pre></td></tr></table></figure>
<h3 id="安装grub">安装grub</h3><p>查找grub分区<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">grub&#62; find /grub/grub.conf&#10;find /grub/grub.conf&#10; (hd0,0)&#10; (hd1,0)&#10;grub&#62;</span><br></pre></td></tr></table></figure></p>
<p>修改其中的新盘上的grub然后分辨新的grub在哪台机器上，我的新盘是(hd0,0)<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub&gt; root (hd0,<span class="number">0</span>) </span><br><span class="line">grub&gt; setup (hd0)    </span><br><span class="line">setup (hd0)</span><br><span class="line"> Checking <span class="keyword">if</span> <span class="string">"/boot/grub/stage1"</span> exists... no</span><br><span class="line"> Checking <span class="keyword">if</span> <span class="string">"/grub/stage1"</span> exists... yes</span><br><span class="line"> Checking <span class="keyword">if</span> <span class="string">"/grub/stage2"</span> exists... yes</span><br><span class="line"> Checking <span class="keyword">if</span> <span class="string">"/grub/e2fs_stage1_5"</span> exists... yes</span><br><span class="line"> Running <span class="string">"embed /grub/e2fs_stage1_5 (hd0)"</span>...  <span class="number">27</span> sectors are embedded.</span><br><span class="line">succeeded</span><br><span class="line"> Running <span class="string">"install /grub/stage1 (hd0) (hd0)1+27 p (hd0,0)/grub/stage2 /grub/grub.conf"</span>... succeeded</span><br><span class="line">Done.</span><br><span class="line">grub&gt; quit</span><br></pre></td></tr></table></figure></p>
<p>完成后，系统盘就完全备份了一份了，重启就可以启动一个一模一样的系统了</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文将介绍两种方式的系统盘的完整的备份，两种方式各有优缺点，需要根据实际情况来进行选择</p>
<ul>
<li>使用dd的完整镜像克隆的方式</li>
<li>使用tar去备份数据，安装grub的方式</li>
</ul>
<h4 id="dd方式">dd方式</h4><p>优点：<br>简单，一条命令 dd if=/dev/sda of=/dev/sdb 就可以进行完整的系统备份了</p>
<p>缺点：<br>时间非常长，备份一个系统盘，无论数据多少，系统盘全部会读取一遍，时间比较久<br>备份目的盘需要大于原盘<br>分区无法调整，根原分区一模一样</p>
<h4 id="tar方式">tar方式</h4><p>优点：<br>时间短，只需要备份实际磁盘上的数据即可<br>自定义，可以修改分区的大小，可以控制备份的类容，可以定期备份<br>对目的盘大小无限制，比较灵活</p>
<p>缺点：<br>人为修改东西比较多，需要手动去修改一些信息<br>当然在掌握了一定的linux基础的情况下建议是使用tar方式的，，下面将介绍tar方式的处理方式：</p>]]>
    
    </summary>
    
      <category term="操作系统" scheme="http://www.zphj1987.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux下制作软件包安装服务器]]></title>
    <link href="http://www.zphj1987.com/2015/04/28/linux%E4%B8%8B%E5%88%B6%E4%BD%9C%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%AE%89%E8%A3%85%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://www.zphj1987.com/2015/04/28/linux下制作软件包安装服务器/</id>
    <published>2015-04-28T08:43:29.000Z</published>
    <updated>2015-09-23T07:27:18.653Z</updated>
    <content type="html"><![CDATA[<p>linux下的软件包在有网络的情况下比较好安装，在ubuntu下，更新sourcelist，然后使用apt-get就可以很方便的安装包，在centos下面，更新yum列表，然后使用yum也可以进行方便的软件安装，但是在没有网络的情况下就比较难安装，可以用一个个包的安装的方式去安装，这个在少量的包的情况下比较好处理，在多的情况下就比较麻烦了，本篇文档，就是介绍了在无网的情况下，根据自己的需要制作内网的包的安装服务器</p>
<h2 id="centos系列">centos系列</h2><h3 id="使用光驱作为安装源">使用光驱作为安装源</h3><p>1、将光驱挂载到服务器的本地目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># mount /dev/cdrom /mnt</span></span><br><span class="line">mount: block device /dev/sr0 is write-protected, mounting <span class="built_in">read</span>-only</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>2、修改本地的yum源文件，将源指向光驱挂载的目录<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/yum.repos.d/myiso.repo</span><br></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10;&#28155;&#21152;&#10;[myiso]&#10;name=myiso&#10;baseurl=file:///mnt&#10;gpgcheck=0&#10;enabled=1&#10;gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</span><br></pre></td></tr></table></figure>
<p>3、更新本地的源缓存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 yum.repos.d]<span class="comment"># yum makecache</span></span><br><span class="line">Loaded plugins: security</span><br><span class="line">myiso                                 | <span class="number">3.6</span> kB     <span class="number">00</span>:<span class="number">00</span> ... </span><br><span class="line">myiso/group_gz                        |  <span class="number">17</span> kB     <span class="number">00</span>:<span class="number">00</span> ... </span><br><span class="line">myiso/filelists_db                    | <span class="number">3.4</span> MB     <span class="number">00</span>:<span class="number">00</span> ... </span><br><span class="line">myiso/primary_db                      | <span class="number">6.8</span> MB     <span class="number">00</span>:<span class="number">00</span> ... </span><br><span class="line">myiso/other_db                        | <span class="number">2.3</span> MB     <span class="number">00</span>:<span class="number">00</span> ... </span><br><span class="line">Metadata Cache Created</span><br></pre></td></tr></table></figure>
<p>做完上面的就可以使用本地的光驱的中的包使用yum安装了</p>
<h3 id="使用iso文件作为安装源">使用iso文件作为安装源</h3><p>1、将iso文件拷贝到服务器，然后挂载到服务器本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># mount -t iso9660 OracleLinux-R6-U5-Server-x86_64-dvd.\[V41362-01\].iso /mnt -o loop</span></span><br><span class="line">mount: /root/OracleLinux-R6-U5-Server-x86_64-dvd.[V41362-<span class="number">01</span>].iso is write-protected, mounting <span class="built_in">read</span>-only</span><br></pre></td></tr></table></figure>
<p>2、修改本地的yum源文件，将源指向光驱挂载的目录</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">vim /etc/yum.repos.d/myiso.repo&#10;&#28155;&#21152;&#10;[myiso]&#10;name=myiso&#10;baseurl=file:///mnt&#10;gpgcheck=0&#10;enabled=1&#10;gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</span><br></pre></td></tr></table></figure>
<p>3、更新本地的源缓存<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@node1 yum.repos.d]# yum makecache&#10;Loaded plugins: security&#10;myiso                                 | 3.6 kB     00:00 ... &#10;myiso/group_gz                        |  17 kB     00:00 ... &#10;myiso/filelists_db                    | 3.4 MB     00:00 ... &#10;myiso/primary_db                      | 6.8 MB     00:00 ... &#10;myiso/other_db                        | 2.3 MB     00:00 ... &#10;Metadata Cache Created</span><br></pre></td></tr></table></figure></p>
<p>做完上面的就可以使用本地的iso中的包使用yum安装了</p>
<h3 id="使用安装包做一个ftp的yum安装服务器">使用安装包做一个ftp的yum安装服务器</h3><p>1、安装vsftpd服务器<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh vsftpd-<span class="number">2.2</span>.<span class="number">2</span>-<span class="number">11</span>.el6_4.<span class="number">1</span>.x86_64.rpm</span><br></pre></td></tr></table></figure></p>
<p>这个包在操作iso中的包路径下面有</p>
<p>2、配置ftp服务器<br>默认的ftp目录为/var/ftp/pub/<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#21019;&#24314;&#28304;&#30446;&#24405;&#10;mkdir /var/ftp/pub/centos&#10;&#23558;iso&#25346;&#36733;&#21040;&#28304;&#30446;&#24405;&#65292;&#20063;&#21487;&#20197;&#30452;&#25509;&#23558;&#25991;&#20214;&#25335;&#36125;&#21040;&#36825;&#20010;&#30446;&#24405;&#24403;&#20013;&#21435;&#10;mount -t iso9660 OracleLinux-R6-U5-Server-x86_64-dvd.\[V41362-01\].iso /var/ftp/pub/centos/  -o loop</span><br></pre></td></tr></table></figure></p>
<p>配置完成后，镜像的下载地址就为:<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">ftp://youripaddress/pub/centos/</span><br></pre></td></tr></table></figure></p>
<p>我的为:<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">ftp://172.16.81.129/pub/centos/</span><br></pre></td></tr></table></figure></p>
<p>3、使用的机器的配置<br>修改yum源<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">vim /etc/yum.repos.d/ftpcentos.repo&#10;&#28155;&#21152;&#10;[ftpcentos]&#10;name=ftpcentos&#10;baseurl=ftp://172.16.81.129/pub/centos/&#10;enabled=1</span><br></pre></td></tr></table></figure></p>
<p>4、更新yum的缓存<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@node2 yum.repos.d]# yum makecache&#10;Loaded plugins: security&#10;ftpcentos                          | 3.7 kB     00:00     &#10;ftpcentos/filelists_db             | 3.3 MB     00:00     &#10;ftpcentos/primary_db               | 3.0 MB     00:00     &#10;ftpcentos/other_db                 | 1.3 MB     00:00     &#10;ftpcentos/group_gz                 | 203 kB     00:00     &#10;Metadata Cache Created</span><br></pre></td></tr></table></figure></p>
<h3 id="制作自己的定制源">制作自己的定制源</h3><p>1、安装制作源的工具<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">rpm -ivh deltarpm-3.5-0.5.20090913git.el6.x86_64.rpm&#10;rpm -ivh python-deltarpm-3.5-0.5.20090913git.el6.x86_64.rpm &#10;rpm -ivh createrepo-0.9.9-18.0.1.el6.noarch.rpm</span><br></pre></td></tr></table></figure></p>
<p>这三个包在默认的iso当中有</p>
<p>2、将安装包拷贝到指定的目录</p>
<p>本例子使用leveldb，snappy举例，snappy是leveldb的依赖包。<br>将<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">leveldb-1.7.0-2.el6.x86_64.rpm&#10;snappy-1.0.5-1.el6.x86_64.rpm</span><br></pre></td></tr></table></figure></p>
<p>拷贝到<br>/usr/src/myepel/目录当中去</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@node1 src]# createrepo myepel/&#10;Spawning worker 0 with 2 pkgs&#10;Workers Finished&#10;Gathering worker results&#10;&#10;Saving Primary metadata&#10;Saving file lists metadata&#10;Saving other metadata&#10;Generating sqlite DBs&#10;Sqlite DBs complete</span><br></pre></td></tr></table></figure>
<p>检查目录下面会生成repodata，存储一些元数据信息<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@node1 src]# ll myepel/&#10;total 200&#10;-rw-r--r-- 1 root root 162052 Apr 16 08:45 leveldb-1.7.0-2.el6.x86_64.rpm&#10;drwxr-xr-x 2 root root   4096 Apr 16 08:48 repodata&#10;-rw-r--r-- 1 root root  34372 Apr 16 08:45 snappy-1.0.5-1.el6.x86_64.rpm</span><br></pre></td></tr></table></figure></p>
<p>3、修改源列表</p>
<p>同样的将yum源的目录指向这个myepel/<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[myiso]&#10;name=myiso&#10;baseurl=file:///usr/src/myepel/&#10;gpgcheck=0&#10;enabled=1</span><br></pre></td></tr></table></figure></p>
<p>4、更新yum缓存<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@node1 yum.repos.d]# yum makecache&#10;[root@node1 yum.repos.d]# yum install leveldb</span><br></pre></td></tr></table></figure></p>
<p>即可安装了</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>linux下的软件包在有网络的情况下比较好安装，在ubuntu下，更新sourcelist，然后使用apt-get就可以很方便的安装包，在centos下面，更新yum列表，然后使用yum也可以进行方便的软件安装，但是在没有网络的情况下就比较难安装，可以用一个个包的安装的方式去安装，这个在少量的包的情况下比较好处理，在多的情况下就比较麻烦了，本篇文档，就是介绍了在无网的情况下，根据自己的需要制作内网的包的安装服务器</p>
<h2 id="centos系列">centos系列</h2><h3 id="使用光驱作为安装源">使用光驱作为安装源</h3><p>1、将光驱挂载到服务器的本地目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># mount /dev/cdrom /mnt</span></span><br><span class="line">mount: block device /dev/sr0 is write-protected, mounting <span class="built_in">read</span>-only</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="linux" scheme="http://www.zphj1987.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[windows下命令行设置静态IP]]></title>
    <link href="http://www.zphj1987.com/2015/04/03/windows%E4%B8%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP/"/>
    <id>http://www.zphj1987.com/2015/04/03/windows下命令行设置静态IP/</id>
    <published>2015-04-03T04:25:48.000Z</published>
    <updated>2015-09-23T07:27:15.004Z</updated>
    <content type="html"><![CDATA[<p>windows 10 预览版出现无法设置静态IP的bug，只能通过命令行进行设置，开启powershell，然后执行下列的命令即可<br>下面的“以太网 3” 为你设置的网卡的网卡名称,注意不要忘了空格</p>
<p>设置静态IP:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netsh interface ipv4 <span class="built_in">set</span> address <span class="string">"以太网 3"</span>  static <span class="number">192.168</span>.<span class="number">0.71</span> <span class="number">255.255</span>.<span class="number">0.0</span> <span class="number">192.168</span>.<span class="number">26.1</span></span><br></pre></td></tr></table></figure></p>
<p>增加静态IP:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netsh interface ipv4 <span class="built_in">set</span> dns <span class="string">"以太网 3"</span>  static <span class="number">223.5</span>.<span class="number">5.5</span></span><br></pre></td></tr></table></figure></p>
<p>增加静态IP:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netsh interface ipv4 add address <span class="string">"以太网 3"</span> <span class="number">11.12</span>.<span class="number">0.0</span> <span class="number">255.255</span>.<span class="number">0.0</span></span><br></pre></td></tr></table></figure></p>
<p>重置为dhcp:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netsh interface ipv4 <span class="built_in">set</span> address <span class="string">"以太网 3"</span>  dhcp</span><br></pre></td></tr></table></figure></p>
<p>基本设置应该够用了</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>windows 10 预览版出现无法设置静态IP的bug，只能通过命令行进行设置，开启powershell，然后执行下列的命令即可<br>下面的“以太网 3” 为你设置的网卡的网卡名称,注意不要忘了空格</p>
<p>设置静态IP:<br><figure class="hi]]>
    </summary>
    
      <category term="windows" scheme="http://www.zphj1987.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[shell脚本的自动交互]]></title>
    <link href="http://www.zphj1987.com/2015/04/02/shell%E8%84%9A%E6%9C%AC%E7%9A%84%E8%87%AA%E5%8A%A8%E4%BA%A4%E4%BA%92/"/>
    <id>http://www.zphj1987.com/2015/04/02/shell脚本的自动交互/</id>
    <published>2015-04-02T09:22:40.000Z</published>
    <updated>2015-09-23T07:27:11.524Z</updated>
    <content type="html"><![CDATA[<p>使用expect来自动应答shell的交互</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/expect&#10;spawn openssl req -new -key server.key -out server1.csr&#10;expect &#34;Country Name&#34;&#10;send &#34;\n&#34;&#10;expect &#34;State or Province Name&#34;&#10;send &#34;\n&#34;&#10;interact</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>使用expect来自动应答shell的交互</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/expect&#10;spawn opens]]>
    </summary>
    
      <category term="脚本" scheme="http://www.zphj1987.com/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
</feed>
