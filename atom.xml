<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[zphj1987'Blog]]></title>
  <subtitle><![CDATA[但行好事，莫问前程]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.zphj1987.com/"/>
  <updated>2017-07-28T06:16:57.059Z</updated>
  <id>http://www.zphj1987.com/</id>
  
  <author>
    <name><![CDATA[zphj1987]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[RBD快速删除的方法分析与改进]]></title>
    <link href="http://www.zphj1987.com/2017/07/27/RBD-fast-remove/"/>
    <id>http://www.zphj1987.com/2017/07/27/RBD-fast-remove/</id>
    <published>2017-07-27T14:20:37.000Z</published>
    <updated>2017-07-28T06:16:57.059Z</updated>
    <content type="html"><![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/deleting.gif?imageMogr2/thumbnail/!75p" alt="delete"><br></center>

<h2 id="前言">前言</h2><p>这个问题在很久以前就有一篇文章进行过讨论 <a href="http://cephnotes.ksperis.com/blog/2014/07/04/remove-big-rbd-image" target="_blank" rel="external">remove-big-rbd</a>,这个文章写的比较清楚了，并且对不同的方法做了分析，这里先把结论说下</p>
<table>
<thead>
<tr>
<th style="text-align:center">rbd类型</th>
<th style="text-align:center">rbd rm 方法</th>
<th style="text-align:center">rados -p rm方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">未填充很多</td>
<td style="text-align:center">慢</td>
<td style="text-align:center">快</td>
</tr>
<tr>
<td style="text-align:center">已填充很多</td>
<td style="text-align:center">快</td>
<td style="text-align:center">慢</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>在rbd进行删除的时候，即使内部没有对象数据，也一样需要一个个对象去发请求，即使对象不存在，这个可以开日志看到</p>
<h2 id="实验过程">实验过程</h2><h3 id="开启日志的方法">开启日志的方法</h3><p>在/etc/ceph/ceph.conf中添加<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">debug_ms=<span class="number">1</span></span><br><span class="line"><span class="built_in">log</span>_file=/var/<span class="built_in">log</span>/ceph/rados.log</span><br></pre></td></tr></table></figure></p>
<p>这个默认也会在执行命令的时候打印到前台，所以处理下比较好，最简单的办法就是做alias<br>添加下面内容到 /etc/bashrc<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> ceph=<span class="string">'ceph  --debug-ms=0'</span></span><br><span class="line"><span class="built_in">alias</span> rados=<span class="string">'rados  --debug-ms=0'</span></span><br></pre></td></tr></table></figure></p>
<p>然后命令行执行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/bashrc</span><br></pre></td></tr></table></figure></p>
<p>在做操作的时候就只会记录日志，前台不会打印调试信息了,但是这个会影响到ceph daemon的命令，这个可以用这种方式在线屏蔽即可<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph --debug_ms=<span class="number">0</span>  <span class="operator">-s</span></span><br></pre></td></tr></table></figure></p>
<p>然后执行操作后，去分析每秒钟的操作数目即可,类似下面的这个，也可以用日志系统进行分析，这里不赘述<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat  /var/<span class="built_in">log</span>/ceph/rados.log|grep delete|grep -v <span class="string">"&gt;"</span>|grep <span class="number">13</span>:<span class="number">29</span>:<span class="number">46</span>|wc <span class="operator">-l</span></span><br></pre></td></tr></table></figure></p>
<p>原始的快速删除方法<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rados -p rbd ls | grep <span class="string">'^rbd_data.25ae86b8b4567'</span> | xargs -n <span class="number">200</span>  rados -p rbd rm</span><br></pre></td></tr></table></figure></p>
<h2 id="开启多进程删除的方法">开启多进程删除的方法</h2><p>这个比上面那种方法好的是：</p>
<ul>
<li>可以显示当前删除的进度</li>
<li>可以指定删除的进程并发数</li>
<li>可以显示当时正在删除的对象</li>
<li>可以增加一个中断时间降低负载</li>
</ul>
<p>首先获取一个需要快速删除的rbd的列表<br>获取prifix<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 put]<span class="comment"># rbd info testrbd|grep prefix</span></span><br><span class="line">	block_name_prefix: rbd_data.<span class="number">32</span>c0f6b8b4567</span><br></pre></td></tr></table></figure></p>
<p>获取列表<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 put]<span class="comment"># rados -p rbd ls |grep rbd_data.32c0f6b8b4567 &gt; delobject</span></span><br></pre></td></tr></table></figure></p>
<p>这里可以看下内容有没有问题，检查确认下</p>
<p>删除的fastremove.sh脚本如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span><br><span class="line"></span></span><br><span class="line"><span class="comment">#####config</span></span><br><span class="line">process=<span class="number">5</span></span><br><span class="line">objectlistfile=<span class="string">"./delobject"</span></span><br><span class="line">deletepool=rbd</span><br><span class="line"><span class="comment">#####</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">delete_fun</span></span>()</span><br><span class="line">  &#123;</span><br><span class="line">      date <span class="string">"+%Y-%m-%d %H:%M:%S"</span></span><br><span class="line">      rados -p <span class="variable">$deletepool</span> rm <span class="variable">$1</span></span><br><span class="line">	  <span class="comment">#sleep 1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="title">concurrent</span></span>()</span><br><span class="line"> &#123;</span><br><span class="line">     start=<span class="variable">$1</span> &amp;&amp; end=<span class="variable">$2</span> &amp;&amp; cur_num=<span class="variable">$3</span></span><br><span class="line">     mkfifo   ./fifo.$$ &amp;&amp;  <span class="built_in">exec</span> <span class="number">4</span>&lt;&gt; ./fifo.$$ &amp;&amp; rm <span class="operator">-f</span> ./fifo.$$</span><br><span class="line">     <span class="keyword">for</span> ((i=<span class="variable">$start</span>; i&lt;<span class="variable">$cur_num</span>+<span class="variable">$start</span>; i++)); <span class="keyword">do</span></span><br><span class="line">         <span class="built_in">echo</span> <span class="string">"init  start delete process <span class="variable">$i</span>"</span> &gt;&amp;<span class="number">4</span></span><br><span class="line">     <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>((i=<span class="variable">$start</span>; i&lt;=<span class="variable">$end</span>; i++)); <span class="keyword">do</span></span><br><span class="line">         <span class="built_in">read</span> -u <span class="number">4</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="built_in">echo</span> <span class="operator">-e</span> <span class="string">"-- current delete: [:delete <span class="variable">$i</span>/<span class="variable">$objectnum</span>  <span class="variable">$REPLY</span>]"</span></span><br><span class="line">             delob=`sed -n <span class="string">"<span class="variable">$&#123;i&#125;</span>p"</span> <span class="variable">$objectlistfile</span>`</span><br><span class="line">             delete_fun <span class="variable">$delob</span></span><br><span class="line">             <span class="built_in">echo</span> <span class="string">"delete <span class="variable">$delob</span> done"</span>  <span class="number">1</span>&gt;&amp;<span class="number">4</span> <span class="comment"># write to $ff_file</span></span><br><span class="line">         &#125; &amp;</span><br><span class="line">     <span class="keyword">done</span></span><br><span class="line">     <span class="built_in">wait</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">objectnum=`cat <span class="variable">$objectlistfile</span>|wc <span class="operator">-l</span>`</span><br><span class="line">concurrent <span class="number">1</span> <span class="variable">$objectnum</span> <span class="variable">$process</span></span><br></pre></td></tr></table></figure></p>
<p>上面直接把配置写到脚本里面了，根据需要进行修改<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#####config</span></span><br><span class="line">process=<span class="number">10</span></span><br><span class="line">objectlistfile=<span class="string">"./delobject"</span></span><br><span class="line">deletepool=rbd</span><br><span class="line"><span class="comment">#####</span></span><br></pre></td></tr></table></figure></p>
<p>指定并发数目，指定准备删除的对象的list文件，指定对象所在的存储池</p>
<p>然后执行即可</p>
<h2 id="本次测试删除的性能差别">本次测试删除的性能差别</h2><p>准备对象数据<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rbd map testrbd</span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/dev/rbd2 bs=<span class="number">4</span>M count=<span class="number">1200</span></span><br></pre></td></tr></table></figure></p>
<p>获取列表<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 put]<span class="comment"># rados -p rbd ls |grep rbd_data.32c0f6b8b4567 &gt; delobject</span></span><br></pre></td></tr></table></figure></p>
<p>执行删除脚本<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 put]<span class="comment"># sh fastremove.sh</span></span><br></pre></td></tr></table></figure></p>
<p>测试结果如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">并发数</th>
<th style="text-align:center">删除时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">71s</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">35s</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">5s</td>
</tr>
<tr>
<td style="text-align:center">25</td>
<td style="text-align:center">6s</td>
</tr>
<tr>
<td style="text-align:center">50</td>
<td style="text-align:center">5s</td>
</tr>
<tr>
<td style="text-align:center">100</td>
<td style="text-align:center">5s</td>
</tr>
</tbody>
</table>
<p>从测试结果来看在并发数为5的时候就能达到每秒删除200个对象了，根据自己的需要进行增减，也可以增减删除的间隔加上sleep</p>
<p>下面看下这个过程：</p>
<iframe src="http://7xweck.com1.z0.glb.clouddn.com/fastremove.html" height="530px" width="90%" align="center"></iframe>

<h2 id="总结">总结</h2><p>在ceph里面一些系统的操作默认是单进程去处理的，一般情况下都没什么问题，在数据量超大，追求效率的时候，我们可以通过加上一些并发加速这个过程，本篇脚本当中的并发同样适用于其他需要并发的场景</p>
<h2 id="变更记录">变更记录</h2><table>
<thead>
<tr>
<th style="text-align:center">Why</th>
<th style="text-align:center">Who</th>
<th style="text-align:center">When</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建</td>
<td style="text-align:center">武汉-运维-磨渣</td>
<td style="text-align:center">2017-07-27</td>
</tr>
<tr>
<td style="text-align:center">增加前台调试信息的屏蔽</td>
<td style="text-align:center">武汉-运维-磨渣</td>
<td style="text-align:center">2017-07-28</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/deleting.gif?imageMogr2/thumbnail/!75p" alt="delete"><br></center>

<h2 id="前言">前言</h2><p>这个问题在很久以前就有一篇文章进行过讨论 <a href="http://cephnotes.ksperis.com/blog/2014/07/04/remove-big-rbd-image">remove-big-rbd</a>,这个文章写的比较清楚了，并且对不同的方法做了分析，这里先把结论说下</p>
<table>
<thead>
<tr>
<th style="text-align:center">rbd类型</th>
<th style="text-align:center">rbd rm 方法</th>
<th style="text-align:center">rados -p rm方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">未填充很多</td>
<td style="text-align:center">慢</td>
<td style="text-align:center">快</td>
</tr>
<tr>
<td style="text-align:center">已填充很多</td>
<td style="text-align:center">快</td>
<td style="text-align:center">慢</td>
</tr>
</tbody>
</table>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从ceph对象中提取RBD中的指定文件]]></title>
    <link href="http://www.zphj1987.com/2017/07/22/from-ceph-object-get-rbd-file/"/>
    <id>http://www.zphj1987.com/2017/07/22/from-ceph-object-get-rbd-file/</id>
    <published>2017-07-22T15:25:35.000Z</published>
    <updated>2017-07-22T15:35:41.820Z</updated>
    <content type="html"><![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/BLDG.png" alt=""><br></center>


<h2 id="前言">前言</h2><p>之前有个想法，是不是有办法找到rbd中的文件与对象的关系，想了很久但是一直觉得文件系统比较复杂，在fs 层的东西对ceph来说是透明的，并且对象大小是4M，而文件很小，可能在fs层进行了合并，应该很难找到对应关系，最近看到小胖有提出这个问题，那么就再次尝试了，现在就是把这个实现方法记录下来<br><a id="more"></a><br>这个提取的作用个人觉得最大的好处就是一个rbd设备，在文件系统层被破坏以后，还能够从rbd提取出文件，我们知道很多情况下设备的文件系统一旦破坏，无法挂载，数据也就无法读取，而如果能从rbd中提取出文件，这就是保证了即使文件系统损坏的情况下，数据至少不丢失</p>
<p>本篇是基于xfs文件系统情况下的提取，其他文件系统有时间再看看，因为目前使用的比较多的就是xfs文件系统</p>
<p>本篇也回答了一个可能会经常被问起的问题，能告诉我虚拟机里面的文件在后台存储在哪里么，看完本篇就知道存储在哪里了</p>
<h2 id="XFS文件系统介绍">XFS文件系统介绍</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># mkfs.xfs -f /dev/rbd0p1 </span></span><br><span class="line">warning: device is not properly aligned /dev/rbd0p1</span><br><span class="line">meta-data=/dev/rbd0p1            isize=<span class="number">256</span>    agcount=<span class="number">9</span>, agsize=<span class="number">162816</span> blks</span><br><span class="line">         =                       sectsz=<span class="number">512</span>   attr=<span class="number">2</span>, projid32bit=<span class="number">1</span></span><br><span class="line">         =                       crc=<span class="number">0</span>        finobt=<span class="number">0</span></span><br><span class="line">data     =                       bsize=<span class="number">4096</span>   blocks=<span class="number">1310475</span>, imaxpct=<span class="number">25</span></span><br><span class="line">         =                       sunit=<span class="number">1024</span>   swidth=<span class="number">1024</span> blks</span><br><span class="line">naming   =version <span class="number">2</span>              bsize=<span class="number">4096</span>   ascii-ci=<span class="number">0</span> ftype=<span class="number">0</span></span><br><span class="line"><span class="built_in">log</span>      =internal <span class="built_in">log</span>           bsize=<span class="number">4096</span>   blocks=<span class="number">2560</span>, version=<span class="number">2</span></span><br><span class="line">         =                       sectsz=<span class="number">512</span>   sunit=<span class="number">8</span> blks, lazy-count=<span class="number">1</span></span><br><span class="line">realtime =none                   extsz=<span class="number">4096</span>   blocks=<span class="number">0</span>, rtextents=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>XFS文件系统采取是AG管理的，每个AG维护自己的inode和数据，所以XFS文件系统是一种很容易扩展的文件系统，本篇里面主要用到的命令是xfs_bmap这个命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># xfs_bmap -lvp /etc/fstab</span></span><br><span class="line">/etc/fstab:</span><br><span class="line"> EXT: FILE-OFFSET      BLOCK-RANGE        AG AG-OFFSET        TOTAL FLAGS</span><br><span class="line">   <span class="number">0</span>: [<span class="number">0</span>..<span class="number">7</span>]:          <span class="number">26645424</span>..<span class="number">26645431</span>  <span class="number">1</span> (<span class="number">431024</span>..<span class="number">431031</span>)     <span class="number">8</span> <span class="number">00000</span></span><br></pre></td></tr></table></figure></p>
<p>一个文件最小就是8个block（512b），也就是4k,这个因为上面默认的xfs的格式化就是data bsize=4K,这个值可以自行调整的，本篇尽量用默认常规的参数来讲例子</p>
<p>查看man xfs_bmap这个命令可以看到：</p>
<blockquote>
<p>Holes are marked by replacing the startblock..endblock with hole.  All the file offsets and disk blocks are in units of 512-byte blocks, no matter what the filesystem’s block size is.</p>
</blockquote>
<p>意思是这个查询到的里面的计数单位都是512-byte，不管上层设置的block大小是多少，我们知道文件系统底层的sector就是512-byte，所以这个查询到的结果就可以跟当前的文件系统的sector的偏移量联系起来，这里强调一下，这个偏移量的起始位子为当前文件系统所在分区的偏移量，如果是多分区的情况，在计算整个偏移量的时候就要考虑分区的偏移量了，这个会在后面用实例进行讲解的</p>
<p>rbd的对象是不清楚内部分区的偏移量，所以在rbd层进行提取的时候是需要得到的是分区当中的文件相对整个磁盘的一个sector的偏移量</p>
<h2 id="rbd的对象结构">rbd的对象结构</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># rados -p rbd ls|grep data</span></span><br><span class="line">rbd_data.<span class="number">25</span>a636b8b4567.<span class="number">00000000000009</span>ff</span><br><span class="line">rbd_data.<span class="number">25</span>a636b8b4567.<span class="number">00000000000001</span>dd</span><br><span class="line">rbd_data.<span class="number">25</span>a636b8b4567.<span class="number">0000000000000000</span></span><br><span class="line">rbd_data.<span class="number">25</span>a636b8b4567.<span class="number">000000000000009</span>f</span><br><span class="line">rbd_data.<span class="number">25</span>a636b8b4567.<span class="number">0000000000000459</span></span><br><span class="line">rbd_data.<span class="number">25</span>a636b8b4567.<span class="number">000000000000027</span>e</span><br><span class="line">rbd_data.<span class="number">25</span>a636b8b4567.<span class="number">00000000000004</span>ff</span><br><span class="line">rbd_data.<span class="number">25</span>a636b8b4567.<span class="number">000000000000027</span>c</span><br><span class="line">rbd_data.<span class="number">25</span>a636b8b4567.<span class="number">000000000000027</span>d</span><br><span class="line">rbd_data.<span class="number">25</span>a636b8b4567.<span class="number">0000000000000001</span></span><br><span class="line">rbd_data.<span class="number">25</span>a636b8b4567.<span class="number">000000000000013</span>e</span><br><span class="line">rbd_data.<span class="number">25</span>a636b8b4567.<span class="number">00000000000003</span>ba</span><br><span class="line">rbd_data.<span class="number">25</span>a636b8b4567.<span class="number">000000000000031</span>b</span><br><span class="line">rbd_data.<span class="number">25</span>a636b8b4567.<span class="number">00000000000004</span>f8</span><br></pre></td></tr></table></figure>
<p>rbd被xfs格式化以后会产生一些对象，这些对象是以16进制名称的方式存储在后台的，也就是rbd大小一定的情况下对象数目是一定的，也就是名称也是一定的<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># parted -s /dev/rbd0 unit s print</span></span><br><span class="line">Model: Unknown (unknown)</span><br><span class="line">Disk /dev/rbd0: <span class="number">20971520</span>s</span><br><span class="line">Sector size (logical/physical): <span class="number">512</span>B/<span class="number">512</span>B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start      End        Size       File system  Name     Flags</span><br><span class="line"> <span class="number">1</span>      <span class="number">1953</span>s      <span class="number">10485759</span>s  <span class="number">10483807</span>s  xfs          primari</span><br><span class="line"> <span class="number">2</span>      <span class="number">10485760</span>s  <span class="number">20963327</span>s  <span class="number">10477568</span>s               primari</span><br></pre></td></tr></table></figure></p>
<p>上面可以看到rbd0的sector个数为20971520s<br>20971520s*512byte=10737418240byte=10485760KB=10240MB<br>sector的大小一定，总rbd大小一定的情况下sector的数目也是一定的，本篇实例的rbd大小<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># rbd info zp</span></span><br><span class="line">rbd image <span class="string">'zp'</span>:</span><br><span class="line">	size <span class="number">10000</span> MB <span class="keyword">in</span> <span class="number">2500</span> objects</span><br><span class="line">	order <span class="number">22</span> (<span class="number">4096</span> kB objects)</span><br><span class="line">	block_name_prefix: rbd_data.<span class="number">25</span>a776b8b4567</span><br><span class="line">	format: <span class="number">2</span></span><br><span class="line">	features: layering</span><br><span class="line">	flags: </span><br><span class="line">	create_timestamp: Sat Jul <span class="number">22</span> <span class="number">18</span>:<span class="number">04</span>:<span class="number">12</span> <span class="number">2017</span></span><br></pre></td></tr></table></figure></p>
<h2 id="sector和ceph_object的对应关系的查询">sector和ceph object的对应关系的查询</h2><p>这个就像个map一样，需要把这个关系给找到，一个sector的区间对应到object的map，这里我用python写个简单的方法来做查询，也可以自己用其他语言来实现</p>
<p>首先查询到rbd的对象数目<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># rbd info zp</span></span><br><span class="line">rbd image <span class="string">'zp'</span>:</span><br><span class="line">	size <span class="number">10000</span> MB <span class="keyword">in</span> <span class="number">2500</span> objects</span><br><span class="line">	order <span class="number">22</span> (<span class="number">4096</span> kB objects)</span><br><span class="line">	block_name_prefix: rbd_data.<span class="number">25</span>a776b8b4567</span><br><span class="line">	format: <span class="number">2</span></span><br><span class="line">	features: layering</span><br><span class="line">	flags: </span><br><span class="line">	create_timestamp: Sat Jul <span class="number">22</span> <span class="number">18</span>:<span class="number">04</span>:<span class="number">12</span> <span class="number">2017</span></span><br></pre></td></tr></table></figure></p>
<p>处理脚本如下:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim getsecob.py</span><br></pre></td></tr></table></figure></p>
<p>添加下面内容<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /bin/python</span></span><br><span class="line"><span class="comment"># *-* conding=UTF-8 *-*</span></span><br><span class="line"></span><br><span class="line">import commands</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    getmap(<span class="number">2500</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getmap(object):</span><br><span class="line">    sector=int(object)*<span class="number">4096</span>*<span class="number">1024</span>/<span class="number">512</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">"object:"</span>+str(object)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">"sector:"</span>+str(sector)</span><br><span class="line">    incre=sector/object</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> range(int(object)):</span><br><span class="line">        a=int(item*<span class="number">8192</span>)</span><br><span class="line">        b=int((item+<span class="number">1</span>)*<span class="number">8192</span>-<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span> str([a,b])+<span class="string">"  --&gt;  "</span>+<span class="string">"%016x"</span> %item</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<p>其中getmap后面为对象数目<br>输出是这个形式的：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># python getsecob.py</span></span><br><span class="line">object:<span class="number">2500</span></span><br><span class="line">sector:<span class="number">20480000</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">8191</span>]  --&gt;  <span class="number">0000000000000000</span></span><br><span class="line">[<span class="number">8192</span>, <span class="number">16383</span>]  --&gt;  <span class="number">0000000000000001</span></span><br><span class="line">[<span class="number">16384</span>, <span class="number">24575</span>]  --&gt;  <span class="number">0000000000000002</span></span><br><span class="line">[<span class="number">24576</span>, <span class="number">32767</span>]  --&gt;  <span class="number">0000000000000003</span></span><br><span class="line">[<span class="number">32768</span>, <span class="number">40959</span>]  --&gt;  <span class="number">0000000000000004</span></span><br><span class="line">[<span class="number">40960</span>, <span class="number">49151</span>]  --&gt;  <span class="number">0000000000000005</span></span><br><span class="line">···</span><br></pre></td></tr></table></figure></p>
<p>对rbd0进行分区，分区后的结果如下<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># parted -s /dev/rbd0 unit s print</span></span><br><span class="line">Model: Unknown (unknown)</span><br><span class="line">Disk /dev/rbd0: <span class="number">20480000</span>s</span><br><span class="line">Sector size (logical/physical): <span class="number">512</span>B/<span class="number">512</span>B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start      End        Size       File system  Name     Flags</span><br><span class="line"> <span class="number">1</span>      <span class="number">1953</span>s      <span class="number">10240000</span>s  <span class="number">10238048</span>s               primari</span><br><span class="line"> <span class="number">2</span>      <span class="number">10248192</span>s  <span class="number">20471807</span>s  <span class="number">10223616</span>s               primari</span><br></pre></td></tr></table></figure></p>
<p>这个是个测试用的image，大小为10G分成两个5G的分区，现在我们在两个分区里面分别写入两个测试文件，然后经过计算后，从后台的对象中把文件读出<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/rbd0p1 /mnt1</span><br><span class="line">mount /dev/rbd0p2 /mnt2</span><br><span class="line">cp /etc/fstab /mnt1</span><br><span class="line">cp /etc/hostname /mnt2</span><br></pre></td></tr></table></figure></p>
<p>首先获取文件在分区上的sector的偏移量<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># xfs_bmap -lvp /mnt1/fstab </span></span><br><span class="line">/mnt1/fstab:</span><br><span class="line"> EXT: FILE-OFFSET      BLOCK-RANGE      AG AG-OFFSET        TOTAL FLAGS</span><br><span class="line">   <span class="number">0</span>: [<span class="number">0</span>..<span class="number">7</span>]:          <span class="number">8224</span>..<span class="number">8231</span>        <span class="number">0</span> (<span class="number">8224</span>..<span class="number">8231</span>)         <span class="number">8</span> <span class="number">01111</span></span><br></pre></td></tr></table></figure></p>
<p>可以得到是(8224..8231)共8个sector<br>从上面的分区1的start的sector可以知道起始位置是1953，那么相对于磁盘的偏移量就变成了</p>
<blockquote>
<p>(8224+1953..8231+1953) = (10177..10184)</p>
</blockquote>
<p>这里说下，这个地方拿到偏移量后，直接通过对rbd设备进行dd读取也可以把这个文件读取出来，这个顺带讲下，本文主要是从对象提取：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/rbd0 of=a bs=<span class="number">512</span> count=<span class="number">8</span> skip=<span class="number">10177</span></span><br></pre></td></tr></table></figure></p>
<p>bs取512是因为sector的单位就是512b<br>这样就把刚刚的fstab文件读取出来了，skip就是文件的sector相对磁盘的起始位置，count就是文件所占的block数目</p>
<p>继续我们的对象提取方式，上面的（10177..10184）这个我们根据上面那个脚本输出的对象列表来找到对象</p>
<blockquote>
<p>[8192, 16383]  —&gt;  0000000000000001<br>获取名称，这个因为我的是测试环境，就只有一个匹配，多个image的时候要过滤出对用的rbd的对象，用prifix过滤即可</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># rados -p rbd ls|grep 0000000000000001</span></span><br><span class="line">rbd_data.<span class="number">25</span>a776b8b4567.<span class="number">0000000000000001</span></span><br></pre></td></tr></table></figure>
<p>下载对象<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># rados -p rbd get rbd_data.25a776b8b4567.0000000000000001 rbd_data.25a776b8b4567.0000000000000001</span></span><br></pre></td></tr></table></figure></p>
<p>根据偏移量计算对象中的偏移量<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">（<span class="number">10177</span>..<span class="number">10184</span>）</span><br><span class="line">[<span class="number">8192</span>, <span class="number">16383</span>]  --&gt;  <span class="number">0000000000000001</span></span><br></pre></td></tr></table></figure></p>
<p>得到<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="number">10177</span>-<span class="number">8192</span>=<span class="number">1985</span></span><br><span class="line"></span><br><span class="line">dd <span class="keyword">if</span>=rbd_data.<span class="number">25</span>a776b8b4567.<span class="number">0000000000000001</span> of=a bs=<span class="number">512</span> count=<span class="number">8</span> skip=<span class="number">1985</span></span><br></pre></td></tr></table></figure></p>
<p>得到的文件a的内容即为之前文件的内容</p>
<p>准备取第二个分区的文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># xfs_bmap -lvp /mnt2/hostname </span></span><br><span class="line">/mnt2/hostname:</span><br><span class="line"> EXT: FILE-OFFSET      BLOCK-RANGE      AG AG-OFFSET        TOTAL FLAGS</span><br><span class="line">   <span class="number">0</span>: [<span class="number">0</span>..<span class="number">7</span>]:          <span class="number">8224</span>..<span class="number">8231</span>        <span class="number">0</span> (<span class="number">8224</span>..<span class="number">8231</span>)         <span class="number">8</span> <span class="number">01111</span></span><br></pre></td></tr></table></figure></p>
<p>8224+10248192..8231+10248192=10256416..10256423</p>
<p>从磁盘方式<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># dd if=/dev/rbd0 of=a bs=512 count=8 skip=10256416</span></span><br></pre></td></tr></table></figure></p>
<p>从对象方式<br>10256416..10256423 对应<br>[10256384, 10264575]  —&gt;  00000000000004e4<br>对象偏移量<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="number">10256416</span>-<span class="number">10256384</span>=<span class="number">32</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rados -p rbd get </span><br><span class="line">[root@lab8106 ~]<span class="comment"># rados -p rbd get rbd_data.25a776b8b4567.00000000000004e4 rbd_data.25a776b8b4567.00000000000004e4</span></span><br></pre></td></tr></table></figure>
<p>获取文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># dd if=rbd_data.25a776b8b4567.00000000000004e4 of=a bs=512 count=8 skip=32</span></span><br></pre></td></tr></table></figure></p>
<p>如果文件比较大的情况，可能出现就是文件是跨对象的，那么还是跟上面的提取方法一样，然后进行提取后的文件进行合并即可</p>
<h2 id="总结">总结</h2><p>在存储系统上面存储的文件必然会对应到底层磁盘的sector，而sector也是会一一对应到后台的对象的，这个在本文当中得到了验证，所以整个逻辑就是，在文件系统层找到文件对应的sector位置，然后再在底层把sector和对象关系找好，就能从找到文件在对象当中的具体的位置，也就能定位并且能提取了，本篇是基于xfs的，其他文件系统只要能定位文件的sector，就可以在底层找到文件，这个以后会补充其他文件系统进来</p>
<h2 id="变更记录">变更记录</h2><table>
<thead>
<tr>
<th style="text-align:center">Why</th>
<th style="text-align:center">Who</th>
<th style="text-align:center">When</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建</td>
<td style="text-align:center">武汉-运维-磨渣</td>
<td style="text-align:center">2017-07-22</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/BLDG.png" alt=""><br></center>


<h2 id="前言">前言</h2><p>之前有个想法，是不是有办法找到rbd中的文件与对象的关系，想了很久但是一直觉得文件系统比较复杂，在fs 层的东西对ceph来说是透明的，并且对象大小是4M，而文件很小，可能在fs层进行了合并，应该很难找到对应关系，最近看到小胖有提出这个问题，那么就再次尝试了，现在就是把这个实现方法记录下来<br>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用火焰图分析ceph pg分布]]></title>
    <link href="http://www.zphj1987.com/2017/07/18/use-flame-show-ceph-pg/"/>
    <id>http://www.zphj1987.com/2017/07/18/use-flame-show-ceph-pg/</id>
    <published>2017-07-18T05:35:07.000Z</published>
    <updated>2017-07-18T14:09:45.747Z</updated>
    <content type="html"><![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/flame.png" alt=""><br></center>

<h2 id="前言">前言</h2><p>性能优化大神Brendan Gregg发明了火焰图来定位性能问题，通过图表就可以发现问题出在哪里，通过svg矢量图来查看性能卡在哪个点，哪个操作占用的资源最多<br><a id="more"></a><br>在查看了原始数据后，这个分析的原理是按层级来对调用进行一个计数，然后以层级去做比对，来看横向的占用的比例情况</p>
<p>基于这个原理，把osd tree的数据和pg数据可以做一个层级的组合，从而可以很方便的看出pg的分布情况，主机的分布情况，还可以进行搜索，在一个简单的图表内汇聚了大量的信息</p>
<h2 id="实践">实践</h2><p>获取需要的数据，这个获取数据是我用一个脚本解析的osd tree 和pg dump，然后按照需要的格式进行输出</p>
<blockquote>
<p>default;lab8106;osd.2;0.0 6<br>default;lab8106;osd.3;0.0 6<br>default;rack1;lab8107;osd.0;0.0 6</p>
</blockquote>
<p>需要的格式是这个样的，最后一个为权重，使用的是对象数，因为对象数可能为0，所以默认在每个数值进行了加一的操作，前面就是osd的分布的位置</p>
<p>脚本/sbin/stackcollapse-crush内容如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line">import os</span><br><span class="line">import commands</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    global list_all_host</span><br><span class="line">    list_all_host = commands.getoutput(<span class="string">'ceph osd tree -f json-pretty  2&gt;/dev/null'</span>)</span><br><span class="line">    getpgmap()</span><br><span class="line">def getosd(osd):</span><br><span class="line">    mylist=[]</span><br><span class="line">    crushid=&#123;&#125;</span><br><span class="line">    json_str = json.loads(list_all_host)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> json_str[<span class="string">'nodes'</span>]:</span><br><span class="line">        <span class="keyword">if</span> item.has_key(<span class="string">'children'</span>):</span><br><span class="line">            crushid[str(item[<span class="string">'id'</span>])]=str(item[<span class="string">'name'</span>])</span><br><span class="line">            <span class="keyword">for</span> child <span class="keyword">in</span> item[<span class="string">'children'</span>]:</span><br><span class="line">                tmplist=[item[<span class="string">'id'</span>],child]</span><br><span class="line">                mylist.append(tmplist)</span><br><span class="line">        <span class="keyword">if</span> item[<span class="string">'type'</span>] == <span class="string">"osd"</span>:</span><br><span class="line">            crushid[str(item[<span class="string">'id'</span>])]=str(item[<span class="string">'name'</span>])</span><br><span class="line">    listnum=len(mylist)</span><br><span class="line">    compareindex=<span class="number">0</span></span><br><span class="line"><span class="comment">###从数组开始跟后面的数组进行比较，如果有就改变后面的数组，然后删除当前比较的list(index),进行list更新</span></span><br><span class="line"><span class="comment">###如果没有改变，就把索引往后推即可</span></span><br><span class="line">    <span class="keyword">while</span> compareindex &lt; len(mylist):</span><br><span class="line">        change = False</span><br><span class="line">        <span class="keyword">for</span> index,num <span class="keyword">in</span> enumerate(mylist):</span><br><span class="line">            <span class="keyword">if</span> compareindex != index and compareindex &lt; index:</span><br><span class="line">                <span class="keyword">if</span> str(mylist[compareindex][-<span class="number">1</span>]) == str(num[<span class="number">0</span>]):</span><br><span class="line">                    del mylist[index][<span class="number">0</span>]</span><br><span class="line">                    mylist[index]=mylist[compareindex]+mylist[index]</span><br><span class="line">                    change=True</span><br><span class="line">                <span class="keyword">if</span> str(mylist[compareindex][<span class="number">0</span>]) == str(num[-<span class="number">1</span>]):</span><br><span class="line">                    del mylist[index][-<span class="number">1</span>]</span><br><span class="line">                    mylist[index]=mylist[index]+mylist[compareindex]</span><br><span class="line">                    change=True</span><br><span class="line">        <span class="keyword">if</span> change == True:</span><br><span class="line">            del mylist[compareindex]</span><br><span class="line">        <span class="keyword">if</span> change == False:</span><br><span class="line">            compareindex = compareindex + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index,crushlist <span class="keyword">in</span> enumerate(mylist):</span><br><span class="line">        osdcrushlist=[]</span><br><span class="line">        <span class="keyword">for</span> osdlocaltion <span class="keyword">in</span> crushlist:</span><br><span class="line">            <span class="built_in">local</span>=str(crushid[<span class="string">'%s'</span> %osdlocaltion])</span><br><span class="line">            osdcrushlist.append(<span class="built_in">local</span>)</span><br><span class="line">        <span class="keyword">if</span> osdcrushlist[-<span class="number">1</span>] == osd:</span><br><span class="line">            <span class="built_in">return</span> osdcrushlist</span><br><span class="line"></span><br><span class="line">def getpgmap():</span><br><span class="line">    list_all_host = commands.getoutput(<span class="string">'ceph pg  ls --format json-pretty  2&gt;/dev/null'</span>)</span><br><span class="line">    json_str = json.loads(list_all_host)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> json_str:</span><br><span class="line">        <span class="keyword">for</span> osdid <span class="keyword">in</span> item[<span class="string">'up'</span>]:</span><br><span class="line">            osd=<span class="string">"osd."</span>+str(osdid)</span><br><span class="line">            b=<span class="string">""</span></span><br><span class="line">            <span class="keyword">for</span> a <span class="keyword">in</span> getosd(osd):</span><br><span class="line">                b=b+str(a)+<span class="string">";"</span></span><br><span class="line">            <span class="built_in">print</span> b+item[<span class="string">'pgid'</span>]+<span class="string">" "</span>+str(item[<span class="string">'stat_sum'</span>][<span class="string">'num_objects'</span>]+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<h3 id="获取数据">获取数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/sbin/stackcollapse-crush &gt; /tmp/mydata</span><br></pre></td></tr></table></figure>
<h3 id="解析数据">解析数据</h3><p>获取解析脚本，这个脚本是Brendan Gregg写好的，这地方托管到我的github里面了<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O /sbin/flamegraph https://raw.githubusercontent.com/zphj1987/cephcrushflam/master/flamegraph.pl</span><br></pre></td></tr></table></figure></p>
<p>对数据进行解析<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/sbin/flamegraph  --title  <span class="string">"Ceph crush flame graph"</span> --width <span class="string">"1800"</span> --countname <span class="string">"num"</span> /tmp/mydata &gt; /tmp/mycrush.svg</span><br></pre></td></tr></table></figure></p>
<p>将/tmp/mycrush.svg拷贝到windows机器，然后用浏览器打开即可，推荐chrome</p>
<h3 id="效果图如下">效果图如下</h3><p>Example (右键在新窗口中打开):<br><a href="http://7xweck.com1.z0.glb.clouddn.com/mycrush.svg" target="_blank" rel="external"><img src="http://7xweck.com1.z0.glb.clouddn.com/mycrush.svg" alt="Example"></a></p>
<ul>
<li>通过颜色来区分比例占用的区别</li>
<li>支持搜索</li>
<li>tree方式，可以清楚看到分布</li>
<li>可以查看pg对象数目</li>
<li>可以查看osd上面有哪些pg，主机上有哪些osd</li>
</ul>
<h2 id="总结">总结</h2><p>通过ceph osd tree可以查到整个的信息，但是一个屏幕的信息量有限，而通过滚屏或者过滤进行查询的信息，需要做一下关联，而这种可以缩放的svg位图的方式，可以包含大量的信息，如果是做分析的时候还是能比较直观的看到，上面的难点在于获取数据部分，而绘图的部分是直接用的现有的处理，比自己重新开发一个要简单的多，类似的工具还有个桑基图方式，这个在inkscope这个管理平台里面有用到</p>
<p>本篇就是在最小的视野里容纳尽量多的信息量一个实例，其他的数据有类似模型的也可以做相似的处理</p>
<h2 id="变更记录">变更记录</h2><table>
<thead>
<tr>
<th style="text-align:center">Why</th>
<th style="text-align:center">Who</th>
<th style="text-align:center">When</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建</td>
<td style="text-align:center">武汉-运维-磨渣</td>
<td style="text-align:center">2017-07-18</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/flame.png" alt=""><br></center>

<h2 id="前言">前言</h2><p>性能优化大神Brendan Gregg发明了火焰图来定位性能问题，通过图表就可以发现问题出在哪里，通过svg矢量图来查看性能卡在哪个点，哪个操作占用的资源最多<br>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cephfs 操作输出到日志查询系统]]></title>
    <link href="http://www.zphj1987.com/2017/07/13/CEPHFS-op-to-graylog/"/>
    <id>http://www.zphj1987.com/2017/07/13/CEPHFS-op-to-graylog/</id>
    <published>2017-07-13T03:32:04.000Z</published>
    <updated>2017-07-13T04:02:53.320Z</updated>
    <content type="html"><![CDATA[<center><br><img src="http://static.zybuluo.com/zphj1987/flhdkmrs0d5dqt02ymi30phy/log.png" alt="log.png-116.6kB"><br></center>

<h2 id="前言">前言</h2><p>文件系统当中如果某些文件不见了，有什么办法判断是删除了还是自己不见了，这个就需要去日志里面定位了，通常情况下是去翻日志，而日志是会进行压缩的，并且查找起来非常的不方便,还有可能并没有开启<br><a id="more"></a><br>这个时候就需要日志系统了，最近正好看到一篇<a href="https://zhuanlan.zhihu.com/p/27363484" target="_blank" rel="external">最佳日志实践（v2.0）</a>，一篇非常好的文章，本篇日志属于文章里面所提到的统计日志，统计客户端做了什么操作</p>
<p>对于日志系统来说，很重要的一点，能够很方便的进行查询，这就需要对日志信息进行一些处理了，怎么处理就是设计问题，要求就是不多不少</p>
<h2 id="结构">结构</h2><center><br><img src="http://static.zybuluo.com/zphj1987/22grh70azoj3owga4lwmnpmk/mdslogsystem.png" alt="mdslogsystem.png-32.4kB"><br></center>

<p>其中graylog配置部分在这篇<a href="http://www.zphj1987.com/2017/06/09/use-graylog-get-Ceph-status/" target="_blank" rel="external">使用日志系统graylog获取Ceph集群状态</a>，根据这篇的操作，配置出12201的udp监听端口即可，剩余部分就是本篇中的配置</p>
<h2 id="配置">配置</h2><h3 id="集群的配置">集群的配置</h3><p>需要对MDS的配置进行debug_ms=1,在/etc/ceph/ceph.conf当中添加下面配置<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mds.lab8106]</span><br><span class="line">debug_ms=<span class="number">1</span></span><br><span class="line">hostname=lab8106</span><br></pre></td></tr></table></figure></p>
<p>这个地方集群的文件操作日志是记录在message里面的1级别的，所以把mds的debug_ms开到1<br>日志长这个样子：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="number">2017</span>-<span class="number">07</span>-<span class="number">13</span> <span class="number">11</span>:<span class="number">26</span>:<span class="number">23.703624</span> <span class="number">7</span><span class="built_in">fc</span>3128c3700  <span class="number">1</span> -- <span class="number">192.168</span>.<span class="number">8.106</span>:<span class="number">6804</span>/<span class="number">3280969928</span> &lt;== client.<span class="number">14180</span> <span class="number">192.168</span>.<span class="number">8.106</span>:<span class="number">0</span>/<span class="number">1092795882</span> <span class="number">2384</span> ==== client_request(client.<span class="number">14180</span>:<span class="number">2346</span> mkdir <span class="comment">#1/ppop 2017-07-13 11:26:23.702532 caller_uid=0, caller_gid=0&#123;&#125;) v2 ==== 170+0+0 (843685338 0 0) 0x5645ec243600 con 0x5645ec247000</span></span><br></pre></td></tr></table></figure></p>
<p>下面会对这个日志进行提取</p>
<h3 id="下载logstash">下载logstash</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://artifacts.elastic.co/downloads/logstash/logstash-<span class="number">5.5</span>.<span class="number">0</span>.rpm</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># rpm -ivh logstash-5.5.0.rpm</span></span><br></pre></td></tr></table></figure>
<p>修改启动进程为root权限<br>修改/etc/systemd/system/logstash.service文件当中的<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">User=root</span><br><span class="line">Group=root</span><br></pre></td></tr></table></figure></p>
<p>因为logstash需要本地文件的读取权限，这里是为了方便直接给的root权限，方便使用，如果对权限要求比较严的环境，就给文件</p>
<h3 id="创建一个配置文件">创建一个配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/logstash/conf.d/logstash.conf</span><br></pre></td></tr></table></figure>
<p>添加下面的配置文件，这个配置文件包含的内容比较多，会在后面详细的介绍下处理过程<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    file &#123;</span><br><span class="line">    path =&gt; <span class="string">"/var/log/ceph/ceph-mds.*.log"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">     match =&gt;&#123;<span class="string">"message"</span> =&gt; <span class="string">"%&#123;TIMESTAMP_ISO8601:logtime&#125; %&#123;BASE16FLOAT&#125;  %&#123;BASE10NUM&#125; -- %&#123;HOSTPORT:mdsip&#125;%&#123;NOTSPACE&#125; &lt;== %&#123;NOTSPACE:clientid&#125; %&#123;IP:clientip&#125;%&#123;NOTSPACE&#125; %&#123;INT&#125; ==== client_request\(%&#123;NOTSPACE&#125; %&#123;WORD:do&#125; %&#123;NOTSPACE:where&#125; %&#123;TIMES</span><br><span class="line">TAMP_ISO8601:dotime&#125;%&#123;GREEDYDATA&#125;"</span>&#125;</span><br><span class="line">    overwrite =&gt; [<span class="string">"message"</span>]</span><br><span class="line">    remove_field =&gt;[<span class="string">"logtime"</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ![dotime] &#123;</span><br><span class="line">        drop &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> [<span class="keyword">do</span>] == <span class="string">"mkdir"</span> &#123;</span><br><span class="line">        mutate &#123;</span><br><span class="line">        replace =&gt; &#123; <span class="string">"do"</span> =&gt; <span class="string">"创建目录"</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> [<span class="keyword">do</span>] == <span class="string">"create"</span> &#123;</span><br><span class="line">        mutate &#123;</span><br><span class="line">        replace =&gt; &#123; <span class="string">"do"</span> =&gt; <span class="string">"创建文件"</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> [<span class="keyword">do</span>] == <span class="string">"unlink"</span> &#123;</span><br><span class="line">        mutate &#123;</span><br><span class="line">        replace =&gt; &#123; <span class="string">"do"</span> =&gt; <span class="string">"删除文件"</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> [<span class="keyword">do</span>] == <span class="string">"rmdir"</span> &#123;</span><br><span class="line">        mutate &#123;</span><br><span class="line">        replace =&gt; &#123; <span class="string">"do"</span> =&gt; <span class="string">"删除目录"</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> [<span class="keyword">do</span>] == <span class="string">"rename"</span> &#123;</span><br><span class="line">        mutate &#123;</span><br><span class="line">        replace =&gt; &#123; <span class="string">"do"</span> =&gt; <span class="string">"重命名"</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> [<span class="keyword">do</span>] == <span class="string">"symlink"</span> &#123;</span><br><span class="line">        mutate &#123;</span><br><span class="line">        replace =&gt; &#123; <span class="string">"do"</span> =&gt; <span class="string">"链接"</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> [<span class="keyword">do</span>] == <span class="string">"unlink"</span>&#123;</span><br><span class="line">        mutate &#123;</span><br><span class="line">        replace =&gt; &#123; <span class="string">"do"</span> =&gt; <span class="string">"删除链接"</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutate &#123;</span><br><span class="line">        replace =&gt; &#123; <span class="string">"message"</span> =&gt; <span class="string">"time:%&#123;dotime&#125; ClientIp:%&#123;clientip&#125;  ClintId:%&#123;clientid&#125;  MdsIp: %&#123;mdsip&#125; do:%&#123;do&#125; where:%&#123;where&#125;"</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    date &#123;</span><br><span class="line">        match =&gt; [ <span class="string">"dotime"</span>, <span class="string">"yyyy-MM-dd HH:mm:ss.SSSSSS"</span>]</span><br><span class="line">        target =&gt; <span class="string">"@timestamp"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">    gelf &#123;</span><br><span class="line">        host =&gt; <span class="string">"192.168.8.106"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stdout &#123; codec =&gt; json_lines&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>处理后的日志是这个样子：</p>
<blockquote>
<p>{“path”:”/var/log/ceph/ceph-mds.lab8106.log”,”@timestamp”:”2017-07-13T04:01:01.251Z”,”clientid”:”client.14180”,”clientip”:”192.168.8.106”,”@version”:”1”,”host”:”lab8106”,”where”:”#1/test1”,”do”:”创建目录”,”message”:”time:2017-07-13 12:01:01.251358 ClientIp:192.168.8.106  ClintId:client.14180  MdsIp: 192.168.8.106:6804 do:创建目录 where:#1/test1”,”mdsip”:”192.168.8.106:6804”,”dotime”:”2017-07-13 12:01:01.251358”}</p>
</blockquote>
<p>是一个json形式的，可以根据自己的需要增加减少字段，这些信息都会传递到graylog当中</p>
<h3 id="解析配置文件">解析配置文件</h3><p>logstash配置文件的结构包括三个大模块：</p>
<ul>
<li>input</li>
<li>filter</li>
<li>output</li>
</ul>
<p>input是文件的来源，也就是我们需要解析的日志，filter是处理日志的模块，output是输出的模块，这里我们需要使用的是gelf的输出模式，在本地进行调试的时候，可以开启stdout来进行调试</p>
<p>采用grok进行正则匹配，这个里面的匹配正则可以用 <a href="http://grokconstructor.appspot.com/do/construction" target="_blank" rel="external">http://grokconstructor.appspot.com/do/construction</a> 这个进行正则表达式的验证和书写，可以一步步的进行匹配，还是很方便的工具</p>
<p>output输出gelf的信息流</p>
<h3 id="grok内部解析">grok内部解析</h3><ul>
<li>remove_field可以用来删除无用的字段</li>
<li>if ![dotime] 这个是用来过滤消息的，如果没拿到这个值，也就是没匹配上的时候，就把消息丢弃</li>
<li>使用mutate replace模块来进行字段的替换，将固定操作转换为中文</li>
<li>使用mutate replace模块来重写message，根据自己定义的格式进行输出</li>
<li>使用date 模块进行@timestamp的重写，将日志内的时间写入到这个里面</li>
</ul>
<p>查询插件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/share/logstash/bin/logstash-plugin list</span><br></pre></td></tr></table></figure></p>
<p>logstash-output-gelf默认没有安装的,需要安装一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/share/logstash/bin/logstash-plugin install logstash-output-gelf</span><br></pre></td></tr></table></figure>
<p>这个安装可能有点慢，稍微多等一下</p>
<p>调试方式的启动<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/share/logstash/bin/logstash <span class="operator">-f</span> /etc/logstash/conf.d/logstash.conf</span><br></pre></td></tr></table></figure></p>
<p>如果调试完毕了后就用系统命令启动<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># systemctl restart logstash</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://static.zybuluo.com/zphj1987/95e2t54owr6ket33b9t00fa8/graylogfs.png" alt="graylogfs.png-188.3kB"></p>
<p>通过graylog系统就可以很方便的看到日志里面节获取的内容了</p>
<h3 id="总结">总结</h3><p>对于一套系统来说，日志系统是一个很重要的组成部分，可以更好的掌握系统内部的运行情况，并不是说出了问题再去找日志，这个日志的需求来源其实很简单</p>
<blockquote>
<p>哪个客户端对着哪个MDS做了一个什么操作</p>
</blockquote>
<p>然后就可以用这个搜索引擎去进行相关的搜索了，可以查询一段时间创建了多少文件，是不是删除了哪个文件</p>
<p>本次实践的难点在于logstash对日志的相关解析的操作，掌握了方法以后，对于其他日志的提取也可以用类似的方法，提取自己需要的信息，然后进行整合，输出到一个系统当中，剩下的就是在界面上获取信息</p>
<h2 id="变更记录">变更记录</h2><table>
<thead>
<tr>
<th style="text-align:center">Why</th>
<th style="text-align:center">Who</th>
<th style="text-align:center">When</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建</td>
<td style="text-align:center">武汉-运维-磨渣</td>
<td style="text-align:center">2017-07-13</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<center><br><img src="http://static.zybuluo.com/zphj1987/flhdkmrs0d5dqt02ymi30phy/log.png" alt="log.png-116.6kB"><br></center>

<h2 id="前言">前言</h2><p>文件系统当中如果某些文件不见了，有什么办法判断是删除了还是自己不见了，这个就需要去日志里面定位了，通常情况下是去翻日志，而日志是会进行压缩的，并且查找起来非常的不方便,还有可能并没有开启<br>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ceph luminous 新功能之磁盘智能分组]]></title>
    <link href="http://www.zphj1987.com/2017/06/28/ceph-luminous-new-osd-class/"/>
    <id>http://www.zphj1987.com/2017/06/28/ceph-luminous-new-osd-class/</id>
    <published>2017-06-28T07:51:07.000Z</published>
    <updated>2017-06-28T08:50:13.483Z</updated>
    <content type="html"><![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/ssd.png" alt=""><br></center>

<h2 id="前言">前言</h2><p>本篇是luminous一个新功能介绍，关于磁盘智能分组的，这个在ceph里面叫crush class，这个我自己起名叫磁盘智能分组，因为这个实现的功能就是根据磁盘类型进行属性关联，然后进行分类，减少了很多的人为操作</p>
<p>以前我们需要对ssd和hdd进行分组的时候，需要大量的修改crush map，然后绑定不同的存储池到不同的 crush 树上面，现在这个逻辑简化了很多</p>
<a id="more"></a>
<blockquote>
<p>ceph crush class {create,rm,ls} manage the new CRUSH device<br>class feature. ceph crush set-device-class <osd> <class><br>will set the clas for a particular device.</class></osd></p>
<p>Each OSD can now have a device class associated with it (e.g., hdd or<br>ssd), allowing CRUSH rules to trivially map data to a subset of devices<br>in the system. Manually writing CRUSH rules or manual editing of the CRUSH is normally not required.</p>
</blockquote>
<p>这个是发布的公告里面关于这两个功能的说明的，本篇就来看看这个功能怎么用</p>
<h2 id="实践">实践</h2><h3 id="首先创建分类的规则">首先创建分类的规则</h3><p>创建一个ssd的分组<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ceph]<span class="comment"># ceph osd crush class create  ssd</span></span><br><span class="line">created class ssd with id <span class="number">0</span> to crush map</span><br></pre></td></tr></table></figure></p>
<p>也就是一个名称，这里我认为是ssd的分组就创建名词为ssd</p>
<p>再创建一个hdd的分组<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ceph]<span class="comment"># ceph osd crush class create  hdd</span></span><br><span class="line">created class hdd with id <span class="number">1</span> to crush map</span><br></pre></td></tr></table></figure></p>
<h3 id="查询分组规则">查询分组规则</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ceph]<span class="comment"># ceph osd crush class ls</span></span><br><span class="line">[</span><br><span class="line">    <span class="string">"ssd"</span>,</span><br><span class="line">    <span class="string">"hdd"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="把osd绑定不同的属性(属性名称就是上面的分类)">把osd绑定不同的属性(属性名称就是上面的分类)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ceph]<span class="comment"># ceph osd crush set-device-class osd.0  ssd</span></span><br><span class="line"><span class="built_in">set</span>-device-class item id <span class="number">0</span> name <span class="string">'osd.0'</span> device_class ssd</span><br><span class="line">[root@lab8106 ceph]<span class="comment"># ceph osd crush set-device-class osd.2  ssd</span></span><br><span class="line"><span class="built_in">set</span>-device-class item id <span class="number">2</span> name <span class="string">'osd.2'</span> device_class ssd</span><br><span class="line">[root@lab8106 ceph]<span class="comment"># ceph osd crush set-device-class osd.1  hdd</span></span><br><span class="line"><span class="built_in">set</span>-device-class item id <span class="number">1</span> name <span class="string">'osd.1'</span> device_class hdd</span><br><span class="line">[root@lab8106 ceph]<span class="comment"># ceph osd crush set-device-class osd.3  hdd</span></span><br><span class="line"><span class="built_in">set</span>-device-class item id <span class="number">3</span> name <span class="string">'osd.3'</span> device_class hdd</span><br></pre></td></tr></table></figure>
<p>查询设置以后的效果<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ceph]<span class="comment"># ceph osd tree</span></span><br><span class="line">ID WEIGHT  TYPE NAME            UP/DOWN REWEIGHT PRIMARY-AFFINITY </span><br><span class="line">-<span class="number">6</span> <span class="number">0.54559</span> root default~hdd                                       </span><br><span class="line">-<span class="number">5</span> <span class="number">0.54559</span>     host lab8106~hdd                                   </span><br><span class="line"> <span class="number">1</span> <span class="number">0.27280</span>         osd.<span class="number">1</span>             up  <span class="number">1.00000</span>          <span class="number">1.00000</span> </span><br><span class="line"> <span class="number">3</span> <span class="number">0.27280</span>         osd.<span class="number">3</span>             up  <span class="number">1.00000</span>          <span class="number">1.00000</span> </span><br><span class="line">-<span class="number">4</span> <span class="number">0.54559</span> root default~ssd                                       </span><br><span class="line">-<span class="number">3</span> <span class="number">0.54559</span>     host lab8106~ssd                                   </span><br><span class="line"> <span class="number">0</span> <span class="number">0.27280</span>         osd.<span class="number">0</span>             up  <span class="number">1.00000</span>          <span class="number">1.00000</span> </span><br><span class="line"> <span class="number">2</span> <span class="number">0.27280</span>         osd.<span class="number">2</span>             up  <span class="number">1.00000</span>          <span class="number">1.00000</span> </span><br><span class="line">-<span class="number">1</span> <span class="number">1.09119</span> root default                                           </span><br><span class="line">-<span class="number">2</span> <span class="number">1.09119</span>     host lab8106                                       </span><br><span class="line"> <span class="number">0</span> <span class="number">0.27280</span>         osd.<span class="number">0</span>             up  <span class="number">1.00000</span>          <span class="number">1.00000</span> </span><br><span class="line"> <span class="number">1</span> <span class="number">0.27280</span>         osd.<span class="number">1</span>             up  <span class="number">1.00000</span>          <span class="number">1.00000</span> </span><br><span class="line"> <span class="number">2</span> <span class="number">0.27280</span>         osd.<span class="number">2</span>             up  <span class="number">1.00000</span>          <span class="number">1.00000</span> </span><br><span class="line"> <span class="number">3</span> <span class="number">0.27280</span>         osd.<span class="number">3</span>             up  <span class="number">1.00000</span>          <span class="number">1.00000</span></span><br></pre></td></tr></table></figure></p>
<p>这个就是这个功能比较核心的地方，会根据磁盘类型不同，自动的创建了不同的树，并且把磁盘放入到了树里面去了</p>
<h3 id="根据根创建规则（这个地方有bug，下面会提及）">根据根创建规则（这个地方有bug，下面会提及）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ceph]<span class="comment"># ceph osd crush rule create-simple ssd default~ssd host firstn</span></span><br></pre></td></tr></table></figure>
<p>检查创建的rule规则：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 build]<span class="comment"># ceph   osd  crush rule  dump ssd</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"rule_id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"rule_name"</span>: <span class="string">"ssd"</span>,</span><br><span class="line">    <span class="string">"ruleset"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"min_size"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"max_size"</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="string">"steps"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"op"</span>: <span class="string">"take"</span>,</span><br><span class="line">            <span class="string">"item"</span>: -<span class="number">4</span>,</span><br><span class="line">            <span class="string">"item_name"</span>: <span class="string">"default~ssd"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"op"</span>: <span class="string">"chooseleaf_firstn"</span>,</span><br><span class="line">            <span class="string">"num"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"host"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"op"</span>: <span class="string">"emit"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="根据rule创建存储池">根据rule创建存储池</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph  osd pool create testpool <span class="number">64</span> <span class="number">64</span> ssd</span><br><span class="line">ceph   osd dump|grep pool</span><br><span class="line">pool <span class="number">3</span> <span class="string">'testpool'</span> replicated size <span class="number">3</span> min_size <span class="number">1</span> crush_rule <span class="number">1</span> object_<span class="built_in">hash</span> rjenkins pg_num <span class="number">64</span> pgp_num <span class="number">64</span> last_change <span class="number">27</span> flags hashpspool stripe_width <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这里有个验证规则的小bug  代码在src/mon/MonCommands.h<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> COMMAND(<span class="string">"osd crush rule create-simple "</span> \</span><br><span class="line"><span class="string">"name=name,type=CephString,goodchars=[A-Za-z0-9-_.] "</span> \</span><br><span class="line"><span class="string">"name=root,type=CephString,goodchars=[A-Za-z0-9-_.] "</span> \</span><br><span class="line"><span class="string">"name=type,type=CephString,goodchars=[A-Za-z0-9-_.] "</span> \</span><br></pre></td></tr></table></figure></p>
<p>默认的goodchars不包含’~’,这里不清楚社区是准备去改创建的逻辑去掉这个特殊符号，还是去改创建rule相关的规则，我已经提交了<a href="http://tracker.ceph.com/issues/20446" target="_blank" rel="external">issue#20446</a>，等待社区的修改方案</p>
<h2 id="功能逻辑">功能逻辑</h2><h3 id="现在方法">现在方法</h3><p>创建一个磁盘类型的class，给磁盘标记class的统一标签，自动会根据class的类型创建一个树，根据树创建rule，根据rule创建存储池，整个操作没有动crushmap的操作</p>
<p>增加或修改盘的时候，设置下属性即可</p>
<h3 id="以前的方法">以前的方法</h3><p>先添加盘，手动创建树，新加的osd要找下原来的树的名称，然后把osd放到这个树里面去，然后创建规则，根据rule创建存储池</p>
<p>增加盘或修改盘的时候，需要查找下，然后根据查找的规则进行相关操作</p>
<h2 id="总结">总结</h2><p>现在方法对用户操作来说更透明，直接对磁盘进行分类打标签即可，减少了一些复杂的操作逻辑，是一个很不错的功能</p>
<h2 id="更新">更新</h2><p>后面会在crush rule创建的时候指定一个class的选项，就可以不改规则，也不改命令了<br><a href="https://www.spinics.net/lists/ceph-devel/msg37343.html，下个版本的rc应该会解决" target="_blank" rel="external">https://www.spinics.net/lists/ceph-devel/msg37343.html，下个版本的rc应该会解决</a></p>
<h2 id="变更记录">变更记录</h2><table>
<thead>
<tr>
<th style="text-align:center">Why</th>
<th style="text-align:center">Who</th>
<th style="text-align:center">When</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建</td>
<td style="text-align:center">武汉-运维-磨渣</td>
<td style="text-align:center">2017-06-28</td>
</tr>
<tr>
<td style="text-align:center">更新进度</td>
<td style="text-align:center">武汉-运维-磨渣</td>
<td style="text-align:center">2017-06-28</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/ssd.png" alt=""><br></center>

<h2 id="前言">前言</h2><p>本篇是luminous一个新功能介绍，关于磁盘智能分组的，这个在ceph里面叫crush class，这个我自己起名叫磁盘智能分组，因为这个实现的功能就是根据磁盘类型进行属性关联，然后进行分类，减少了很多的人为操作</p>
<p>以前我们需要对ssd和hdd进行分组的时候，需要大量的修改crush map，然后绑定不同的存储池到不同的 crush 树上面，现在这个逻辑简化了很多</p>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ceph luminous 新功能之内置dashboard]]></title>
    <link href="http://www.zphj1987.com/2017/06/25/ceph-luminous-new-dashboard/"/>
    <id>http://www.zphj1987.com/2017/06/25/ceph-luminous-new-dashboard/</id>
    <published>2017-06-25T15:59:44.000Z</published>
    <updated>2017-06-25T16:11:37.681Z</updated>
    <content type="html"><![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/dashboard.jpg" alt=""><br></center>

<h2 id="前言">前言</h2><p>ceph luminous版本新增加了很多有意思的功能，这个也是一个长期支持版本，所以这些新功能的特性还是很值得期待的，从底层的存储改造，消息方式的改变，以及一些之前未实现的功能的完成，都让ceph变得更强，这里面有很多核心模块来自中国的开发者，在这里准备用一系列的文章对这些新功能进行一个简单的介绍，也是自己的一个学习的过程</p>
<a id="more"></a>
<h2 id="相关配置">相关配置</h2><h3 id="配置ceph国内源">配置ceph国内源</h3><p>修改 /etc/yum.repos.d/ceph.repo文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ceph]</span><br><span class="line">name=ceph</span><br><span class="line">baseurl=http://mirrors.<span class="number">163</span>.com/ceph/rpm-luminous/el7/x86_64/</span><br><span class="line">gpgcheck=<span class="number">0</span></span><br><span class="line">[ceph-noarch]</span><br><span class="line">name=cephnoarch</span><br><span class="line">baseurl=http://mirrors.<span class="number">163</span>.com/ceph/rpm-luminous/el7/noarch/</span><br><span class="line">gpgcheck=<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>添加完更新下缓存<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum makecache</span><br></pre></td></tr></table></figure></p>
<p>前一段时间163源上的ceph没有了，可能是误操作的，现在的163源已经恢复，上面添加的是最新的luminous版本源，本篇实践的功能是在这个版本才加入的</p>
<h3 id="安装ceph相关软件包">安装ceph相关软件包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># yum install ceph-deploy ceph</span></span><br></pre></td></tr></table></figure>
<p>检查版本<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># ceph -v</span></span><br><span class="line">ceph version <span class="number">12.1</span>.<span class="number">0</span> (<span class="number">262617</span>c9f16c55e863693258061c5b25dea5b086) luminous (dev)</span><br></pre></td></tr></table></figure></p>
<h3 id="搭建一个集群">搭建一个集群</h3><p>这个就不描述配置集群的步骤，这个网上很多资料，也是很基础的操作<br>这里提几个luminous重要的变化</p>
<ul>
<li>默认的消息处理从simple变成了async了（ms_type = async+posix）</li>
<li>默认的后端存储从filestore变成了bluestore了</li>
<li>ceph-s的命令的输出发生了改变(显示如下)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ceph]<span class="comment"># ceph -s</span></span><br><span class="line">  cluster:</span><br><span class="line">    id:     <span class="number">49</span>ee8a7f-fb7c-<span class="number">4239</span><span class="operator">-a</span>4b7-acf0bc37430d</span><br><span class="line">    health: HEALTH_OK</span><br><span class="line"> </span><br><span class="line">  services:</span><br><span class="line">    mon: <span class="number">1</span> daemons, quorum lab8106</span><br><span class="line">    mgr: lab8106(active)</span><br><span class="line">    osd: <span class="number">2</span> osds: <span class="number">2</span> up, <span class="number">2</span> <span class="keyword">in</span></span><br><span class="line"> </span><br><span class="line">  data:</span><br><span class="line">    pools:   <span class="number">1</span> pools, <span class="number">64</span> pgs</span><br><span class="line">    objects: <span class="number">0</span> objects, <span class="number">0</span> bytes</span><br><span class="line">    usage:   <span class="number">2110</span> MB used, <span class="number">556</span> GB / <span class="number">558</span> GB avail</span><br><span class="line">    pgs:     <span class="number">64</span> active+clean</span><br></pre></td></tr></table></figure>
<h3 id="开启监控模块">开启监控模块</h3><p>在/etc/ceph/ceph.conf中添加<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mgr]</span><br><span class="line">mgr modules = dashboard</span><br></pre></td></tr></table></figure></p>
<p>设置dashboard的ip和端口<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph config-key put mgr/dashboard/server_addr <span class="number">192.168</span>.<span class="number">8.106</span></span><br><span class="line">ceph config-key put mgr/dashboard/server_port <span class="number">7000</span></span><br></pre></td></tr></table></figure></p>
<p>这个从代码上看应该是可以支持配置文件方式的设置，目前还没看到具体的文档，先按这个设置即可，默认的端口是7000</p>
<p>重启mgr服务<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ceph]<span class="comment"># systemctl restart ceph-mgr@lab8106</span></span><br></pre></td></tr></table></figure></p>
<p>检查端口<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ceph]<span class="comment"># netstat -tunlp|grep 7000</span></span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">192.168</span>.<span class="number">8.106</span>:<span class="number">7000</span>      <span class="number">0.0</span>.<span class="number">0.0</span>:*               LISTEN      <span class="number">31485</span>/ceph-mgr</span><br></pre></td></tr></table></figure></p>
<h3 id="访问界面">访问界面</h3><p><img src="http://static.zybuluo.com/zphj1987/i7i3e911qxjqvw8pqnieyb27/image.png" alt="dashboard"><br>这个是首页的信息</p>
<p><img src="http://static.zybuluo.com/zphj1987/a729siz4lhuhgufycx354dqx/image.png" alt="image.png-137.3kB"><br>如果配置了cephfs文件系统后，会有这个文件系统相关的监控</p>
<p><img src="http://static.zybuluo.com/zphj1987/l5qwg9wwkhdh7rfcznl1zvjv/image.png" alt="servers"><br>这个界面是显示的主机的信息的</p>
<h2 id="总结">总结</h2><p>从部署方便性来说，这个部署还是非常的方便的，而且走的是ceph原生接口，ceph通过增加一个mgr模块，可以把一些管理的功能独立出来，从而让mon自己做最重要的一些事情</p>
<p>目前的监控功能还比较少，主要是监控功能，未来应该会慢慢增加更多的功能，从产品角度来看，一个原生的UI监控使得ceph整个模块更加的完整了</p>
<p>有的时候也许 simple is the best</p>
<h2 id="参考资料">参考资料</h2><p>/usr/lib64/ceph/mgr/dashboard/README.rst</p>
<h2 id="变更记录">变更记录</h2><table>
<thead>
<tr>
<th style="text-align:center">Why</th>
<th style="text-align:center">Who</th>
<th style="text-align:center">When</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建</td>
<td style="text-align:center">武汉-运维-磨渣</td>
<td style="text-align:center">2017-06-26</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/dashboard.jpg" alt=""><br></center>

<h2 id="前言">前言</h2><p>ceph luminous版本新增加了很多有意思的功能，这个也是一个长期支持版本，所以这些新功能的特性还是很值得期待的，从底层的存储改造，消息方式的改变，以及一些之前未实现的功能的完成，都让ceph变得更强，这里面有很多核心模块来自中国的开发者，在这里准备用一系列的文章对这些新功能进行一个简单的介绍，也是自己的一个学习的过程</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[调整PG分多次调整和一次到位的迁移差别分析]]></title>
    <link href="http://www.zphj1987.com/2017/06/14/different-change-pg/"/>
    <id>http://www.zphj1987.com/2017/06/14/different-change-pg/</id>
    <published>2017-06-14T05:39:26.000Z</published>
    <updated>2017-06-14T05:41:18.539Z</updated>
    <content type="html"><![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/diff.png" alt="different"><br></center>

<h2 id="前言">前言</h2><p>这个问题来源于我们研发的一个问题，在进行pg调整的时候，是一次调整到位好，还是分多次调整比较好，分多次调整的时候会不会出现某个pg反复挪动的问题，造成整体迁移量大于一次调整的</p>
<p>最近自己的项目上也有pg调整的需求，这个需求一般来源于pg规划好了，后期出现节点扩容的情况，需要对pg进行增加的调整</p>
<p>本篇用具体的数据来分析两种方式的差别</p>
<p>因为本篇的篇幅较长，直接先把结论拿出来<br><a id="more"></a></p>
<h2 id="数据结论">数据结论</h2><table>
<thead>
<tr>
<th style="text-align:center">调整pg</th>
<th style="text-align:center">迁移pg</th>
<th style="text-align:center">迁移对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1200-&gt;1440</td>
<td style="text-align:center">460</td>
<td style="text-align:center">27933</td>
</tr>
<tr>
<td style="text-align:center">1440-&gt;1680</td>
<td style="text-align:center">458</td>
<td style="text-align:center">27730</td>
</tr>
<tr>
<td style="text-align:center">1680-&gt;1920</td>
<td style="text-align:center">465</td>
<td style="text-align:center">27946</td>
</tr>
<tr>
<td style="text-align:center">1920-&gt;2160</td>
<td style="text-align:center">457</td>
<td style="text-align:center">21141</td>
</tr>
<tr>
<td style="text-align:center">2160-&gt;2400</td>
<td style="text-align:center">458</td>
<td style="text-align:center">13938</td>
</tr>
<tr>
<td style="text-align:center">总和</td>
<td style="text-align:center">2305</td>
<td style="text-align:center">132696</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">调整pg</th>
<th style="text-align:center">迁移pg</th>
<th style="text-align:center">迁移对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1200-&gt;2400</td>
<td style="text-align:center">2299</td>
<td style="text-align:center">115361</td>
</tr>
</tbody>
</table>
<p>结论：<br>分多次调整的时候，PG迁移量比一次调整多了6个，多了0.2%，对象的迁移量多了17335，多了15%</p>
<p>从数据上看pg迁移的数目基本一样，但是数据量是多了15%，这个是因为分多次迁移的时候，在pg基数比较小的时候，迁移一个pg里面的对象要比后期分裂以后的对象要多，就产生了这个数据量的差别</p>
<p>从整体上来看二者需要迁移的pg基本差不多，数据量上面会增加15%，分多次的时候是可以进行周期性调整的，拆分到不同的时间段来做，所以各有好处</p>
<h2 id="实践">实践</h2><h3 id="环境准备">环境准备</h3><p>本次测试采用的是开发环境，使用开发环境可以很快的部署一个需要的环境，本次分析采用的就是一台机器模拟的4台机器48个 4T osd的环境</p>
<h4 id="环境搭建">环境搭建</h4><p>生成集群<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./vstart.sh -n  --mon_num <span class="number">1</span> --osd_num <span class="number">48</span> --mds_num <span class="number">1</span> --short  <span class="operator">-d</span></span><br></pre></td></tr></table></figure></p>
<p>后续操作都在源码的src目录下面执行</p>
<p>设置存储池副本为2</p>
<p>修改crush weight 为3.7模拟4T盘<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">seq <span class="number">0</span> <span class="number">47</span>| xargs -i ./ceph -c ceph.conf osd crush reweight osd.&#123;&#125; <span class="number">3.8</span></span><br></pre></td></tr></table></figure></p>
<p>模拟主机分组<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">seq <span class="number">0</span> <span class="number">11</span> |xargs -i ./ceph -c ceph.conf osd crush <span class="built_in">set</span> osd.&#123;&#125; <span class="number">3.8</span> host=lab8106 root=default</span><br><span class="line">seq <span class="number">12</span> <span class="number">23</span> |xargs -i ./ceph -c ceph.conf osd crush <span class="built_in">set</span> osd.&#123;&#125; <span class="number">3.8</span> host=lab8107 root=default</span><br><span class="line">seq <span class="number">24</span> <span class="number">35</span> |xargs -i ./ceph -c ceph.conf osd crush <span class="built_in">set</span> osd.&#123;&#125; <span class="number">3.8</span> host=lab8108 root=default</span><br><span class="line">seq <span class="number">36</span> <span class="number">47</span> |xargs -i ./ceph -c ceph.conf osd crush <span class="built_in">set</span> osd.&#123;&#125; <span class="number">3.8</span> host=lab8109 root=default</span><br></pre></td></tr></table></figure></p>
<p>48个osd设置初始pg为1200，让每个osd上面差不多50个pg左右，做一下均衡操作，后续目标调整为pg为2400</p>
<p>准备120000个小文件准备put进去集群，使每个pg上面对象100个左右<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./rados -c ceph.conf -p rbd bench -b <span class="number">1</span>K <span class="number">600</span> write --no-cleanup</span><br></pre></td></tr></table></figure></p>
<h3 id="一次调整pg到2400">一次调整pg到2400</h3><p>统计一次调整到位的情况下的数据迁移情况<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ceph  -c ceph.conf  osd pool <span class="built_in">set</span> rbd pg_num <span class="number">2400</span></span><br></pre></td></tr></table></figure></p>
<p>记录当前的pg分布的情况<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ceph -c ceph.conf pg dump pgs|awk <span class="string">'&#123;print $1,$2,$15,$17&#125;'</span> &gt; pgmappg_1200_pgp_2400</span><br></pre></td></tr></table></figure></p>
<p>调整存储池的pgp为2400<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ceph -c ceph.conf osd pool <span class="built_in">set</span> rbd  pgp_num <span class="number">2400</span></span><br></pre></td></tr></table></figure></p>
<p>等迁移完成以后，统计最终的pg分布情况<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ceph -c ceph.conf pg dump pgs|awk <span class="string">'&#123;print $1,$2,$15,$17&#125;'</span> &gt; pgmappg2400_pgp2400</span><br></pre></td></tr></table></figure></p>
<p>这里说明一下，调整pg的时候只会触发pg的分裂，并不会影响集群的分布，也就是不会出现pg迁移的情况，调整pgp以后才会去改变pg的分布，所以本次数据分析统计的是pgp变动后的迁移的数据量，这个量才是集群的真正的迁移量</p>
<p>用比较的脚本来进行统计（脚本会在本文文末提供）<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 src]<span class="comment">#python compair.py pgmappg_1200_pgp_2400 pgmappg2400_pgp2400</span></span><br><span class="line">| pgs | objects |</span><br><span class="line">-----------------</span><br><span class="line">[<span class="number">2299</span>, <span class="number">115361</span>]</span><br></pre></td></tr></table></figure></p>
<p>也就是整个环境有2299次pg的变动，总共迁移的对象数目为115361个</p>
<h3 id="分五次调整到2400PG">分五次调整到2400PG</h3><h4 id="初始pg为1200个第一次调整，1200PG调整到1440PG">初始pg为1200个第一次调整，1200PG调整到1440PG</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ceph -c ceph.conf osd pool <span class="built_in">set</span> rbd pg_num <span class="number">1440</span></span><br></pre></td></tr></table></figure>
<p>调整pg为1440,当前pgp为1200<br>记录当前的pg分布数据<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ceph -c ceph.conf pg dump pgs|awk <span class="string">'&#123;print $1,$2,$15,$17&#125;'</span> &gt; pgmappaira1</span><br></pre></td></tr></table></figure></p>
<p>调整pgp为1440,当前pg为1440<br>记录当前的pg分布数据<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ceph -c ceph.conf pg dump pgs|awk <span class="string">'&#123;print $1,$2,$15,$17&#125;'</span> &gt; pgmappaira2</span><br></pre></td></tr></table></figure></p>
<p>统计第一次调整后的迁移量<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 pgdata]<span class="comment"># python compair.py pgmappaira1 pgmappaira2</span></span><br><span class="line">| pgs | objects |</span><br><span class="line">-----------------</span><br><span class="line">[<span class="number">460</span>, <span class="number">27933</span>]</span><br></pre></td></tr></table></figure></p>
<h4 id="第二次调整，1440PG调整到1680PG">第二次调整，1440PG调整到1680PG</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ceph -c ceph.conf osd pool <span class="built_in">set</span> rbd pg_num <span class="number">1680</span></span><br></pre></td></tr></table></figure>
<p>调整pg为1680,当前pgp为1440<br>记录当前的pg分布数据<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ceph -c ceph.conf pg dump pgs|awk <span class="string">'&#123;print $1,$2,$15,$17&#125;'</span> &gt; pgmappairb1</span><br></pre></td></tr></table></figure></p>
<p>调整pgp为1680,当前pg为1680<br>记录当前的pg分布数据<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ceph -c ceph.conf pg dump pgs|awk <span class="string">'&#123;print $1,$2,$15,$17&#125;'</span> &gt; pgmappairb2</span><br></pre></td></tr></table></figure></p>
<p>统计第二次调整后的迁移量<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 pgdata]<span class="comment"># python compair.py pgmappairb1 pgmappairb2</span></span><br><span class="line">| pgs | objects |</span><br><span class="line">-----------------</span><br><span class="line">[<span class="number">458</span>, <span class="number">27730</span>]</span><br></pre></td></tr></table></figure></p>
<h4 id="第三次调整，1680PG调整到1920PG">第三次调整，1680PG调整到1920PG</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ceph -c ceph.conf osd pool <span class="built_in">set</span> rbd pg_num <span class="number">1920</span></span><br></pre></td></tr></table></figure>
<p>调整pg为1920,当前pgp为1680<br>记录当前的pg分布数据<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ceph -c ceph.conf pg dump pgs|awk <span class="string">'&#123;print $1,$2,$15,$17&#125;'</span> &gt; pgmappairc1</span><br></pre></td></tr></table></figure></p>
<p>调整pgp为1920,当前pg为1920<br>记录当前的pg分布数据<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ceph -c ceph.conf pg dump pgs|awk <span class="string">'&#123;print $1,$2,$15,$17&#125;'</span> &gt; pgmappairc2</span><br></pre></td></tr></table></figure></p>
<p>统计第三次调整后的迁移量<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 pgdata]<span class="comment"># python compair.py  pgmappairc1 pgmappairc2</span></span><br><span class="line">| pgs | objects |</span><br><span class="line">-----------------</span><br><span class="line">[<span class="number">465</span>, <span class="number">27946</span>]</span><br></pre></td></tr></table></figure></p>
<h4 id="第四次调整，1920PG调整到2160PG">第四次调整，1920PG调整到2160PG</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ceph -c ceph.conf osd pool <span class="built_in">set</span> rbd pg_num <span class="number">2160</span></span><br></pre></td></tr></table></figure>
<p>调整pg为2160,当前pgp为1920<br>记录当前的pg分布数据<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ceph -c ceph.conf pg dump pgs|awk <span class="string">'&#123;print $1,$2,$15,$17&#125;'</span> &gt; pgmappaird1</span><br></pre></td></tr></table></figure></p>
<p>调整pgp为2160,当前pg为2160<br>记录当前的pg分布数据<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ceph -c ceph.conf pg dump pgs|awk <span class="string">'&#123;print $1,$2,$15,$17&#125;'</span> &gt; pgmappaird2</span><br></pre></td></tr></table></figure></p>
<p>统计第四次调整后的迁移量<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 pgdata]<span class="comment"># python compair.py pgmappaird1 pgmappaird2</span></span><br><span class="line">| pgs | objects |</span><br><span class="line">-----------------</span><br><span class="line">[<span class="number">457</span>, <span class="number">21141</span>]</span><br></pre></td></tr></table></figure></p>
<h4 id="第五次调整，2160PG调整到2400PG">第五次调整，2160PG调整到2400PG</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ceph -c ceph.conf osd pool <span class="built_in">set</span> rbd pg_num <span class="number">2400</span></span><br></pre></td></tr></table></figure>
<p>调整pg为2400,当前pgp为2160<br>记录当前的pg分布数据<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ceph -c ceph.conf pg dump pgs|awk <span class="string">'&#123;print $1,$2,$15,$17&#125;'</span> &gt; pgmappaire1</span><br></pre></td></tr></table></figure></p>
<p>调整pgp为2400,当前pg为2400<br>记录当前的pg分布数据<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./ceph -c ceph.conf pg dump pgs|awk <span class="string">'&#123;print $1,$2,$15,$17&#125;'</span> &gt; pgmappaire2</span><br></pre></td></tr></table></figure></p>
<p>统计第五次调整后的迁移量<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 pgdata]<span class="comment"># python compair.py pgmappaire1 pgmappaire2</span></span><br><span class="line">| pgs | objects |</span><br><span class="line">-----------------</span><br><span class="line">[<span class="number">458</span>, <span class="number">13938</span>]</span><br></pre></td></tr></table></figure></p>
<p>上面五次加起来的总量为<br>2305 PGS    132696 objects</p>
<h2 id="统计的脚本">统计的脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"> <span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">__author__ =<span class="string">"zp"</span></span><br><span class="line">import os,sys</span><br><span class="line"></span><br><span class="line">class filetojson(object):</span><br><span class="line">    def __init__(self,orin,new):</span><br><span class="line">        self.origin=orin</span><br><span class="line">        self.new=new</span><br><span class="line"></span><br><span class="line">    def tojson(self,filename):</span><br><span class="line">        data=&#123;&#125;</span><br><span class="line">        pginfo=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> open(filename):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"pg_stat"</span> <span class="keyword">in</span> line:</span><br><span class="line">                <span class="built_in">continue</span></span><br><span class="line">            lines=line.split()</span><br><span class="line">            pg=lines[<span class="number">0</span>]</span><br><span class="line">            objects=lines[<span class="number">1</span>]</span><br><span class="line">            withosd=lines[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">            data[pg]=&#123;<span class="string">'objects'</span>:objects,<span class="string">'osd'</span>:list(<span class="built_in">eval</span>(withosd))&#125;</span><br><span class="line">        <span class="built_in">return</span> data</span><br><span class="line"></span><br><span class="line">    def compare(self):</span><br><span class="line">        movepg=<span class="number">0</span></span><br><span class="line">        allmovepg=<span class="number">0</span></span><br><span class="line">        allmoveobject=<span class="number">0</span></span><br><span class="line">        moveobject=<span class="number">0</span></span><br><span class="line">        oringinmap=self.tojson(self.origin)</span><br><span class="line">        newmap=self.tojson(self.new)</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> oringinmap:</span><br><span class="line">            amapn=<span class="built_in">set</span>(oringinmap[key][<span class="string">'osd'</span>])</span><br><span class="line">            bmapn=<span class="built_in">set</span>(newmap[key][<span class="string">'osd'</span>])</span><br><span class="line">            movepg=len(list(amapn.difference(bmapn)))</span><br><span class="line">            <span class="keyword">if</span> movepg != <span class="number">0</span>:</span><br><span class="line">                moveobject=int(oringinmap[key][<span class="string">'objects'</span>]) * int(movepg)</span><br><span class="line">                allmovepg=allmovepg+movepg</span><br><span class="line">                allmoveobject=allmoveobject+moveobject</span><br><span class="line">        <span class="built_in">return</span> [allmovepg,allmoveobject]</span><br><span class="line"></span><br><span class="line">mycom=filetojson(sys.argv[<span class="number">1</span>],sys.argv[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span> <span class="string">"| pgs | objects |"</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">"-----------------"</span></span><br><span class="line"><span class="built_in">print</span> mycom.compare()</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2><p>本篇是对集群进行pg调整的这个场景下迁移的数据进行分析的，对于一个集群来说，还是要用数据来进行问题的说明会比较有说服力，凭感觉还是没有那么强的说服力，本篇因为环境所限，所以在模拟的时候采用的是单个pg100个对象的样本，如果需要更精确的数据可以采用多次测试，并且加大这个单个pg的对象数目</p>
<h2 id="变更记录">变更记录</h2><table>
<thead>
<tr>
<th style="text-align:center">Why</th>
<th style="text-align:center">Who</th>
<th style="text-align:center">When</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建</td>
<td style="text-align:center">武汉-运维-磨渣</td>
<td style="text-align:center">2017-06-14</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/diff.png" alt="different"><br></center>

<h2 id="前言">前言</h2><p>这个问题来源于我们研发的一个问题，在进行pg调整的时候，是一次调整到位好，还是分多次调整比较好，分多次调整的时候会不会出现某个pg反复挪动的问题，造成整体迁移量大于一次调整的</p>
<p>最近自己的项目上也有pg调整的需求，这个需求一般来源于pg规划好了，后期出现节点扩容的情况，需要对pg进行增加的调整</p>
<p>本篇用具体的数据来分析两种方式的差别</p>
<p>因为本篇的篇幅较长，直接先把结论拿出来<br>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用日志系统graylog获取Ceph集群状态]]></title>
    <link href="http://www.zphj1987.com/2017/06/09/use-graylog-get-Ceph-status/"/>
    <id>http://www.zphj1987.com/2017/06/09/use-graylog-get-Ceph-status/</id>
    <published>2017-06-09T08:30:56.000Z</published>
    <updated>2017-07-13T03:22:31.448Z</updated>
    <content type="html"><![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/graylog.png" alt=""><br></center>

<h2 id="前言">前言</h2><p>在看集群的配置文件的时候看到ceph里面有一个graylog的输出选择，目前看到的是可以收集mon日志和clog，osd单个的日志没有看到，Elasticsearch有整套的日志收集系统，可以很方便的将所有日志汇总到一起，这个graylog的收集采用的是自有的udp协议，从配置上来说可以很快的完成，这里只做一个最基本的实践<br><a id="more"></a></p>
<h2 id="系统实践">系统实践</h2><p>graylog日志系统主要由三个组件组成的</p>
<ul>
<li>MongoDB – 存储配置信息和一些元数据信息的，MongoDB (&gt;= 2.4)</li>
<li>Elasticsearch – 用来存储Graylog server收取的log messages的，Elasticsearch (&gt;= 2.x)</li>
<li>Graylog server – 用来解析日志的并且提供内置的web的访问接口</li>
</ul>
<p>配置好基础源文件</p>
<blockquote>
<p>CentOS-Base.repo<br>epel.repo</p>
</blockquote>
<h3 id="安装java">安装java</h3><p>要求版本Java (&gt;= 8)<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install java-<span class="number">1.8</span>.<span class="number">0</span>-openjdk</span><br></pre></td></tr></table></figure></p>
<h3 id="安装MongoDB">安装MongoDB</h3><p>安装软件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install mongodb mongodb-server</span><br></pre></td></tr></table></figure></p>
<p>启动服务并且加入自启动<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart mongod</span><br><span class="line">systemctl <span class="built_in">enable</span> mongod</span><br></pre></td></tr></table></figure></p>
<p>安装完成检查服务启动端口<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab102 ~]<span class="comment"># netstat -tunlp|grep 27017</span></span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">27017</span>         <span class="number">0.0</span>.<span class="number">0.0</span>:*               LISTEN      <span class="number">151840</span>/mongod</span><br></pre></td></tr></table></figure></p>
<h3 id="安装Elasticsearch">安装Elasticsearch</h3><p>倒入认证文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm --import https://packages.elastic.co/GPG-KEY-elasticsearch</span><br></pre></td></tr></table></figure></p>
<p>添加源文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/yum.repos.d/elasticsearch.repo</span><br><span class="line">添加</span><br><span class="line">[elasticsearch-<span class="number">2</span>.x]</span><br><span class="line">name=Elasticsearch repository <span class="keyword">for</span> <span class="number">2</span>.x packages</span><br><span class="line">baseurl=https://packages.elastic.co/elasticsearch/<span class="number">2</span>.x/centos</span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=https://packages.elastic.co/GPG-KEY-elasticsearch</span><br><span class="line">enabled=<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>安装elasticsearch包<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install elasticsearch</span><br></pre></td></tr></table></figure></p>
<p>配置自启动<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> elasticsearch</span><br></pre></td></tr></table></figure></p>
<p>修改配置文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim /etc/elasticsearch/elasticsearch.yml</span></span><br><span class="line"></span><br><span class="line">cluster.name: graylog</span><br></pre></td></tr></table></figure></p>
<p>重启服务<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart  elasticsearch</span><br></pre></td></tr></table></figure></p>
<p>检查运行服务端口<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab102 ~]<span class="comment"># netstat -tunlp|grep java</span></span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9200</span>          <span class="number">0.0</span>.<span class="number">0.0</span>:*               LISTEN      <span class="number">154116</span>/java </span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9300</span>          <span class="number">0.0</span>.<span class="number">0.0</span>:*               LISTEN      <span class="number">154116</span>/java</span><br></pre></td></tr></table></figure></p>
<p>检查elasticsearch状态<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab102 ~]<span class="comment">#  curl -X GET http://localhost:9200</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span> : <span class="string">"Vibro"</span>,</span><br><span class="line">  <span class="string">"cluster_name"</span> : <span class="string">"graylog"</span>,</span><br><span class="line">  <span class="string">"cluster_uuid"</span> : <span class="string">"11Y2GOTmQ9ynNbTlruFcyA"</span>,</span><br><span class="line">  <span class="string">"version"</span> : &#123;</span><br><span class="line">    <span class="string">"number"</span> : <span class="string">"2.4.5"</span>,</span><br><span class="line">    <span class="string">"build_hash"</span> : <span class="string">"c849dd13904f53e63e88efc33b2ceeda0b6a1276"</span>,</span><br><span class="line">    <span class="string">"build_timestamp"</span> : <span class="string">"2017-04-24T16:18:17Z"</span>,</span><br><span class="line">    <span class="string">"build_snapshot"</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"lucene_version"</span> : <span class="string">"5.5.4"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"tagline"</span> : <span class="string">"You Know, for Search"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab102 ~]<span class="comment"># curl -XGET 'http://localhost:9200/_cluster/health?pretty=true'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"cluster_name"</span> : <span class="string">"graylog"</span>,</span><br><span class="line">  <span class="string">"status"</span> : <span class="string">"green"</span>,</span><br></pre></td></tr></table></figure>
<p>状态应该是green</p>
<h3 id="安装graylog">安装graylog</h3><p>安装源<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -Uvh https://packages.graylog2.org/repo/packages/graylog-<span class="number">2.2</span>-repository_latest.rpm</span><br></pre></td></tr></table></figure></p>
<p>安装软件包<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install graylog-server pwgen</span><br></pre></td></tr></table></figure></p>
<p>生成password_secret<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab102 ~]<span class="comment"># pwgen -N 1 -s 96</span></span><br><span class="line">DoqTYuvQPHaNW6XGFj5jru3FH8qxMjehj7Xk9OaVxhxaLYphF871CyiCMOKuAsHsJc0DtUUkK3ioFeqYo73mkMDUN7YklqgS</span><br></pre></td></tr></table></figure></p>
<p>在配置文件/etc/graylog/server/server.conf中password_secret填上上面的输出</p>
<p>生成root_password_sha2（后面生成的-不需要）<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab102 ~]<span class="comment"># echo -n 123456 |shasum -a 256</span></span><br><span class="line"><span class="number">8</span>d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92  -</span><br></pre></td></tr></table></figure></p>
<p>123456是我设置的密码<br>在配置文件/etc/graylog/server/server.conf中root_password_sha2填上上面的输出</p>
<p>设置时区<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root_timezone = Asia/Shanghai</span><br></pre></td></tr></table></figure></p>
<p>配置web监听端口<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rest_listen_uri = http://<span class="number">192.168</span>.<span class="number">10.2</span>:<span class="number">9000</span>/api/</span><br><span class="line">web_listen_uri = http://<span class="number">192.168</span>.<span class="number">10.2</span>:<span class="number">9000</span>/</span><br></pre></td></tr></table></figure></p>
<p>这里注意写上你的web准备使用的那个网卡的IP地址，不要全局监听</p>
<p>启动服务并配置自启动<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab102 ~]<span class="comment"># systemctl restart graylog-server</span></span><br><span class="line">[root@lab102 ~]<span class="comment"># systemctl enable graylog-server</span></span><br></pre></td></tr></table></figure></p>
<p>检查服务端口<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab102 ~]<span class="comment"># netstat -tunlp|grep 9000</span></span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">192.168</span>.<span class="number">10.2</span>:<span class="number">9000</span>       <span class="number">0.0</span>.<span class="number">0.0</span>:*               LISTEN      <span class="number">160129</span>/java</span><br></pre></td></tr></table></figure></p>
<h3 id="使用web进行访问">使用web进行访问</h3><p>使用地址<a href="http://192.168.10.2:9000进行访问" target="_blank" rel="external">http://192.168.10.2:9000进行访问</a><br><img src="http://static.zybuluo.com/zphj1987/c07fkvdhinqn3ewzg0slxc44/image.png" alt="image.png-312kB"><br>用户名admin<br>密码123456</p>
<p><img src="http://static.zybuluo.com/zphj1987/6nvvez8axru9djfrn4iyx4hj/image.png" alt="image.png-69.9kB"><br>进来就是引导界面，这个地方是<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">1、把日志发送到graylog</span><br><span class="line">2、对收集到的数据做点搜索</span><br><span class="line">3、创建一个图表</span><br><span class="line">4、创建告警</span><br></pre></td></tr></table></figure></p>
<p>到这里配置graylog平台的基础工作就完成了，现在看下怎么跟ceph对接</p>
<p><img src="http://static.zybuluo.com/zphj1987/d2rbv3q5mfwvhkrqrf0bfyvc/image.png" alt="image.png-38.6kB"></p>
<h2 id="配置ceph的支持">配置ceph的支持</h2><p>日志从ceph里面输出是采用的GELF UDP方式的</p>
<p>GELF is Graylog2 的json格式的数据，内部采用键值对的方式，ceoh内部传输出来的数据不光有message还有下面的</p>
<ul>
<li>hostname</li>
<li>thread id</li>
<li>priority</li>
<li>subsystem name and id</li>
<li>fsid</li>
</ul>
<p><img src="http://static.zybuluo.com/zphj1987/0p2lgnam8tq0mn9ebcturx6i/image.png" alt="image.png-68.5kB"></p>
<p>选择GELF UDP协议 </p>
<p><img src="http://static.zybuluo.com/zphj1987/r5yibecnxsp04vo5hw8iboj2/image.png" alt="image.png-77.1kB"></p>
<p>选择节点，配置监听端口为12201，保存</p>
<p>在lab102上检查端口的监听情况<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab102 ~]<span class="comment"># netstat -tunlp|grep 12201</span></span><br><span class="line">udp        <span class="number">0</span>      <span class="number">0</span> <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">12201</span>           <span class="number">0.0</span>.<span class="number">0.0</span>:*                           <span class="number">160129</span>/java</span><br></pre></td></tr></table></figure></p>
<p>可以看到已经监听好了</p>
<p>修改ceph的配置文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#log_to_graylog = true</span></span><br><span class="line"><span class="comment">#err_to_graylog = true</span></span><br><span class="line"><span class="comment">#log_graylog_host = 192.168.10.2</span></span><br><span class="line"><span class="comment">#log_graylog_port = 12201</span></span><br><span class="line">clog_to_graylog = <span class="literal">true</span></span><br><span class="line">clog_to_graylog_host = <span class="number">192.168</span>.<span class="number">10.2</span></span><br><span class="line">clog_to_graylog_port = <span class="number">12201</span></span><br><span class="line">mon_cluster_<span class="built_in">log</span>_to_graylog = <span class="literal">true</span></span><br><span class="line">mon_cluster_<span class="built_in">log</span>_to_graylog_host = <span class="number">192.168</span>.<span class="number">10.2</span></span><br><span class="line">mon_cluster_<span class="built_in">log</span>_to_graylog_port = <span class="number">12201</span></span><br></pre></td></tr></table></figure></p>
<p>ceph.conf当中跟graylog有关的就是这些配置文件了，配置好端口是刚刚监听的那个udp端口，然后重启ceph服务，这里我只需要mon_cluster日志和clog，这个根据自己的需要选择</p>
<p><img src="http://static.zybuluo.com/zphj1987/haiphagvwq5fwgpe8cls2bm0/image.png" alt="image.png-199.9kB"></p>
<p>可以看到ceph -w的输出都可以在这个里面查询了</p>
<h3 id="配置告警">配置告警</h3><p><img src="http://static.zybuluo.com/zphj1987/niv3p6tq44rv7xif0ao62ykg/image.png" alt="image.png-128.7kB"><br>出现异常的时候<br><img src="http://static.zybuluo.com/zphj1987/cz7qz8qdi0if4ddvtb60nike/image.png" alt="image.png-62.2kB"></p>
<h2 id="总结">总结</h2><p>这个系统支持原生的接口接入，未来应该可以支持更多类型的日志倒入，这样相当于很容易就部署了一个日志搜索系统了，当然还有很多其他的方案，从功能完整性来说Elasticsearch要比这个强大，这套系统目前来看配置是非常的简单，也是一个优势</p>
<h2 id="变更记录">变更记录</h2><table>
<thead>
<tr>
<th style="text-align:center">Why</th>
<th style="text-align:center">Who</th>
<th style="text-align:center">When</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建</td>
<td style="text-align:center">武汉-运维-磨渣</td>
<td style="text-align:center">2017-06-09</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/graylog.png" alt=""><br></center>

<h2 id="前言">前言</h2><p>在看集群的配置文件的时候看到ceph里面有一个graylog的输出选择，目前看到的是可以收集mon日志和clog，osd单个的日志没有看到，Elasticsearch有整套的日志收集系统，可以很方便的将所有日志汇总到一起，这个graylog的收集采用的是自有的udp协议，从配置上来说可以很快的完成，这里只做一个最基本的实践<br>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ceph部署mon出现0.0.0.0地址]]></title>
    <link href="http://www.zphj1987.com/2017/06/06/Ceph-deploymon-with-error-address/"/>
    <id>http://www.zphj1987.com/2017/06/06/Ceph-deploymon-with-error-address/</id>
    <published>2017-06-06T09:42:22.000Z</published>
    <updated>2017-06-06T09:48:16.851Z</updated>
    <content type="html"><![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/monitor.png" alt="monitor"><br></center>

<h2 id="前言">前言</h2><p>最近在群里两次看到出现mon地址不对的问题，都是显示0.0.0.0:0地址，如下所示：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ceph]<span class="comment"># ceph -s</span></span><br><span class="line">    cluster <span class="number">3137</span>d009<span class="operator">-e</span>41e-<span class="number">41</span>f0-b8f8-<span class="number">5</span>cb574502572</span><br><span class="line">     health HEALTH_ERR</span><br><span class="line">            <span class="number">1</span> mons down, quorum <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span> lab8106,node8107,lab104</span><br><span class="line">     monmap e2: <span class="number">4</span> mons at &#123;lab104=<span class="number">192.168</span>.<span class="number">10.4</span>:<span class="number">6789</span>/<span class="number">0</span>,lab8106=<span class="number">192.168</span>.<span class="number">8.106</span>:<span class="number">6789</span>/<span class="number">0</span>,lab8107=<span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">0</span>/<span class="number">2</span>,node8107=<span class="number">192.168</span>.<span class="number">8.107</span>:<span class="number">6789</span>/<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>这个之前偶尔会看到有出现这个问题，但是自己一直没碰到过，想看下是什么情况下触发的，在征得这个cepher的同意后，登录上他的环境检查了一下，发现是主机名引起的这个问题</p>
<h2 id="问题复现">问题复现</h2><p>在部署的过程中，已经规划好了主机名，而又去修改了这个机器的主机名的情况下就会出现这个问题<br>比如我的这个机器，开始规划好lab8107主机名是这个，然后再lab8107上执行hostname node8107，就会触发这个问题</p>
<p>这个在deploy的部署输出日志中可以看得到<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[lab8107][WARNIN] ********************************************************************************</span><br><span class="line">[lab8107][WARNIN] provided hostname must match remote hostname</span><br><span class="line">[lab8107][WARNIN] provided hostname: lab8107</span><br><span class="line">[lab8107][WARNIN] remote hostname: node8107</span><br><span class="line">[lab8107][WARNIN] monitors may not reach quorum and create-keys will not complete</span><br><span class="line">[lab8107][WARNIN] ********************************************************************************</span><br></pre></td></tr></table></figure></p>
<p>可以看到 provided hostname: lab8107 而remote hostname: node8107，就会出现这个问题了</p>
<p>如果下次出现这个问题，首先就检查下规划的mon的主机名与真实的主机名是否一致</p>
<h2 id="总结">总结</h2><p>新手在部署环境的时候，经常会犯一些比较基础的错误，这个是一个经验积累的过程，当然对于已经比较熟悉的cepher来说，也去尝试多看下各种异常问题，这个对于以后定位异常还是很有帮助的</p>
<h2 id="变更记录">变更记录</h2><table>
<thead>
<tr>
<th style="text-align:center">Why</th>
<th style="text-align:center">Who</th>
<th style="text-align:center">When</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建</td>
<td style="text-align:center">武汉-运维-磨渣</td>
<td style="text-align:center">2017-06-06</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/monitor.png" alt="monitor"><br></center>

<h2 id="前言">前言</h2><p>最近在群里两次看到出现mon地址不对的问题，都是显示0.0.0.0:0地址，如下所示：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ceph]<span class="comment"># ceph -s</span></span><br><span class="line">    cluster <span class="number">3137</span>d009<span class="operator">-e</span>41e-<span class="number">41</span>f0-b8f8-<span class="number">5</span>cb574502572</span><br><span class="line">     health HEALTH_ERR</span><br><span class="line">            <span class="number">1</span> mons down, quorum <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span> lab8106,node8107,lab104</span><br><span class="line">     monmap e2: <span class="number">4</span> mons at &#123;lab104=<span class="number">192.168</span>.<span class="number">10.4</span>:<span class="number">6789</span>/<span class="number">0</span>,lab8106=<span class="number">192.168</span>.<span class="number">8.106</span>:<span class="number">6789</span>/<span class="number">0</span>,lab8107=<span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">0</span>/<span class="number">2</span>,node8107=<span class="number">192.168</span>.<span class="number">8.107</span>:<span class="number">6789</span>/<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Centos7升级内核后无法启动解决办法]]></title>
    <link href="http://www.zphj1987.com/2017/06/01/centos7-update-kernel-can-not-boot/"/>
    <id>http://www.zphj1987.com/2017/06/01/centos7-update-kernel-can-not-boot/</id>
    <published>2017-06-01T06:09:39.000Z</published>
    <updated>2017-06-01T07:03:17.481Z</updated>
    <content type="html"><![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/newkernel.png?imageMogr2/thumbnail/!75p" alt="kernel"><br></center>

<h2 id="前言">前言</h2><p>这个问题存在有一段时间了，之前做的centos7的ISO，在进行内核的升级以后就存在这个问题：</p>
<ul>
<li>系统盘在板载sata口上是可以正常启动新内核并且能识别面板硬盘</li>
<li>系统盘插在面板口上新内核无法启动，调试发现无法找到系统盘</li>
<li>系统盘插在面板上默认的3.10内核可以正常启动<a id="more"></a>
暂时的解决办法就是让系统插在板载的sata口上，因为当时没找到具体的解决办法，在这个问题持续了一段时间后，最近再次搜索资料的时候，把问题定位在了initramfs内的驱动的问题，并且对问题进行了解决</li>
</ul>
<h2 id="解决过程">解决过程</h2><p>查询initramfs的驱动<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab103 lab103]<span class="comment"># lsinitrd -k 3.10.0-327.el7.x86_64|grep mpt[23]sas</span></span><br><span class="line">drwxr-xr-x   <span class="number">2</span> root     root            <span class="number">0</span> Apr <span class="number">17</span> <span class="number">12</span>:<span class="number">05</span> usr/lib/modules/<span class="number">3.10</span>.<span class="number">0</span>-<span class="number">327</span>.el7.x86_64/kernel/drivers/scsi/mpt2sas</span><br><span class="line">-rw-r--r--   <span class="number">1</span> root     root       <span class="number">337793</span> Nov <span class="number">20</span>  <span class="number">2015</span> usr/lib/modules/<span class="number">3.10</span>.<span class="number">0</span>-<span class="number">327</span>.el7.x86_64/kernel/drivers/scsi/mpt2sas/mpt2sas.ko</span><br></pre></td></tr></table></figure></p>
<p>可以看到在3.10内核的时候是mpt2sas驱动</p>
<p>可以在4.x内核中看到<br>新版的内核已经把mpt2sas升级为mpt3sas<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/lib/modules/<span class="number">4.4</span>.<span class="number">46</span>/kernel/drivers/scsi/mpt3sas/mpt3sas.ko</span><br></pre></td></tr></table></figure></p>
<p>查询initramfs内的模块<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsinitrd -k  <span class="number">4.4</span>.<span class="number">46</span>|grep mpt[<span class="number">23</span>]sas</span><br></pre></td></tr></table></figure></p>
<p>可以看到并没有输出，说明initramfs并没有把这个驱动打进去</p>
<p>这个地方有两种方式来解决</p>
<h3 id="方法一：">方法一：</h3><p>修改 /etc/dracut.conf文件，增加字段</p>
<blockquote>
<p>add_drivers+=”mpt3sas”</p>
</blockquote>
<p>重新生成initramfs<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dracut <span class="operator">-f</span> /boot/initramfs-<span class="number">4.4</span>.<span class="number">46</span>.img <span class="number">4.4</span>.<span class="number">46</span></span><br></pre></td></tr></table></figure></p>
<h3 id="方法二：">方法二：</h3><p>强制加载驱动<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dracut --force --add-drivers mpt3sas --kver=<span class="number">4.4</span>.<span class="number">46</span></span><br></pre></td></tr></table></figure></p>
<p>以上方法二选一做下驱动的集成，然后做下面的检查<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsinitrd -k  <span class="number">4.4</span>.<span class="number">46</span>|grep mpt[<span class="number">23</span>]sas</span><br></pre></td></tr></table></figure></p>
<p>如果有输出就是正常了的</p>
<p>然后重启操作系统即可</p>
<h2 id="总结">总结</h2><p>目前出现这个问题的原因不清楚来自内核还是dracut生成的地方，如果遇到这个问题就按照上面的方法进行处理下即可，问题能找到解决办法后就会发现只是小问题，没找到的时候，完全不知道问题在哪里</p>
<h2 id="变更记录">变更记录</h2><table>
<thead>
<tr>
<th style="text-align:center">Why</th>
<th style="text-align:center">Who</th>
<th style="text-align:center">When</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建</td>
<td style="text-align:center">武汉-运维-磨渣</td>
<td style="text-align:center">2017-06-01</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/newkernel.png?imageMogr2/thumbnail/!75p" alt="kernel"><br></center>

<h2 id="前言">前言</h2><p>这个问题存在有一段时间了，之前做的centos7的ISO，在进行内核的升级以后就存在这个问题：</p>
<ul>
<li>系统盘在板载sata口上是可以正常启动新内核并且能识别面板硬盘</li>
<li>系统盘插在面板口上新内核无法启动，调试发现无法找到系统盘</li>
<li>系统盘插在面板上默认的3.10内核可以正常启动]]>
    
    </summary>
    
      <category term="linux" scheme="http://www.zphj1987.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Freebsd10.2安装包升级pkg引起环境破坏的解决]]></title>
    <link href="http://www.zphj1987.com/2017/05/24/Freebsd-pkg-destroy/"/>
    <id>http://www.zphj1987.com/2017/05/24/Freebsd-pkg-destroy/</id>
    <published>2017-05-24T02:40:34.000Z</published>
    <updated>2017-06-01T06:46:51.484Z</updated>
    <content type="html"><![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/brock.png?imageMogr2/thumbnail/!75p" alt=""><br></center>


<h2 id="前言">前言</h2><p>freebsd10.2环境在安装一个新软件包的时候提示升级pkg到1.10.1，然后点击了升级，然后整个pkg环境就无法使用了</p>
<h2 id="记录">记录</h2><p>升级完了软件包以后第一个错误提示</p>
<blockquote>
<p>FreeBSD: /usr/local/lib/libpkg.so.3: Undefined symbol “utimensat” </p>
</blockquote>
<p>这个是因为这个库是在freebsd的10.3当中才有的库，而我的环境是10.2的环境<br><a id="more"></a></p>
<h3 id="网上有一个解决办法">网上有一个解决办法</h3><p>更新源<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /usr/local/etc/pkg/repos/FreeBSD.conf</span></span><br><span class="line">FreeBSD: &#123;</span><br><span class="line">  url: <span class="string">"pkg+http://pkg.FreeBSD.org/<span class="variable">$&#123;ABI&#125;</span>/release_2"</span>,</span><br><span class="line">  enabled: yes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>检查当前版本<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pkg --version</span></span><br><span class="line"><span class="number">1.10</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>更新缓存<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pkg update</span></span><br></pre></td></tr></table></figure></p>
<p>卸载<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pkg delete -f pkg</span></span><br></pre></td></tr></table></figure></p>
<p>重新安装<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pkg install -y pkg</span></span><br><span class="line"><span class="comment"># pkg2ng</span></span><br></pre></td></tr></table></figure></p>
<p>检查版本<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pkg --version</span></span><br><span class="line"><span class="number">1.5</span>.<span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>这个在我的环境下没有生效</p>
<h3 id="还有一个办法">还有一个办法</h3><p>有个pkg-static命令可以使用，，然后/var/cache/pkg里边缓存的包。执行命令： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pkg-static install -f /var/cache/pkg/pkg-1.5.4.txz</span></span><br></pre></td></tr></table></figure>
<p>这个在我的环境下报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@mkiso:/usr/ports/ports-mgmt/pkg <span class="comment"># pkg info sqlite3</span></span><br><span class="line">pkg: warning: database version <span class="number">34</span> is newer than libpkg(<span class="number">3</span>) version <span class="number">33</span>, but still compatible</span><br><span class="line">pkg: sqlite error <span class="keyword">while</span> executing INSERT OR ROLLBACK INTO pkg_search(id, name, origin) VALUES (?<span class="number">1</span>, ?<span class="number">2</span> || <span class="string">'-'</span> || ?<span class="number">3</span>, ?<span class="number">4</span>); <span class="keyword">in</span> file pkgdb.c:<span class="number">1544</span>: no such table: pkg_search</span><br></pre></td></tr></table></figure>
<p>这个在网上看到有很多人出现了</p>
<h3 id="最终解决的办法">最终解决的办法</h3><p>在邮件列表里面看到一个解决办法，我是用的这个办法解决了的<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#pkg shell</span></span><br></pre></td></tr></table></figure></p>
<p>进入交互模式,执行下面的操作<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE VIRTUAL TABLE pkg_search USING fts4(id, name, origin);</span><br><span class="line">pragma user_version=<span class="number">33</span>;</span><br></pre></td></tr></table></figure></p>
<p>执行完了以后pkg 环境可用了</p>
<h2 id="避免这个问题">避免这个问题</h2><p>锁定本机的pkg版本<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkg lock pkg</span><br></pre></td></tr></table></figure></p>
<p>如果需要手动找包就是这个路径<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://pkg.freebsd.org/FreeBSD:<span class="number">10</span>:amd64/</span><br></pre></td></tr></table></figure></p>
<p>我的机器最终版本是<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#pkg -v</span></span><br><span class="line"><span class="number">1.8</span>.<span class="number">7</span></span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料">参考资料</h2><p><a href="http://www.07net01.com/2017/02/1816847.html" target="_blank" rel="external">freebsd pkg升级问题报错</a><br><a href="http://glasz.org/sheeplog/2017/02/freebsd-usrlocalliblibpkgso3-undefined-symbol-utimensat.html" target="_blank" rel="external">FreeBSD: /usr/local/lib/libpkg.so.3: Undefined symbol “utimensat” </a><br><a href="http://bbs.chinaunix.net/thread-4260263-1-1.html" target="_blank" rel="external">升级pkg失败, 安装低版本pkg失败</a><br><a href="https://lists.freebsd.org/pipermail/freebsd-ports/2017-January/106799.html" target="_blank" rel="external">pkg database issue: database version 34 is newer than libpkg(3) version 33 ?</a></p>
<h2 id="变更记录">变更记录</h2><table>
<thead>
<tr>
<th style="text-align:center">Why</th>
<th style="text-align:center">Who</th>
<th style="text-align:center">When</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建</td>
<td style="text-align:center">武汉-运维-磨渣</td>
<td style="text-align:center">2017-05-24</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/brock.png?imageMogr2/thumbnail/!75p" alt=""><br></center>


<h2 id="前言">前言</h2><p>freebsd10.2环境在安装一个新软件包的时候提示升级pkg到1.10.1，然后点击了升级，然后整个pkg环境就无法使用了</p>
<h2 id="记录">记录</h2><p>升级完了软件包以后第一个错误提示</p>
<blockquote>
<p>FreeBSD: /usr/local/lib/libpkg.so.3: Undefined symbol “utimensat” </p>
</blockquote>
<p>这个是因为这个库是在freebsd的10.3当中才有的库，而我的环境是10.2的环境<br>]]>
    
    </summary>
    
      <category term="freebsd" scheme="http://www.zphj1987.com/tags/freebsd/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ceph OSD从filestore 转换到 bluestore的方法]]></title>
    <link href="http://www.zphj1987.com/2017/05/03/Ceph-filestore-to-bluestore/"/>
    <id>http://www.zphj1987.com/2017/05/03/Ceph-filestore-to-bluestore/</id>
    <published>2017-05-03T09:57:27.000Z</published>
    <updated>2017-05-03T10:13:00.113Z</updated>
    <content type="html"><![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/blueprint.png" alt="myceph"><br></center>

<h2 id="前言">前言</h2><p>前段时间看到<a href="https://mp.weixin.qq.com/s?__biz=MzI0NDE0NjUxMQ==&amp;mid=2651256389&amp;idx=1&amp;sn=e11edcce5722853f442b9a7b8211787e&amp;chksm=f2901e65c5e79773c7690f29e35dbd1870a5bfdb92c70541979f5d080d6580e3af9ba85fff66&amp;mpshare=1&amp;scene=23&amp;srcid=0502SazrSPsWnszP3xfdEId4#rd" target="_blank" rel="external">豪迈的公众号</a>上提到了这个离线转换工具，最近看到群里有人问，找了下没什么相关文档，就自己写了一个，供参考<br><a id="more"></a></p>
<h2 id="实践步骤">实践步骤</h2><h3 id="获取代码并安装">获取代码并安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ceph/ceph.git</span><br><span class="line"><span class="built_in">cd</span> ceph</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">./make-dist</span><br><span class="line">rpm -bb ceph.spec</span><br></pre></td></tr></table></figure>
<p>生成rpm安装包后进行安装,这个过程就不讲太多，根据各种文档安装上最新的版本即可，这个代码合进去时间并不久，大概是上个月才合进去的</p>
<h3 id="配置集群">配置集群</h3><p>首先配置一个filestore的集群，这个也是很简单的，我的环境配置一个单主机三个OSD的集群<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ceph]<span class="comment"># ceph -s</span></span><br><span class="line">    cluster <span class="number">3</span>daaf51a-eeba-<span class="number">43</span>a6-<span class="number">9</span>f58-c26c5796f928</span><br><span class="line">     health HEALTH_WARN</span><br><span class="line">            mon.lab8106 low disk space</span><br><span class="line">     monmap e2: <span class="number">1</span> mons at &#123;lab8106=<span class="number">192.168</span>.<span class="number">8.106</span>:<span class="number">6789</span>/<span class="number">0</span>&#125;</span><br><span class="line">            election epoch <span class="number">4</span>, quorum <span class="number">0</span> lab8106</span><br><span class="line">        mgr active: lab8106 </span><br><span class="line">     osdmap e16: <span class="number">3</span> osds: <span class="number">3</span> up, <span class="number">3</span> <span class="keyword">in</span></span><br><span class="line">      pgmap v34: <span class="number">64</span> pgs, <span class="number">1</span> pools, <span class="number">0</span> bytes data, <span class="number">0</span> objects</span><br><span class="line">            <span class="number">323</span> MB used, <span class="number">822</span> GB / <span class="number">822</span> GB avail</span><br><span class="line">                  <span class="number">64</span> active+clean</span><br><span class="line">[root@lab8106 ceph]<span class="comment"># ceph osd tree</span></span><br><span class="line">ID WEIGHT  TYPE NAME        UP/DOWN REWEIGHT PRIMARY-AFFINITY </span><br><span class="line">-<span class="number">1</span> <span class="number">0.80338</span> root default                                       </span><br><span class="line">-<span class="number">2</span> <span class="number">0.80338</span>     host lab8106                                   </span><br><span class="line"> <span class="number">0</span> <span class="number">0.26779</span>         osd.<span class="number">0</span>         up  <span class="number">1.00000</span>          <span class="number">1.00000</span> </span><br><span class="line"> <span class="number">1</span> <span class="number">0.26779</span>         osd.<span class="number">1</span>         up  <span class="number">1.00000</span>          <span class="number">1.00000</span> </span><br><span class="line"> <span class="number">2</span> <span class="number">0.26779</span>         osd.<span class="number">2</span>         up  <span class="number">1.00000</span>          <span class="number">1.00000</span></span><br></pre></td></tr></table></figure></p>
<h3 id="写入少量数据">写入少量数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># rados -p rbd bench 10 write --no-cleanup</span></span><br></pre></td></tr></table></figure>
<h3 id="设置noout">设置noout</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># ceph osd set noout</span></span><br><span class="line">noout is <span class="built_in">set</span></span><br></pre></td></tr></table></figure>
<h3 id="停止OSD-0">停止OSD.0</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># systemctl stop ceph-osd@0</span></span><br><span class="line">[root@lab8106 ~]<span class="comment"># ceph osd down 0</span></span><br><span class="line">osd.<span class="number">0</span> is already down.</span><br></pre></td></tr></table></figure>
<p>将数据换个目录挂载，换个新盘挂载到原路径<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># mkdir /var/lib/ceph/osd/ceph-0.old/</span></span><br><span class="line">[root@lab8106 ~]<span class="comment"># umount /var/lib/ceph/osd/ceph-0</span></span><br><span class="line">[root@lab8106 ~]<span class="comment"># mount /dev/sdb1 /var/lib/ceph/osd/ceph-0.old/</span></span><br><span class="line">[root@lab8106 ~]<span class="comment"># mount /dev/sde1 /var/lib/ceph/osd/ceph-0/</span></span><br><span class="line"></span><br><span class="line">[root@lab8106 ~]<span class="comment"># df -h|grep osd</span></span><br><span class="line">/dev/sdc1       <span class="number">275</span>G  <span class="number">833</span>M  <span class="number">274</span>G   <span class="number">1</span>% /var/lib/ceph/osd/ceph-<span class="number">1</span></span><br><span class="line">/dev/sdd1       <span class="number">275</span>G  <span class="number">833</span>M  <span class="number">274</span>G   <span class="number">1</span>% /var/lib/ceph/osd/ceph-<span class="number">2</span></span><br><span class="line">/dev/sdb1       <span class="number">275</span>G  <span class="number">759</span>M  <span class="number">274</span>G   <span class="number">1</span>% /var/lib/ceph/osd/ceph-<span class="number">0</span>.old</span><br><span class="line">/dev/sde1       <span class="number">280</span>G   <span class="number">33</span>M  <span class="number">280</span>G   <span class="number">1</span>% /var/lib/ceph/osd/ceph-<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>在配置文件/etc/ceph/ceph.conf中添加<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enable</span>_experimental_unrecoverable_data_corrupting_features = bluestore</span><br></pre></td></tr></table></figure></p>
<p>如果需要指定osd的block的路径需要写配置文件<br>在做<code>ceph-objectstore-tool --type bluestore --data-path  --op mkfs</code>这个操作之前，在配置文件的全局里面添加上</p>
<blockquote>
<p>bluestore_block_path = /dev/sde2</p>
</blockquote>
<p>然后再创建的时候就可以是链接到设备了，这个地方写全局变量，然后创建完了后就删除掉这项配置文件，写单独的配置文件的时候发现没读取成功,生成后应该是这样的<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ceph]<span class="comment"># ll /var/lib/ceph/osd/ceph-0</span></span><br><span class="line">total <span class="number">20</span></span><br><span class="line">lrwxrwxrwx <span class="number">1</span> root root  <span class="number">9</span> May  <span class="number">3</span> <span class="number">17</span>:<span class="number">40</span> block -&gt; /dev/sde2</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root  <span class="number">2</span> May  <span class="number">3</span> <span class="number">17</span>:<span class="number">40</span> bluefs</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">37</span> May  <span class="number">3</span> <span class="number">17</span>:<span class="number">40</span> fsid</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root  <span class="number">8</span> May  <span class="number">3</span> <span class="number">17</span>:<span class="number">40</span> kv_backend</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root  <span class="number">4</span> May  <span class="number">3</span> <span class="number">17</span>:<span class="number">40</span> mkfs_<span class="keyword">done</span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">10</span> May  <span class="number">3</span> <span class="number">17</span>:<span class="number">40</span> <span class="built_in">type</span></span><br></pre></td></tr></table></figure></p>
<p>如果不增加这个就是以文件形式的存在</p>
<h3 id="获取osd-0的fsid">获取osd.0的fsid</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># cat /var/lib/ceph/osd/ceph-0.old/fsid </span></span><br><span class="line">b2f73450-<span class="number">5</span>c4a-<span class="number">45</span>fb-<span class="number">9</span>c24-<span class="number">8218</span>a5803434</span><br></pre></td></tr></table></figure>
<h3 id="创建一个bluestore的osd-0">创建一个bluestore的osd.0</h3><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="title">[</span><span class="comment">root@lab8106</span> <span class="comment">~</span><span class="title">]</span><span class="comment">#</span> <span class="comment">ceph</span><span class="literal">-</span><span class="comment">objectstore</span><span class="literal">-</span><span class="comment">tool</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">type</span> <span class="comment">bluestore</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">data</span><span class="literal">-</span><span class="comment">path</span> <span class="comment">/var/lib/ceph/osd/ceph</span><span class="literal">-</span><span class="comment">0</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">fsid</span> <span class="comment">b2f73450</span><span class="literal">-</span><span class="comment">5c4a</span><span class="literal">-</span><span class="comment">45fb</span><span class="literal">-</span><span class="comment">9c24</span><span class="literal">-</span><span class="comment">8218a5803434</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">op</span> <span class="comment">mkfs</span></span><br></pre></td></tr></table></figure>
<h3 id="转移数据">转移数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># ceph-objectstore-tool --data-path /var/lib/ceph/osd/ceph-0.old --target-data-path /var/lib/ceph/osd/ceph-0 --op dup</span></span><br><span class="line">[root@lab8106 ~]<span class="comment"># chown -R ceph:ceph /var/lib/ceph/osd/ceph-0</span></span><br></pre></td></tr></table></figure>
<p>这个操作是将之前的filestore的数据转移到新的bluestore上了</p>
<h3 id="启动OSD-0">启动OSD.0</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 osd]<span class="comment"># systemctl restart ceph-osd@0</span></span><br></pre></td></tr></table></figure>
<p>检查状态<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 osd]<span class="comment"># ceph -s</span></span><br><span class="line"><span class="number">2017</span>-<span class="number">05</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">05</span>:<span class="number">13.119492</span> <span class="number">7</span>f20a501b700 -<span class="number">1</span> WARNING: the following dangerous and experimental features are enabled: bluestore</span><br><span class="line"><span class="number">2017</span>-<span class="number">05</span>-<span class="number">03</span> <span class="number">17</span>:<span class="number">05</span>:<span class="number">13.150181</span> <span class="number">7</span>f20a501b700 -<span class="number">1</span> WARNING: the following dangerous and experimental features are enabled: bluestore</span><br><span class="line">    cluster <span class="number">3</span>daaf51a-eeba-<span class="number">43</span>a6-<span class="number">9</span>f58-c26c5796f928</span><br><span class="line">     health HEALTH_WARN</span><br><span class="line">            noout flag(s) <span class="built_in">set</span></span><br><span class="line">            mon.lab8106 low disk space</span><br><span class="line">     monmap e2: <span class="number">1</span> mons at &#123;lab8106=<span class="number">192.168</span>.<span class="number">8.106</span>:<span class="number">6789</span>/<span class="number">0</span>&#125;</span><br><span class="line">            election epoch <span class="number">4</span>, quorum <span class="number">0</span> lab8106</span><br><span class="line">        mgr active: lab8106 </span><br><span class="line">     osdmap e25: <span class="number">3</span> osds: <span class="number">3</span> up, <span class="number">3</span> <span class="keyword">in</span></span><br><span class="line">            flags noout</span><br><span class="line">      pgmap v80: <span class="number">64</span> pgs, <span class="number">1</span> pools, <span class="number">724</span> MB data, <span class="number">182</span> objects</span><br><span class="line">            <span class="number">3431</span> MB used, <span class="number">555</span> GB / <span class="number">558</span> GB avail</span><br><span class="line">                  <span class="number">64</span> active+clean</span><br></pre></td></tr></table></figure></p>
<p>成功转移</p>
<h3 id="不同的block方式">不同的block方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ceph]<span class="comment"># ll /var/lib/ceph/osd/ceph-0/ -al|grep block</span></span><br><span class="line">-rw-r--r--  <span class="number">1</span> ceph ceph <span class="number">10737418240</span> May  <span class="number">3</span> <span class="number">17</span>:<span class="number">32</span> block</span><br><span class="line">[root@lab8106 ceph]<span class="comment"># ll /var/lib/ceph/osd/ceph-4/ -al|grep block</span></span><br><span class="line">lrwxrwxrwx  <span class="number">1</span> ceph ceph  <span class="number">58</span> May  <span class="number">3</span> <span class="number">17</span>:<span class="number">16</span> block -&gt; /dev/disk/by-partuuid/<span class="number">846</span>e93a2-<span class="number">0</span>f6d-<span class="number">47</span>d4-<span class="number">8</span>a90-<span class="number">85</span>ab3cf4ec4e</span><br><span class="line">-rw-r--r--  <span class="number">1</span> ceph ceph  <span class="number">37</span> May  <span class="number">3</span> <span class="number">17</span>:<span class="number">16</span> block_uuid</span><br></pre></td></tr></table></figure>
<p>可以看到直接创建的时候的block是以链接的方式链接到一个分区的，而不改配置文件的转移的方式里面是一个文件的形式，根据需要进行选择</p>
<h2 id="总结">总结</h2><p>转移工具的出现方便了以后从filestore到bluestore的转移，可以采取一个个osd的转移方式将整个集群进行转移，而免去了剔除osd，再添加的方式，减少了迁移量，可以一个个的离线进行操作</p>
<p>ceph的工具集越来越完整了</p>
<h2 id="变更记录">变更记录</h2><table>
<thead>
<tr>
<th style="text-align:center">Why</th>
<th style="text-align:center">Who</th>
<th style="text-align:center">When</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建</td>
<td style="text-align:center">武汉-运维-磨渣</td>
<td style="text-align:center">2017-05-03</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/blueprint.png" alt="myceph"><br></center>

<h2 id="前言">前言</h2><p>前段时间看到<a href="https://mp.weixin.qq.com/s?__biz=MzI0NDE0NjUxMQ==&amp;mid=2651256389&amp;idx=1&amp;sn=e11edcce5722853f442b9a7b8211787e&amp;chksm=f2901e65c5e79773c7690f29e35dbd1870a5bfdb92c70541979f5d080d6580e3af9ba85fff66&amp;mpshare=1&amp;scene=23&amp;srcid=0502SazrSPsWnszP3xfdEId4#rd">豪迈的公众号</a>上提到了这个离线转换工具，最近看到群里有人问，找了下没什么相关文档，就自己写了一个，供参考<br>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[多MDS变成单MDS的方法]]></title>
    <link href="http://www.zphj1987.com/2017/05/03/mutimds-to-single-mds/"/>
    <id>http://www.zphj1987.com/2017/05/03/mutimds-to-single-mds/</id>
    <published>2017-05-03T07:53:10.000Z</published>
    <updated>2017-05-03T07:54:24.241Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>之前有个cepher的环境上是双活MDS的，需要变成MDS，目前最新版本是支持这个操作的</p>
<a id="more"></a>
<h2 id="方法">方法</h2><h3 id="设置最大mds">设置最大mds</h3><p>多活的mds的max_mds会超过1，这里需要先将max_mds设置为1<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph mds <span class="built_in">set</span> max_mds <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="deactive_mds">deactive mds</h3><p>看下需要停掉的mds是rank 0 还是rank1,然后执行下面的命令即可<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@server8 ~]<span class="comment"># zbkc -s|grep mdsmap</span></span><br><span class="line">     mdsmap e13: <span class="number">1</span>/<span class="number">1</span>/<span class="number">1</span> up &#123;<span class="number">0</span>=lab8106=up:clientreplay&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个输出的lab8106前面的0，就是这个mds的rank，根据需要停止对应的rank<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph mds deactivate <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="总结">总结</h2><p>不建议用多活mds</p>
<h2 id="变更记录">变更记录</h2><table>
<thead>
<tr>
<th style="text-align:center">Why</th>
<th style="text-align:center">Who</th>
<th style="text-align:center">When</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建</td>
<td style="text-align:center">武汉-运维-磨渣</td>
<td style="text-align:center">2017-05-03</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>之前有个cepher的环境上是双活MDS的，需要变成MDS，目前最新版本是支持这个操作的</p>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ceph根据Crush位置读取数据]]></title>
    <link href="http://www.zphj1987.com/2017/04/27/Ceph-depend-Crush-read-data/"/>
    <id>http://www.zphj1987.com/2017/04/27/Ceph-depend-Crush-read-data/</id>
    <published>2017-04-27T08:47:04.000Z</published>
    <updated>2017-04-27T09:10:58.547Z</updated>
    <content type="html"><![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/read.gif?imageMogr2/thumbnail/!75p" alt=""><br></center>

<h2 id="前言">前言</h2><p>在ceph研发群里面看到一个cepher在问关于怎么读取ceph的副本的问题，这个功能应该在2012年的时候,我们公司的研发就修改了代码去实现这个功能，只是当时的硬件条件所限，以及本身的稳定性问题，后来没有在生产当中使用<br><a id="more"></a><br>我们都知道ceph在写数据的时候，是先写主本，然后去写副本，而读取的时候，实际上只有主本能够提供服务，这对于磁盘的整体带宽来说，并没有充分的发挥其性能，所以能够读取副本当然是会有很大好处的，特别是对于读场景比较多的情况</p>
<p>那么在ceph当中是不是有这个功能呢？其实是有的，这个地方ceph更往上走了一层，是基于crush定义的地址去进行文件的读取，这样在读取的客户端眼里，就没有什么主副之分，他会按自己想要的区域去尽量读取，当然这个区域没有的时候就按正常读取就可以了<br><!--more--></p>
<h2 id="实践">实践</h2><p>如果你看过关于ceph hadoop的相关配置文档，应该会看到这么一个配置</p>
<blockquote>
<p>ceph.localize.reads<br>Allow reading from file replica objects<br>Default value: true</p>
</blockquote>
<p>显示的是可以从非主本去读取对象，这个对于hadoop场景肯定是越近越好的，可以在ceph的代码里面搜索下 localize-reads<br><a href="https://github.com/ceph/ceph/blob/master/src/ceph_fuse.cc" target="_blank" rel="external">https://github.com/ceph/ceph/blob/master/src/ceph_fuse.cc</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (std::vector&lt;const char*&gt;::iterator i = args.begin(); i != args.end(); ) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ceph_argparse_double_dash(args, i)) &#123;</span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ceph_argparse_flag(args, i, <span class="string">"--localize-reads"</span>, (char*)NULL)) &#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">"setting CEPH_OSD_FLAG_LOCALIZE_READS"</span> &lt;&lt; std::endl;</span><br><span class="line">    filer_flags |= CEPH_OSD_FLAG_LOCALIZE_READS;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ceph_argparse_flag(args, i, <span class="string">"-h"</span>, <span class="string">"--help"</span>, (char*)NULL)) &#123;</span><br><span class="line">    usage();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ++i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到在ceph-fuse的情况下，是有这个隐藏的一个参数的，本篇就是用这个隐藏的参数来进行实践</p>
<h3 id="配置一个两节点集群">配置一个两节点集群</h3><p>配置完成了以后ceph的目录树如下,mon部署在lab8106上面<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8107 ~]<span class="comment"># ceph osd tree</span></span><br><span class="line">ID WEIGHT  TYPE NAME        UP/DOWN REWEIGHT PRIMARY-AFFINITY </span><br><span class="line">-<span class="number">1</span> <span class="number">1.07336</span> root default                                       </span><br><span class="line">-<span class="number">2</span> <span class="number">0.53778</span>     host lab8106                                   </span><br><span class="line"> <span class="number">1</span> <span class="number">0.26779</span>         osd.<span class="number">1</span>         up  <span class="number">1.00000</span>          <span class="number">1.00000</span> </span><br><span class="line"> <span class="number">0</span> <span class="number">0.26999</span>         osd.<span class="number">0</span>         up  <span class="number">1.00000</span>          <span class="number">1.00000</span> </span><br><span class="line">-<span class="number">3</span> <span class="number">0.53558</span>     host lab8107                                   </span><br><span class="line"> <span class="number">2</span> <span class="number">0.26779</span>         osd.<span class="number">2</span>         up  <span class="number">1.00000</span>          <span class="number">1.00000</span> </span><br><span class="line"> <span class="number">3</span> <span class="number">0.26779</span>         osd.<span class="number">3</span>         up  <span class="number">1.00000</span>          <span class="number">1.00000</span></span><br><span class="line">[root@lab8107 ~]<span class="comment"># ceph -s|grep mon</span></span><br><span class="line">monmap e1: <span class="number">1</span> mons at &#123;lab8106=<span class="number">192.168</span>.<span class="number">8.106</span>:<span class="number">6789</span>/<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="在lab8107上挂载客户端">在lab8107上挂载客户端</h3><p>在/etc/ceph/ceph.conf中增加一个配置<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">crush_location = <span class="string">"host=lab8107 root=default"</span></span><br></pre></td></tr></table></figure></p>
<p>这个配置的作用是告诉这个客户端尽量去读取lab8107上面的对象<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8107 ~]<span class="comment"># ceph-fuse -m lab8106:6789 /mnt  --localize-reads</span></span><br></pre></td></tr></table></figure></p>
<p>写入一个大文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8107 ~]<span class="comment"># dd if=/dev/zero of=a bs=4M count=4000</span></span><br></pre></td></tr></table></figure></p>
<p>在lab8106和lab8107上监控磁盘<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8107 ~]<span class="comment"># iostat -dm 1</span></span><br></pre></td></tr></table></figure></p>
<p>读取数据<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8107 ~]<span class="comment"># dd if=a of=/dev/null</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到只有lab8107上有磁盘的读取，也就是读取的数据里面肯定也有副本，都是从lab8107上面读取了</p>
<p>如果需要多次测试，需要清除下缓存<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sync; <span class="built_in">echo</span> <span class="number">3</span> &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure></p>
<p>并且重新挂载客户端，这个读取crush的位置的操作是在mount的时候读取的</p>
<h2 id="使用场景">使用场景</h2><p>上面的配置是可以指定多个平级的位置的<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">crush_location = <span class="string">"host=lab8106 host=lab8107 root=default"</span></span><br></pre></td></tr></table></figure></p>
<p>这样，在一些读请求很多的场景下，可以把整个后端按逻辑上划分为一个个的区域，然后前面的客户端就可以平级分配到这些区域当中，这样就可以比较大的限度去把副本的读取也调动起来的</p>
<p>目前在ceph-fuse上已经实现，rbd里面也有类似的一些处理，这个是一个很不错的功能</p>
<h2 id="总结">总结</h2><p>ceph里面有很多可配置的东西，怎么用好它，最大限度的去适配使用场景，还是有很大的可调的空间的，所谓学无止境，我也在学习python coding了，有很多想法等着去实现</p>
<h2 id="变更记录">变更记录</h2><table>
<thead>
<tr>
<th style="text-align:center">Why</th>
<th style="text-align:center">Who</th>
<th style="text-align:center">When</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建</td>
<td style="text-align:center">武汉-运维-磨渣</td>
<td style="text-align:center">2017-04-27</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/read.gif?imageMogr2/thumbnail/!75p" alt=""><br></center>

<h2 id="前言">前言</h2><p>在ceph研发群里面看到一个cepher在问关于怎么读取ceph的副本的问题，这个功能应该在2012年的时候,我们公司的研发就修改了代码去实现这个功能，只是当时的硬件条件所限，以及本身的稳定性问题，后来没有在生产当中使用<br>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于backfill参数建议]]></title>
    <link href="http://www.zphj1987.com/2017/04/27/about-backfill-conf/"/>
    <id>http://www.zphj1987.com/2017/04/27/about-backfill-conf/</id>
    <published>2017-04-27T01:36:17.000Z</published>
    <updated>2017-04-27T02:31:18.735Z</updated>
    <content type="html"><![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/fill.gif" alt=""><br></center>

<h2 id="前言">前言</h2><p>在做一个比较满的集群的扩容的时候，遇到了一些问题，在这里做下总结，一般来说很难遇到，扩容要趁早，不然出的问题都是稀奇古怪的一些问题<br><a id="more"></a></p>
<h2 id="建议">建议</h2><p>环境一般来说在70%左右就需要考虑扩容了，这个时候的扩容数据迁移的少，遇到的问题自然会少很多，所谓的参数设置并不是一个单纯的参数的设置，所以一般来说在调优参数的时候，个人觉得只有适配硬件进行调优，所以本篇的参数同样是一个组合形式的</p>
<p>首先罗列出本篇涉及的所有参数</p>
<blockquote>
<p>mon_osd_full_ratio = 0.95<br>osd_backfill_full_ratio = 0.85<br>osd_max_backfills = 1</p>
</blockquote>
<p>最少的OSD的PG数目</p>
<blockquote>
<p>min_pg=`ceph osd df|awk ‘{print $9}’|awk ‘NF’|grep -v PGS|sort|head -n 1`</p>
</blockquote>
<p>那么最好满足</p>
<blockquote>
<p>(osd_max_backfills/min_pg)+osd_backfill_full_ratio &lt; mon_osd_full_ratio</p>
</blockquote>
<p>这个在老版本里面进行backfill full的检测的时候，只在启动backfill的时候做了检测，如果设置的backfill足够大，而迁移的又足够多的时候，就会一下涌过去，直径把OSD给弄full然后挂掉了，新版本还没验证是否做了实时控制，但是如果遵循了上面的设置，即使没控制一样不会出问题</p>
<h2 id="总结">总结</h2><p>有的参数不光对速度有控制，对量上面同样可能有影响，所以在设置的时候，需要尽量综合考虑</p>
<h2 id="变更记录">变更记录</h2><table>
<thead>
<tr>
<th style="text-align:center">Why</th>
<th style="text-align:center">Who</th>
<th style="text-align:center">When</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建</td>
<td style="text-align:center">武汉-运维-磨渣</td>
<td style="text-align:center">2017-04-27</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/fill.gif" alt=""><br></center>

<h2 id="前言">前言</h2><p>在做一个比较满的集群的扩容的时候，遇到了一些问题，在这里做下总结，一般来说很难遇到，扩容要趁早，不然出的问题都是稀奇古怪的一些问题<br>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mds/journal.cc: 2929: FAILED assert解决]]></title>
    <link href="http://www.zphj1987.com/2017/04/27/mds-journal-cc-2929-FAILED-assert/"/>
    <id>http://www.zphj1987.com/2017/04/27/mds-journal-cc-2929-FAILED-assert/</id>
    <published>2017-04-27T01:24:39.000Z</published>
    <updated>2017-04-27T01:31:00.360Z</updated>
    <content type="html"><![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/session.png" alt=""><br></center>

<h2 id="前言">前言</h2><p>在处理一个其他双活MDS无法启动环境的时候，查看mds的日志看到了这个错误mds/journal.cc: 2929: FAILED assert(mds-&gt;sessionmap.get_version() == cmapv)，在查询资料以后，暂时得到了解决,在生产环境下还是不建议使用双活MDS<br><a id="more"></a></p>
<h2 id="处理步骤">处理步骤</h2><p>这个是双MDS多活情况下出现的一个问题，在什么情况下出现还无法判断，目前只看到是有这个问题，并且有其他人也出现了 <a href="http://tracker.ceph.com/issues/17113" target="_blank" rel="external">issue17113</a><br>按照<a href="http://docs.ceph.com/docs/master/cephfs/disaster-recovery/" target="_blank" rel="external">disaster-recovery</a>建议的步骤做了如下处理：</p>
<h3 id="备份下journal">备份下journal</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cephfs-journal-tool journal <span class="built_in">export</span> backup.bin</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cephfs-journal-tool journal reset</span><br><span class="line">cephfs-table-tool all reset session</span><br></pre></td></tr></table></figure>
<p>做了上两步后环境并没有恢复,还有个下面的操作没有做，这个操作会引起数据的丢失， MDS ranks other than 0 will be ignored: as a result it is possible for this to result in data loss，所以暂缓操作<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph fs reset &lt;fs name&gt; --yes-i-really-mean-it</span><br></pre></td></tr></table></figure></p>
<p>再次启动后还是，看到日志提示的是sessionmap的问题，正常情况下这个地方重置了session应该是可以好的</p>
<p>Yan, Zheng 2014年的时候在<a href="https://www.mail-archive.com/ceph-devel@vger.kernel.org/msg18629.html" target="_blank" rel="external">邮件列表</a>里面提过一个配置<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mds wipe_sessions = <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>当时解决一个replay的问题，尝试加入这个参数，然后启动mds</p>
<p>环境恢复了变成了双active，提示还有damage，但是数据属于可访问了</p>
<h3 id="后续操作">后续操作</h3><p>建议是导出数据，重新配置为主备MDS集群，然后倒入数据</p>
<h2 id="变更记录">变更记录</h2><table>
<thead>
<tr>
<th style="text-align:center">Why</th>
<th style="text-align:center">Who</th>
<th style="text-align:center">When</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建</td>
<td style="text-align:center">武汉-运维-磨渣</td>
<td style="text-align:center">2017-04-27</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/session.png" alt=""><br></center>

<h2 id="前言">前言</h2><p>在处理一个其他双活MDS无法启动环境的时候，查看mds的日志看到了这个错误mds/journal.cc: 2929: FAILED assert(mds-&gt;sessionmap.get_version() == cmapv)，在查询资料以后，暂时得到了解决,在生产环境下还是不建议使用双活MDS<br>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[rados put striper功能的调试]]></title>
    <link href="http://www.zphj1987.com/2017/04/26/rados-put-strip-debug/"/>
    <id>http://www.zphj1987.com/2017/04/26/rados-put-strip-debug/</id>
    <published>2017-04-26T08:00:40.000Z</published>
    <updated>2017-04-26T08:01:51.060Z</updated>
    <content type="html"><![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/strip.jpg" alt="strip"><br></center>

<h2 id="前言">前言</h2><p>之前对于striper这个地方的功能并没研究太多，只是知道这个里面可以以条带方式并行的去写对象，从而加大并发性来提高性能，而默认的条带数目为1，也就是以对象大小去写，并没有条带，所以不是很好感觉到差别，今天就尝试下用rados命令来看下这个条带是怎么回事<br><a id="more"></a></p>
<h2 id="实践过程">实践过程</h2><p>最开始我的集群是用rpm包进行安装的，这个可以做一些常规的测试，如果需要改动一些代码的话，就比较麻烦了，本文后面会讲述怎么改动一点点代码，然后进行测试</p>
<p>我们一般来说用rados put操作就是一个完整的文件，并不会进行拆分，我们尝试下看下<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># dd if=/dev/zero of=16M bs=4M count=4</span></span><br><span class="line">[root@lab8106 ~]<span class="comment"># rados  -p rbd put 16M 16M</span></span><br><span class="line">[root@lab8106 ~]<span class="comment"># rados  -p rbd stat 16M</span></span><br><span class="line">rbd/<span class="number">16</span>M mtime <span class="number">2017</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">15</span>:<span class="number">08</span>:<span class="number">14.000000</span>, size <span class="number">16777216</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到我们put 16M的文件，在后台就是一个16M的对象</p>
<p>这个rados命令还有个参数是striper<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># rados  --help|grep stri</span></span><br><span class="line">   --striper</span><br><span class="line">        Use radostriper interface rather than pure rados</span><br></pre></td></tr></table></figure></p>
<p>我们来用这个命令试一下<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># dd if=/dev/zero of=strip16M bs=4M count=4</span></span><br><span class="line">[root@lab8106 ~]<span class="comment"># rados  -p rbd put strip16M strip16M --striper</span></span><br><span class="line">[root@lab8106 ~]<span class="comment"># rados  -p rbd ls |grep strip</span></span><br><span class="line">strip16M.<span class="number">0000000000000002</span></span><br><span class="line">strip16M.<span class="number">0000000000000003</span></span><br><span class="line">strip16M.<span class="number">0000000000000000</span></span><br><span class="line">strip16M.<span class="number">0000000000000001</span></span><br><span class="line">[root@lab8106 ~]<span class="comment"># rados  -p rbd  --striper ls |grep strip</span></span><br><span class="line">strip16M</span><br><span class="line">[root@lab8106 ~]<span class="comment">#  rados  -p rbd stat strip16M.0000000000000002</span></span><br><span class="line">rbd/strip16M.<span class="number">0000000000000002</span> mtime <span class="number">2017</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">15</span>:<span class="number">11</span>:<span class="number">06.000000</span>, size <span class="number">4194304</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到这个16M的文件是被拆分成了4M一个的对象，存储到了后台的,我们开启下日志后看下有没有什么详细的信息，因为在rados参数当中确实没有找到可配置的选项<br>在/etc/ceph/ceph.conf当中添加<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">debug_rados=<span class="number">20</span></span><br><span class="line">debug_striper=<span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<p>再次测试<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># dd if=/dev/zero of=strip116M bs=4M count=4</span></span><br><span class="line">[root@lab8106 ~]<span class="comment"># rados  -p rbd put strip116M strip116M --striper</span></span><br><span class="line">···</span><br><span class="line">sc is one, reset su to os</span><br><span class="line">su <span class="number">4194304</span> sc <span class="number">1</span> os <span class="number">4194304</span> stripes_per_object <span class="number">1</span></span><br><span class="line">···</span><br></pre></td></tr></table></figure></p>
<p>这个地方解释下意思</p>
<blockquote>
<p>strip count is 1,重置strip unit为object size ，也就是4M<br>strip unit 4194304 ，strip count 1，object size 4194304,每个对象的条带为1</p>
</blockquote>
<p>这个代码里面写了<br><a href="https://github.com/ceph/ceph/blob/master/src/tools/rados/rados.cc" target="_blank" rel="external">https://github.com/ceph/ceph/blob/master/src/tools/rados/rados.cc</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--striper</span><br><span class="line">       Use radostriper interface rather than pure rados</span><br></pre></td></tr></table></figure></p>
<p>也就是这个rados在加了参数之后是调用了radostriper interface这个接口的，所以猜测这个条带的相关参数应该是在接口里面写死了的<br><a href="https://github.com/ceph/ceph/blob/master/src/libradosstriper/RadosStriperImpl.cc" target="_blank" rel="external">https://github.com/ceph/ceph/blob/master/src/libradosstriper/RadosStriperImpl.cc</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/// default object layout</span><br><span class="line">struct ceph_file_layout default_file_layout = &#123;</span><br><span class="line"> fl_stripe_unit: init_le32(<span class="number">1</span>&lt;&lt;<span class="number">22</span>),</span><br><span class="line"> fl_stripe_count: init_le32(<span class="number">1</span>),</span><br><span class="line"> fl_object_size: init_le32(<span class="number">1</span>&lt;&lt;<span class="number">22</span>),</span><br><span class="line"> fl_cas_<span class="built_in">hash</span>: init_le32(<span class="number">0</span>),</span><br><span class="line"> fl_object_stripe_unit: init_le32(<span class="number">0</span>),</span><br><span class="line"> fl_unused: init_le32(-<span class="number">1</span>),</span><br><span class="line"> fl_pg_pool : init_le32(-<span class="number">1</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面开始看下调试模式下改下这几个数值</p>
<h3 id="下载代码">下载代码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ceph/ceph.git</span><br><span class="line">git checkout -b myceph2 v10.<span class="number">2.3</span></span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>
<p>切换到10.2.3版本,用的make模式，没用cmake<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ceph</span><br><span class="line">./install-deps.sh</span><br><span class="line">./autogen.sh</span><br><span class="line">./configure</span><br><span class="line">make -j <span class="number">12</span></span><br></pre></td></tr></table></figure></p>
<p>启动开发模式服务<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">./vstart.sh --mon_num <span class="number">1</span> --osd_num <span class="number">3</span> --mds_num <span class="number">1</span>  --short -n <span class="operator">-d</span></span><br></pre></td></tr></table></figure></p>
<p>这样，dev cluster就起来了。修改部分源码重新make之后，需要关闭cluster，重启让代码生效，当然最好的是，你修改哪个模块，就重启那个模块就行，这里使用重启集群<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./stop.sh all</span><br><span class="line">./vstart.sh --mon_num <span class="number">1</span> --osd_num <span class="number">3</span> --mds_num <span class="number">1</span> --short  <span class="operator">-d</span></span><br></pre></td></tr></table></figure></p>
<p>查看状态<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 src]<span class="comment"># ./ceph -s -c ./ceph.conf</span></span><br></pre></td></tr></table></figure></p>
<p>我们修改下代码<br>vim libradosstriper/RadosStriperImpl.cc<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/// default object layout</span><br><span class="line">struct ceph_file_layout default_file_layout = &#123;</span><br><span class="line"> fl_stripe_unit: init_le32(<span class="number">1</span>&lt;&lt;<span class="number">21</span>),</span><br><span class="line"> fl_stripe_count: init_le32(<span class="number">2</span>),</span><br><span class="line"> fl_object_size: init_le32(<span class="number">1</span>&lt;&lt;<span class="number">22</span>),</span><br><span class="line"> fl_cas_<span class="built_in">hash</span>: init_le32(<span class="number">0</span>),</span><br><span class="line"> fl_object_stripe_unit: init_le32(<span class="number">0</span>),</span><br><span class="line"> fl_unused: init_le32(-<span class="number">1</span>),</span><br><span class="line"> fl_pg_pool : init_le32(-<span class="number">1</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>修改的是stripe_unit为2M，stripe_count为2，object_size为4M，也就是条带为2<br>修改完了后重新make<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./stop.sh all</span><br><span class="line">./vstart.sh --mon_num <span class="number">1</span> --osd_num <span class="number">3</span> --mds_num <span class="number">1</span> --short  <span class="operator">-d</span></span><br></pre></td></tr></table></figure></p>
<p>初始化集群，修改下配置文件增加调试信息<br>vim ./ceph.conf<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">debug_rados=<span class="number">20</span></span><br><span class="line">debug_striper=<span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<p>创建文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># dd if=/dev/zero of=debugstrip16M bs=4M count=4</span></span><br><span class="line">[root@lab8106 src]<span class="comment"># ./rados -c ./ceph.conf --striper  -p rbd  put  debugstrip16M debugstrip16M</span></span><br><span class="line">[root@lab8106 src]<span class="comment">#./rados -c ./ceph.conf  -p rbd  stat debugstrip16M.0000000000000001</span></span><br><span class="line">rbd/debugstrip16M.<span class="number">0000000000000001</span> mtime <span class="number">2017</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">15</span>:<span class="number">38</span>:<span class="number">41.483464</span> </span><br><span class="line"><span class="number">2017</span>-<span class="number">04</span>-<span class="number">26</span> <span class="number">15</span>:<span class="number">37</span>:<span class="number">27.000000</span>, size <span class="number">4194304</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到对象还是4M<br>我们截取下日志分析<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su <span class="number">2097152</span> sc <span class="number">2</span> os <span class="number">4194304</span> stripes_per_object <span class="number">2</span></span><br><span class="line">off <span class="number">0</span> blockno <span class="number">0</span> stripeno <span class="number">0</span> stripepos <span class="number">0</span> objectsetno <span class="number">0</span> objectno <span class="number">0</span> block_start <span class="number">0</span></span><br><span class="line">added new extent(debugstrip16M.<span class="number">0000000000000000</span> (<span class="number">0</span>) </span><br><span class="line">off <span class="number">2097152</span> blockno <span class="number">1</span> stripeno <span class="number">0</span> stripepos <span class="number">1</span> objectsetno <span class="number">0</span> objectno <span class="number">1</span> block_start <span class="number">0</span> </span><br><span class="line">added new extent(debugstrip16M.<span class="number">0000000000000001</span> (<span class="number">1</span>) </span><br><span class="line">off <span class="number">4194304</span> blockno <span class="number">2</span> stripeno <span class="number">1</span> stripepos <span class="number">0</span> objectsetno <span class="number">0</span> objectno <span class="number">0</span> block_start <span class="number">2097152</span></span><br><span class="line">added new extent(debugstrip16M.<span class="number">0000000000000000</span> (<span class="number">0</span>)   </span><br><span class="line">off <span class="number">6291456</span> blockno <span class="number">3</span> stripeno <span class="number">1</span> stripepos <span class="number">1</span> objectsetno <span class="number">0</span> objectno <span class="number">1</span> block_start <span class="number">2097152</span></span><br><span class="line">added new extent(debugstrip16M.<span class="number">0000000000000001</span> (<span class="number">1</span>)</span><br><span class="line">off <span class="number">8388608</span> blockno <span class="number">4</span> stripeno <span class="number">2</span> stripepos <span class="number">0</span> objectsetno <span class="number">1</span> objectno <span class="number">2</span> block_start <span class="number">0</span></span><br><span class="line">added new extent(debugstrip16M.<span class="number">0000000000000002</span> (<span class="number">2</span>) </span><br><span class="line">off <span class="number">10485760</span> blockno <span class="number">5</span> stripeno <span class="number">2</span> stripepos <span class="number">1</span> objectsetno <span class="number">1</span> objectno <span class="number">3</span> block_start <span class="number">0</span></span><br><span class="line">added new extent(debugstrip16M.<span class="number">0000000000000003</span> (<span class="number">3</span>) </span><br><span class="line">off <span class="number">12582912</span> blockno <span class="number">6</span> stripeno <span class="number">3</span> stripepos <span class="number">0</span> objectsetno <span class="number">1</span> objectno <span class="number">2</span> block_start <span class="number">2097152</span> </span><br><span class="line">added new extent(debugstrip16M.<span class="number">0000000000000002</span> (<span class="number">2</span>)</span><br><span class="line">off <span class="number">14680064</span> blockno <span class="number">7</span> stripeno <span class="number">3</span> stripepos <span class="number">1</span> objectsetno <span class="number">1</span> objectno <span class="number">3</span> block_start <span class="number">2097152</span> </span><br><span class="line">added new extent(debugstrip16M.<span class="number">0000000000000003</span> (<span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看到先在debugstrip16M.0000000000000000写了2M，在debugstrip16M.0000000000000001写了2M，<br>然后在debugstrip16M.0000000000000000追加写了2M，并且是从block_start 2097152开始的，每个对象是写了两次的并且每次写的就是条带的大小的2M，跟修改上面的条带大小和对象大小是一致的，并且可以很清楚的看到写对象的过程</p>
<h2 id="总结">总结</h2><p>本篇尝试了用rados来测试strip功能，并且顺带讲了下怎么在开发模式下修改代码并测试，如果自己写客户端的话，利用librados的时候，可以考虑使用libradosstriper条带来增加一定的性能</p>
<h2 id="参考文档">参考文档</h2><p><a href="http://ivanjobs.github.io/2016/05/11/prepare-ceph-dev-env/" target="_blank" rel="external">准备Ceph开发环境</a></p>
<h2 id="变更记录">变更记录</h2><table>
<thead>
<tr>
<th style="text-align:center">Why</th>
<th style="text-align:center">Who</th>
<th style="text-align:center">When</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建</td>
<td style="text-align:center">武汉-运维-磨渣</td>
<td style="text-align:center">2017-04-26</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/strip.jpg" alt="strip"><br></center>

<h2 id="前言">前言</h2><p>之前对于striper这个地方的功能并没研究太多，只是知道这个里面可以以条带方式并行的去写对象，从而加大并发性来提高性能，而默认的条带数目为1，也就是以对象大小去写，并没有条带，所以不是很好感觉到差别，今天就尝试下用rados命令来看下这个条带是怎么回事<br>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cephfs的文件存到哪里了]]></title>
    <link href="http://www.zphj1987.com/2017/04/20/where-is-cephfs-data-store/"/>
    <id>http://www.zphj1987.com/2017/04/20/where-is-cephfs-data-store/</id>
    <published>2017-04-20T02:22:17.000Z</published>
    <updated>2017-07-12T09:55:18.668Z</updated>
    <content type="html"><![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/file.png" alt="file"><br></center>

<h2 id="前言">前言</h2><p>在ceph里面使用rbd接口的时候，存储的数据在后台是以固定的prifix的对象存在的，这样就能根据相同的前缀对象去对image文件进行拼接或者修复</p>
<p>在文件系统里面这一块就要复杂一些，本篇就写的关于这个，文件和对象的对应关系是怎样的，用系统命令怎么定位，又是怎么得到这个路径的<br><a id="more"></a></p>
<h2 id="实践">实践</h2><h3 id="根据系统命令进行文件的定位">根据系统命令进行文件的定位</h3><p>写入测试文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/mnt/testfile bs=<span class="number">4</span>M count=<span class="number">10</span></span><br></pre></td></tr></table></figure></p>
<p>查看文件的映射<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 mnt]<span class="comment"># cephfs /mnt/testfile  map</span></span><br><span class="line">WARNING: This tool is deprecated.  Use the layout.* xattrs to query and modify layouts.</span><br><span class="line">    FILE OFFSET                    OBJECT        OFFSET        LENGTH  OSD</span><br><span class="line">              <span class="number">0</span>      <span class="number">10000001188.00000000</span>             <span class="number">0</span>       <span class="number">4194304</span>  <span class="number">1</span></span><br><span class="line">        <span class="number">4194304</span>      <span class="number">10000001188.00000001</span>             <span class="number">0</span>       <span class="number">4194304</span>  <span class="number">0</span></span><br><span class="line">        <span class="number">8388608</span>      <span class="number">10000001188.00000002</span>             <span class="number">0</span>       <span class="number">4194304</span>  <span class="number">1</span></span><br><span class="line">       <span class="number">12582912</span>      <span class="number">10000001188.00000003</span>             <span class="number">0</span>       <span class="number">4194304</span>  <span class="number">0</span></span><br><span class="line">       <span class="number">16777216</span>      <span class="number">10000001188.00000004</span>             <span class="number">0</span>       <span class="number">4194304</span>  <span class="number">1</span></span><br><span class="line">       <span class="number">20971520</span>      <span class="number">10000001188.00000005</span>             <span class="number">0</span>       <span class="number">4194304</span>  <span class="number">0</span></span><br><span class="line">       <span class="number">25165824</span>      <span class="number">10000001188.00000006</span>             <span class="number">0</span>       <span class="number">4194304</span>  <span class="number">0</span></span><br><span class="line">       <span class="number">29360128</span>      <span class="number">10000001188.00000007</span>             <span class="number">0</span>       <span class="number">4194304</span>  <span class="number">1</span></span><br><span class="line">       <span class="number">33554432</span>      <span class="number">10000001188.00000008</span>             <span class="number">0</span>       <span class="number">4194304</span>  <span class="number">1</span></span><br><span class="line">       <span class="number">37748736</span>      <span class="number">10000001188.00000009</span>             <span class="number">0</span>       <span class="number">4194304</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>查找文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 mnt]<span class="comment"># ceph osd map data 10000001188.00000000</span></span><br><span class="line">osdmap e109 pool <span class="string">'data'</span> (<span class="number">2</span>) object <span class="string">'10000001188.00000000'</span> -&gt; pg <span class="number">2.9865</span>f84d (<span class="number">2</span>.d) -&gt; up ([<span class="number">1</span>], p1) acting ([<span class="number">1</span>], p1)</span><br><span class="line">[root@lab8106 mnt]<span class="comment"># ll /var/lib/ceph/osd/ceph-1/current/2.d_head/10000001188.00000000__head_9865F84D__2 </span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> ceph ceph <span class="number">4194304</span> Apr <span class="number">20</span> <span class="number">09</span>:<span class="number">35</span> /var/lib/ceph/osd/ceph-<span class="number">1</span>/current/<span class="number">2</span>.d_head/<span class="number">10000001188.00000000</span>__head_9865F84D__2</span><br></pre></td></tr></table></figure></p>
<p>根据上面的命令已经把文件和对象的关系找到了，我们要看下这个关系是根据什么计算出来的</p>
<h3 id="根据算法进行文件定位">根据算法进行文件定位</h3><p>写入测试文件(故意用bs=3M模拟后台不为整的情况)<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># dd if=/dev/zero of=/mnt/myfile bs=3M count=10</span></span><br></pre></td></tr></table></figure></p>
<p>获取文件的inode信息<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># fileinode=`stat  -c %i  "/mnt/myfile"`</span></span><br><span class="line">[root@lab8106 ~]<span class="comment"># echo $fileinode</span></span><br></pre></td></tr></table></figure></p>
<p>获取文件的大小和对象个数信息<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># filesize=`stat  -c %s  "/mnt/myfile"`</span></span><br><span class="line">[root@lab8106 ~]<span class="comment"># echo $filesize</span></span><br><span class="line"><span class="number">31457280</span></span><br><span class="line">[root@lab8106 ~]<span class="comment"># objectnumori=`echo "scale = 1; $filesize/$objectsize"|bc`</span></span><br><span class="line">[root@lab8106 ~]<span class="comment"># echo $objectnumori</span></span><br><span class="line"><span class="number">7.5</span></span><br><span class="line">[root@lab8106 ~]<span class="comment"># objectnum=`echo $(($&#123;objectnumori//.*/+1&#125;))`</span></span><br><span class="line">[root@lab8106 ~]<span class="comment"># echo $objectnum</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<p>获取对象名称前缀<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># declare -l $objectname</span></span><br><span class="line">[root@lab8106 ~]<span class="comment"># objectname=`echo "obase=16;$fileinode"|bc`</span></span><br><span class="line">[root@lab8106 ~]<span class="comment"># echo $objectname</span></span><br><span class="line"><span class="number">1000000118</span>b</span><br></pre></td></tr></table></figure></p>
<p>上面的declare -l操作后，对象名称的变量才能自动赋值为小写的，否则的话就是大写的，会出现对应不上的问题<br>对象的后缀(后面的0即为编号)<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment">#objectbackname=`printf "%.8x\n" 0`</span></span><br><span class="line">[root@lab8106 ~]<span class="comment">#echo $objectbackname</span></span><br></pre></td></tr></table></figure></p>
<p>真正的对象名称为：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment">#realobjectback=$objectname.$objectbackname</span></span><br></pre></td></tr></table></figure></p>
<p>打印出所有对象名称<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># for num in `seq  0 $objectnum` ;do backname=`printf "%.8x\n" $num`;echo $objectname.$backname;done;</span></span><br><span class="line"><span class="number">1000000118</span>b.<span class="number">00000000</span></span><br><span class="line"><span class="number">1000000118</span>b.<span class="number">00000001</span></span><br><span class="line"><span class="number">1000000118</span>b.<span class="number">00000002</span></span><br><span class="line"><span class="number">1000000118</span>b.<span class="number">00000003</span></span><br><span class="line"><span class="number">1000000118</span>b.<span class="number">00000004</span></span><br><span class="line"><span class="number">1000000118</span>b.<span class="number">00000005</span></span><br><span class="line"><span class="number">1000000118</span>b.<span class="number">00000006</span></span><br><span class="line"><span class="number">1000000118</span>b.<span class="number">00000007</span></span><br><span class="line"><span class="number">1000000118</span>b.<span class="number">00000008</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到用算法进行定位的时候，整个过程都没有跟集群ceph进行查询交互，只用到了获取文件的stat的信息，所以根据算法就可以完全定位到具体的对象名称了</p>
<h2 id="根据对象名称查找文件所在的位置">根据对象名称查找文件所在的位置</h2><p>假如一个对象名称如下：</p>
<blockquote>
<p>10000000010.00000003</p>
</blockquote>
<p>对象名称取10000000010前面加上0x,并且去掉.后面的，得到:</p>
<blockquote>
<p>0x10000000010</p>
</blockquote>
<p>计算出inode:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 mnt]<span class="comment">#printf "%d\n" 0x10000000010</span></span><br><span class="line"><span class="number">1099511627792</span></span><br></pre></td></tr></table></figure></p>
<p>根据inode查找文件路径<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 mnt]<span class="comment"># find /mnt/  -inum 1099511627792 -printf "%i %p\n"</span></span><br><span class="line"><span class="number">1099511627792</span> /mnt/testfile</span><br></pre></td></tr></table></figure></p>
<h2 id="总结">总结</h2><p>本篇是介绍了cephfs中文件跟后台具体对象对应的关系，这个对于系统的可恢复性上面还是有很大的作用的，在cephfs当中只要对象还在，数据就还在，哪怕所有的服务全挂掉，这个在之前的某个别人的生产环境当中已经实践过一次，当然那个是rbd的相对来说要简单一些，当然文件系统的恢复也可以用OSD重构集群的方式进行恢复，本篇的对于元数据丢失的情况下文件恢复会有一定的指导作用</p>
<h2 id="变更记录">变更记录</h2><table>
<thead>
<tr>
<th style="text-align:center">Why</th>
<th style="text-align:center">Who</th>
<th style="text-align:center">When</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建</td>
<td style="text-align:center">武汉-运维-磨渣</td>
<td style="text-align:center">2017-04-20</td>
</tr>
<tr>
<td style="text-align:center">增加根据对象查找文件位置</td>
<td style="text-align:center">武汉-运维-磨渣</td>
<td style="text-align:center">2017-07-12</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/file.png" alt="file"><br></center>

<h2 id="前言">前言</h2><p>在ceph里面使用rbd接口的时候，存储的数据在后台是以固定的prifix的对象存在的，这样就能根据相同的前缀对象去对image文件进行拼接或者修复</p>
<p>在文件系统里面这一块就要复杂一些，本篇就写的关于这个，文件和对象的对应关系是怎样的，用系统命令怎么定位，又是怎么得到这个路径的<br>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为什么删除的Ceph对象还能get]]></title>
    <link href="http://www.zphj1987.com/2017/04/19/why-rm-object-can-get/"/>
    <id>http://www.zphj1987.com/2017/04/19/why-rm-object-can-get/</id>
    <published>2017-04-19T07:12:42.000Z</published>
    <updated>2017-04-19T07:19:25.755Z</updated>
    <content type="html"><![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/rm.jpg" alt="rm"><br></center>

<h2 id="前言">前言</h2><p>在很久以前在研究一套文件系统的时候，当时发现一个比较奇怪的现象，没有文件存在，磁盘容量还在增加，在研究了一段时间后，发现这里面有一种比较奇特的处理逻辑</p>
<p>这套文件系统在处理一个文件的时候放入的是一个临时目录，最开始在发送第一个写请求后，在操作系统层面马上进行了一个delete操作，而写还在继续，并且需要处理这个数据的进程一直占着的，一旦使用完这个文件，不需要做处理，这个文件就会自动释放掉，而无需担心临时文件占用空间的问题</p>
<p>在Ceph集群当中，有人碰到了去后台的OSD直接rm一个对象后，在前端通过rados还能get到这个删除的对象，而不能rados ls到，我猜测就是这个原因，我们来看下怎么验证这个问题<br><a id="more"></a></p>
<h2 id="验证步骤">验证步骤</h2><h3 id="准备测试数据，并且put进去集群">准备测试数据，并且put进去集群</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># cat zp1 </span></span><br><span class="line">sdasdasd</span><br><span class="line">[root@lab8106 ~]<span class="comment"># rados  -p rbd put zp1 zp1</span></span><br><span class="line">[root@lab8106 ~]<span class="comment"># rados -p rbd ls</span></span><br><span class="line">zp1</span><br></pre></td></tr></table></figure>
<h3 id="找到测试数据并且直接_rm_删除">找到测试数据并且直接 rm 删除</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># ceph osd map rbd zp1</span></span><br><span class="line">osdmap e90 pool <span class="string">'rbd'</span> (<span class="number">3</span>) object <span class="string">'zp1'</span> -&gt; pg <span class="number">3.43</span>eb7bdb (<span class="number">3.1</span>b) -&gt; up ([<span class="number">0</span>], p0) acting ([<span class="number">0</span>], p0)</span><br><span class="line">[root@lab8106 ~]<span class="comment"># ll /var/lib/ceph/osd/ceph-0/current/3.1b_head/DIR_B/DIR_D/zp1__head_43EB7BDB__3 </span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> ceph ceph <span class="number">9</span> Apr <span class="number">19</span> <span class="number">14</span>:<span class="number">46</span> /var/lib/ceph/osd/ceph-<span class="number">0</span>/current/<span class="number">3.1</span>b_head/DIR_B/DIR_D/zp1__head_43EB7BDB__3</span><br><span class="line">[root@lab8106 ~]<span class="comment"># rm -rf /var/lib/ceph/osd/ceph-0/current/3.1b_head/DIR_B/DIR_D/zp1__head_43EB7BDB__3</span></span><br></pre></td></tr></table></figure>
<h3 id="尝试查询数据，get数据">尝试查询数据，get数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 tmp]<span class="comment"># rados  -p rbd ls</span></span><br><span class="line">[root@lab8106 tmp]<span class="comment"># rados  -p rbd get zp1 zp1</span></span><br><span class="line">[root@lab8106 tmp]<span class="comment"># cat zp1</span></span><br><span class="line">sdasdasd</span><br></pre></td></tr></table></figure>
<p>可以看到数据确实可以查询不到，但是能get下来，并且数据是完整的</p>
<h3 id="验证我的猜测">验证我的猜测</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 tmp]<span class="comment"># lsof |grep zp1</span></span><br><span class="line">ms_pipe_w  <span class="number">4737</span>  <span class="number">5620</span>           ceph   <span class="number">86</span>u      REG               <span class="number">8</span>,<span class="number">33</span>          <span class="number">9</span>  <span class="number">201496748</span> /var/lib/ceph/osd/ceph-<span class="number">0</span>/current/<span class="number">3.1</span>b_head/DIR_B/DIR_D/zp1__head_43EB7BDB__3 (deleted)</span><br><span class="line">···</span><br></pre></td></tr></table></figure>
<p>可以看到这个标记为delete的对象就是我们删除的zp1，这个输出的意思是，进程4737上面删除了一个文件，文件描述符为86的</p>
<p>我们直接去拷贝下这个数据看下<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 tmp]<span class="comment"># cp  /proc/4737/fd/86 /tmp/zp_save</span></span><br><span class="line">[root@lab8106 tmp]<span class="comment"># cat /tmp/zp_save </span></span><br><span class="line">sdasdasd</span><br></pre></td></tr></table></figure></p>
<p>可以看到这个数据确实是存在的，还没有释放，所有可以get的到</p>
<p>我们试下重启下这个进程，看下delete的文件是不是会释放<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 tmp]<span class="comment"># systemctl restart ceph-osd@0</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 tmp]<span class="comment"># lsof |grep zp1</span></span><br></pre></td></tr></table></figure>
<p>可以看到已经没有这个delete了，现在我们尝试下get<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 tmp]<span class="comment"># rados  -p rbd get zp1 zp1</span></span><br><span class="line">error getting rbd/zp1: (<span class="number">2</span>) No such file or directory</span><br></pre></td></tr></table></figure></p>
<p>可以看到文件释放掉了，问题确实跟我猜测的是一致的，当然这并不是什么问题</p>
<h2 id="总结">总结</h2><p>本篇是对删除了的对象还能get的现象进行了解释</p>
<h2 id="变更记录">变更记录</h2><table>
<thead>
<tr>
<th style="text-align:center">Why</th>
<th style="text-align:center">Who</th>
<th style="text-align:center">When</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建</td>
<td style="text-align:center">武汉-运维-磨渣</td>
<td style="text-align:center">2017-04-19</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/rm.jpg" alt="rm"><br></center>

<h2 id="前言">前言</h2><p>在很久以前在研究一套文件系统的时候，当时发现一个比较奇怪的现象，没有文件存在，磁盘容量还在增加，在研究了一段时间后，发现这里面有一种比较奇特的处理逻辑</p>
<p>这套文件系统在处理一个文件的时候放入的是一个临时目录，最开始在发送第一个写请求后，在操作系统层面马上进行了一个delete操作，而写还在继续，并且需要处理这个数据的进程一直占着的，一旦使用完这个文件，不需要做处理，这个文件就会自动释放掉，而无需担心临时文件占用空间的问题</p>
<p>在Ceph集群当中，有人碰到了去后台的OSD直接rm一个对象后，在前端通过rados还能get到这个删除的对象，而不能rados ls到，我猜测就是这个原因，我们来看下怎么验证这个问题<br>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ceph删除OSD上一个异常object]]></title>
    <link href="http://www.zphj1987.com/2017/04/19/ceph-delete-an-error-object/"/>
    <id>http://www.zphj1987.com/2017/04/19/ceph-delete-an-error-object/</id>
    <published>2017-04-19T06:12:59.000Z</published>
    <updated>2017-04-19T06:18:23.297Z</updated>
    <content type="html"><![CDATA[<p><center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/delete.png" alt="delete"><br></center></p>
<h2 id="前言">前言</h2><p>ceph里面的数据是以对象的形式存储在OSD当中的，有的时候因为磁盘的损坏或者其它的一些特殊情况，会引起集群当中的某一个对象的异常，那么我们需要对这个对象进行处理</p>
<p>在对象损坏的情况下，启动OSD有的时候都会有问题，那么通过rados rm的方式是没法发送到这个无法启动的OSD的，也就无法删除，所以需要用其他的办法来处理这个情况<br><a id="more"></a></p>
<h2 id="处理步骤">处理步骤</h2><h3 id="查找对象的路径">查找对象的路径</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment"># ceph osd map rbd  rbd_data.857e6b8b4567.00000000000000ba</span></span><br><span class="line">osdmap e53 pool <span class="string">'rbd'</span> (<span class="number">0</span>) object <span class="string">'rbd_data.857e6b8b4567.00000000000000ba'</span> -&gt; pg <span class="number">0.2</span>daee1ba (<span class="number">0.3</span>a) -&gt; up ([<span class="number">1</span>], p1) acting ([<span class="number">1</span>], p1)</span><br></pre></td></tr></table></figure>
<p>先找到这个对象所在的OSD以及PG</p>
<h3 id="设置集群的noout">设置集群的noout</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment">#ceph osd set noout</span></span><br></pre></td></tr></table></figure>
<p>这个是为了防止osd的停止产生不必要的删除</p>
<h3 id="停止OSD">停止OSD</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ]<span class="comment">#systemctl stop ceph-osd@1</span></span><br></pre></td></tr></table></figure>
<p>如果osd已经是停止的状态就不需要做这一步</p>
<h3 id="使用ceph-objectstore-tool工具删除单个对象">使用ceph-objectstore-tool工具删除单个对象</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ]<span class="comment">#ceph-objectstore-tool --data-path /var/lib/ceph/osd/ceph-1/ --journal-path /var/lib/ceph/osd/ceph-1/journal --pgid 0.3a  rbd_data.857e6b8b4567.00000000000000ba remove</span></span><br></pre></td></tr></table></figure>
<p>如果有多个副本的情况下，最好都删除掉，影响的数据就是包含这个对象的数据，这个操作的前提是这个对象数据已经被破坏了，如果是部分破坏，可以用集群的repair进行修复，这个是无法修复的情况下的删除对象，来实现启动OSD而不影响其它的数据的</p>
<h3 id="启动OSD">启动OSD</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ]<span class="comment"># systemctl start ceph-osd@1</span></span><br></pre></td></tr></table></figure>
<h3 id="解除noout">解除noout</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lab8106 ~]<span class="comment">#ceph osd unset noout</span></span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2><p>一般情况下比较少出现这个情况，如果有这样的删除损坏的对象的需求，就可以这么处理</p>
<h2 id="变更记录">变更记录</h2><table>
<thead>
<tr>
<th style="text-align:center">Why</th>
<th style="text-align:center">Who</th>
<th style="text-align:center">When</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建</td>
<td style="text-align:center">武汉-运维-磨渣</td>
<td style="text-align:center">2017-04-19</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<p><center><br><img src="http://7xweck.com1.z0.glb.clouddn.com/delete.png" alt="delete"><br></center></p>
<h2 id="前言">前言</h2><p>ceph里面的数据是以对象的形式存储在OSD当中的，有的时候因为磁盘的损坏或者其它的一些特殊情况，会引起集群当中的某一个对象的异常，那么我们需要对这个对象进行处理</p>
<p>在对象损坏的情况下，启动OSD有的时候都会有问题，那么通过rados rm的方式是没法发送到这个无法启动的OSD的，也就无法删除，所以需要用其他的办法来处理这个情况<br>]]>
    
    </summary>
    
      <category term="ceph" scheme="http://www.zphj1987.com/tags/ceph/"/>
    
  </entry>
  
</feed>
